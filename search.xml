<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java-swing实战]]></title>
    <url>%2F2020%2F05%2F09%2Fjava-swing%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[开发配置1.intelij 安装swing插件2.新建一个java项目或者mvn项目3.配置jdk和依赖包，构建包文件夹和路径4.设计ui界面，并开发相关代码5.构建项目 注意：由于Swing不是线程安全的, 因此在实际操作过程中, 应避免通过多线程来操作UI; 程序要操作 或 更改界面内容，必须向单一线程执行请求，把这个单一的线程称为事件派发线程（可简称为 UI 线程），所有对于 UI 元素的修改都必须提交给 UI 线程执行，不能在主线程 或 其他任何线程中直接操作 UI的内容，如果要从 UI 线程 或 绘制代码以外的地方 访问 UI，需要使用 SwingUtilities 类的 invokeLater() 或 invokeAndWait() 方法；如果要处理一些耗费大量计算能力 或 受 I/O 能力限制的工作，可以使用一个线程工具类，如：SwingWorker 或 Timer 实战123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199import javax.swing.*;import java.awt.*;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import java.io.BufferedReader;import java.io.InputStreamReader;import java.net.URL;import java.net.URLConnection;import java.util.List;import java.util.concurrent.ExecutionException;import utils.XstormEncode;public class Xstorm extends javax.swing.JFrame &#123; private JPanel mainPanel; private JTabbedPane tabbedPane1; private JTextArea textArea1; private JTextArea textArea2; private JPanel jPanel1; private JPanel jPanel2; private JScrollPane jsPane2; private JScrollPane jsPane1; private JButton btn3; private JButton btn4; private JButton btn1; private JButton btn2; private JPanel jPanel0; private JButton btn5; private JButton btn6; private JButton btn7; private JButton btn8; private JButton btn9; private JButton btn10; private JButton btn11; private JButton btn16; private JPanel StatusMenu; private JLabel StatusLabel; public static void main(String[] args) &#123; SwingUtilities.invokeLater(new Runnable() &#123; @Override public void run() &#123; JFrame frame = new JFrame(); frame.setTitle("JTools By Bing"); JPanel rootPane=new Xstorm().mainPanel; frame.setContentPane(rootPane); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setPreferredSize(new Dimension(900,600)); frame.setSize(900, 600); frame.setLocationRelativeTo(rootPane);//居中 frame.pack(); frame.setVisible(true); &#125; &#125;); &#125; public Xstorm() &#123; btn1.addMouseListener(new MouseAdapter() &#123; @Override public void mouseClicked(MouseEvent e) &#123; // unicode编码 super.mouseClicked(e); String x = XstormEncode.stringToUnicode( textArea1.getText().trim() ); textArea2.setText(x); StatusLabel.setText("字节长度:" + x.getBytes().length + ""); &#125; &#125;); btn2.addMouseListener(new MouseAdapter() &#123; @Override public void mouseClicked(MouseEvent e) &#123; // unicode解码 super.mouseClicked(e); String x = XstormEncode.unicodeToString( textArea2.getText().trim() ); textArea1.setText(x); StatusLabel.setText("字节长度:" + x.getBytes().length + ""); &#125; &#125;); btn3.addMouseListener(new MouseAdapter() &#123; @Override public void mouseClicked(MouseEvent e) &#123; // base64编码 super.mouseClicked(e); String x = XstormEncode.bs64Encode( textArea1.getText().trim() ); textArea2.setText( x ); StatusLabel.setText("字节长度:" + x.getBytes().length + ""); &#125; &#125;); btn4.addMouseListener(new MouseAdapter() &#123; @Override public void mouseClicked(MouseEvent e) &#123; // base64解码 super.mouseClicked(e); String x = XstormEncode.bs64Decode( textArea2.getText().trim() ); textArea1.setText( x ); StatusLabel.setText("字节长度:" + x.getBytes().length + ""); &#125; &#125;); btn5.addMouseListener(new MouseAdapter() &#123; // 二进制转换 @Override public void mouseClicked(MouseEvent e) &#123; super.mouseClicked(e); try &#123; int i = Integer.valueOf(textArea1.getText().trim()); String x = Integer.toBinaryString( i ); textArea2.setText( Integer.toBinaryString( i ) ); StatusLabel.setText("字节长度:" + x.getBytes().length + ""); &#125;catch (Exception ee)&#123; textArea2.setText( "数据类型错误!!!" + ee); &#125; &#125; &#125;); btn6.addMouseListener(new MouseAdapter() &#123; // 八进制转换 @Override public void mouseClicked(MouseEvent e) &#123; super.mouseClicked(e); try &#123; int i = Integer.valueOf(textArea1.getText().trim()); String x = Integer.toOctalString( i ); textArea2.setText( x ); StatusLabel.setText("字节长度:" + x.getBytes().length + ""); &#125;catch (Exception ee)&#123; textArea2.setText( "数据类型错误!!!" + ee ); &#125; &#125; &#125;); btn8.addMouseListener(new MouseAdapter() &#123; @Override public void mouseClicked(MouseEvent e) &#123; // UTF8 字符转十六进制 super.mouseClicked(e); try &#123; int i = Integer.valueOf(textArea1.getText().trim()); textArea2.setText( Integer.toHexString( i ) ); &#125;catch (Exception ee)&#123;// String str = "我是一个字符串";// String hex = HexUtil.encodeHexStr(str, CharsetUtil.CHARSET_UTF_8);// System.out.println(textArea1.getText().trim() + "\n"+ hex); String x = XstormEncode.string2HexUTF8( textArea1.getText().trim()); textArea2.setText( x ); StatusLabel.setText("字节长度:" + x.getBytes().length + ""); &#125; &#125; &#125;); &#125; // 异步操作 public void openUri() &#123; // 异步操作 new SwingWorker&lt;StringBuilder, String&gt;() &#123; @Override protected StringBuilder doInBackground() throws Exception &#123; URL url = new URL("http://www.baidu.com"); URLConnection connection = url.openConnection(); BufferedReader reader = new BufferedReader(new InputStreamReader(connection .getInputStream(), "UTF-8") ); String line; StringBuilder builder = new StringBuilder(); while ((line = reader.readLine()) != null) &#123; // publish(line); builder.append(line).append("\n"); &#125; reader.close(); return builder; &#125; @Override protected void process(List&lt;String&gt; chunks) &#123; // 运行时操作 for (String line:chunks) &#123; textArea1.append(line); textArea1.append("\n"); &#125; super.process(chunks); &#125; @Override protected void done() &#123; // 完成后操作 try &#123; textArea1.setText( get().toString() ); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; super.done(); &#125; &#125;.execute(); //execute方法是异步执行，它立即返回到调用者。在execute方法执行后，EDT立即继续执行 &#125;&#125;]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>swing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[env-jenkins代码扫描]]></title>
    <url>%2F2020%2F05%2F09%2Fenv-jenkins%E4%BB%A3%E7%A0%81%E6%89%AB%E6%8F%8F%2F</url>
    <content type="text"><![CDATA[jenkins整体环境构建流程（gerrit+cobra）1.在geriit创建一个账户, 在Non-Interactive Users组中添加创建的用户，给予event事件权限2.搭建jenkins集群，安装Gerrit Trigger和git插件3.在jenkins集群的master上配置Gerrit Tirgger并添加gerrit新建账户的凭证4.创建文件夹，并创建流程。 可选插件:https://github.com/jenkinsci/coverity-plugin 构建脚本模版 自动拉取代码，需要自己根据参数进行设置。描述部分-》带参数化构建；源码管理-》git 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#!/bin/bash -x#### @Author: Bing# @Date: 2020-04-30 09:59:43# @version: 0.1# @Description: 代码扫描;修改report.py的log增加一个print;修改engine.py的临时运行目录/tmp/cobra为自定义的目录#### tmp_dir=$&#123;PWD&#125;.$$# trap "rm -rf $tmp_dir" 0# rm -rf "$&#123;tmp_dir&#125;"# mkdir -p "$tmp_dir"export REMOTE_SCAN_HOST="$&#123;REMOTE_SCAN_HOST:-root@192.1.1.3&#125;"export GERRIT_USER="$&#123;GERRIT_USER:-xx&#125;"export GERRIT_HOST="$&#123;GERRIT_HOST:-192.168.1.1&#125;"export GERRIT_CMD_BASE="$&#123;GERRIT_CMD_BASE:-ssh -p 29418 $GERRIT_USER@$GERRIT_HOST&#125;"export REVIEW_FEEDBACK_GOOD="$&#123;REVIEW_FEEDBACK_GOOD:---label Coverity-Verified=+1&#125;"export REVIEW_FEEDBACK_BAD="$&#123;REVIEW_FEEDBACK_BAD:---label Coverity-Verified=-1&#125;"# 建立临时扫描目录GERRIT_DIR=$&#123;GERRIT_PROJECT&#125;OLD_IFS="$IFS"IFS="/"arr=($GERRIT_DIR)IFS="$OLD_IFS"last_word="$&#123;arr[$&#123;#arr[@]&#125;-1]&#125;"WORK_DIR=/xxx/cobra/temp/check/$&#123;last_word&#125;ssh $&#123;REMOTE_SCAN_HOST&#125; "rm -rf $&#123;WORK_DIR&#125;"ssh $&#123;REMOTE_SCAN_HOST&#125; "mkdir -p $&#123;WORK_DIR&#125;"# 复制jenkins拉取的项目代码上传到扫描器scp -rq ./* $&#123;REMOTE_SCAN_HOST&#125;:$&#123;WORK_DIR&#125;# 代码扫描review_comments=$( ssh $&#123;REMOTE_SCAN_HOST&#125; "cd /xx/cobra &amp;&amp; \ source /xx/activate &amp;&amp; \ python /xx/cobra.py -t $&#123;WORK_DIR&#125; &gt;&gt; $&#123;last_word&#125;'.txt' &amp;&amp; \ sed -n '1p' $&#123;last_word&#125;'.txt' &amp;&amp; \ rm -rf $&#123;last_word&#125;'.txt'")echo $&#123;review_comments&#125;# 正则匹配结果if [[ $&#123;review_comments&#125; =~ 'xx:9088' ]]; then $GERRIT_CMD_BASE gerrit review $&#123;GERRIT_PATCHSET_REVISION&#125; -p $&#123;GERRIT_PROJECT&#125; -m '"Cobra Scan Successful: "'"$review_comments" $GERRIT_CMD_BASE gerrit review $&#123;GERRIT_PATCHSET_REVISION&#125; $REVIEW_FEEDBACK_GOOD -p $&#123;GERRIT_PROJECT&#125; exit 0else $GERRIT_CMD_BASE gerrit review $&#123;GERRIT_PATCHSET_REVISION&#125; -p $&#123;GERRIT_PROJECT&#125; -m '"Cobra Scan Fail: "'"$review_comments" $GERRIT_CMD_BASE gerrit review $&#123;GERRIT_PATCHSET_REVISION&#125; $REVIEW_FEEDBACK_BAD -p $&#123;GERRIT_PROJECT&#125; exit 0fiecho "Cobra scan finish, exit 1 !"exit 1]]></content>
      <categories>
        <category>misc</category>
      </categories>
      <tags>
        <tag>ci</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习4-tesorflow入门]]></title>
    <url>%2F2019%2F12%2F08%2Fpython-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A04%2F</url>
    <content type="text"><![CDATA[基础安装环境带gpu运算版本：123456C:\Users\Administrator&gt;cd C:\Program Files\NVIDIA Corporation\NVSMIC:\Program Files\NVIDIA Corporation\NVSMI&gt;nvidia-smi Driver Version: 385.54 #需要大于 410 conda activate xxxconda install tensorflow-gpu==2.0.0 其它安装方法:conda环境使用基本命令： 12345conda update -n base conda //update最新版本的condaconda create -n xxxx python=3.5 //创建python3.5的xxxx虚拟环境conda activate xxxx //开启xxxx环境conda deactivate //关闭环境conda env list //显示所有的虚拟环境 查看tensorflow各个版本：（查看会发现有一大堆TensorFlow源，但是不能随便选，选择可以用查找命令定位） 1anaconda search -t conda tensorflow 找到自己安装环境对应的最新TensorFlow后（可以在终端搜索anaconda，定位到那一行），然后查看指定包 1anaconda show &lt;USER/PACKAGE&gt; 查看tensorflow版本信息 1anaconda show anaconda/tensorflow 第4步会提供一个下载地址，使用下面命令就可安装1.8.0版本tensorflow 1conda install --channel https://conda.anaconda.org/anaconda tensorflow=1.8.0 更新，卸载安装包： 123conda list #查看已经安装的文件包conda update xxx #更新xxx文件包conda uninstall xxx #卸载xxx文件包 删除虚拟环境 1conda remove -n xxxx --all //创建xxxx虚拟环境 清理（conda瘦身）conda clean就可以轻松搞定！第一步：通过conda clean -p来删除一些没用的包，这个命令会检查哪些包没有在包缓存中被硬依赖到其他地方，并删除它们。第二步：通过conda clean -t可以将conda保存下来的tar包。 12conda clean -p //删除没有用的包conda clean -t //tar打包 基础操作构造图，执行图，数据转化，变化等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#coding:utf8import timeimport tensorflow as tf now = time.time()# 构造图过程：## 运算操作a = tf.constant(32)b = tf.constant(10)c = tf.add(a, b)d = tf.subtract(a, b)e = tf.multiply(a, b)f = tf.divide( a, b)h = tf.math.mod(a, b)## 类型转化操作a_float = tf.cast( a, dtype=tf.float32 )b_float = tf.cast( b, dtype=tf.float32 )i = tf.sin(a_float) #转换成弧度, 具体得查看计算过程j = tf.exp( tf.divide(1.0, a_float) ) # exp为1的几次方k = tf.add( i, tf.math.log(i) ) # log求底数## 数据矩阵变化：2，2mat_a = tf.constant([1,2,3,4])mat_b = tf.reshape(mat_a, (2,2))## 数据随机化#tf.random_normal # 标准正态分布随机#tf.truncated_normal # truncated正态随机#tf.random_uniform # 均匀分布随机# 执行图过程：sess = tf.compat.v1.Session() # print( a, b, c )# print(sess.run(a*b))# print(sess.run([a,b]))# print(a_float, b_float)# print(i, j, k)# print(sess.run( [a_float, b_float, i, j, k] ))# print( sess.run([mat_a, mat_b]) )sess.close()## variable是可以修改的tensor, constant不是. 也和上面的一样不能直接print打印数据var_a = tf.Variable(1, dtype=tf.int32)var_b = tf.Variable([1,2], dtype=tf.float32)var_w = tf.Variable( tf.zeros( (1024,10) ) )### 开启交互式`session`var_sess = tf.compat.v1.InteractiveSession()### 一次性初始化所有变量init = tf.compat.v1.global_variables_initializer()### 一般`session`的方法var_sess.run(init)### `InteractiveSession`的方法init.run()### 初始化某些变量init_ab = tf.compat.v1.variables_initializer([var_a, var_b])init_ab.run()### 初始化某个变量var_w.initializer.run()W = tf.Variable(10)var_sess.run(W.initializer)print(W)print(var_sess.run(W))print( W.eval() )## Variable赋值assign_op = W.assign(100)W.initializer.run()assign_op.eval()print( W.eval() )end = time.time()print("The program has been running for", end-now, "seconds") 占位符 12345678910111213141516171819#coding:utf8import timeimport tensorflow as tf now = time.time()# 定义占位符a = tf.placeholder(tf.float32, shape=[3])b = tf.placeholder(tf.bool, shape=[1,2])# 占位符代入值sess = tf.compat.v1.Session() print( sess.run(a, feed_dict=&#123;a:[1,2,3]&#125;) )print( sess.run([a,b], feed_dict=&#123;a:[1,2,3], b:[[True, False]]&#125;) )sess.close()end = time.time()print("The program has been running for", end-now, "seconds") Graph 神经网络 深度学习框架1pip install tensorflow==1.8 -i http://mirrors.aliyun.com/pypi/simple tensorflow特点 tensorflow结构123456789101112131415161718192021222324252627282930313233343536373839404142import tensorflow as tfdef ternsorflow_demo(): #原始加法运算 a = 3 b = 3 print( a+b ) #tensorflow实现加法运算 a_t = tf.constant(3) b_t = tf.constant(3) c_t = a_t + b_t print("Tensorflow加法运算的结果: \n", c_t) #开启会话 with tf.Session() as sess: c_t_value = sess.run(c_t) print(c_t_value) return Nonedef getgrah(): #使用默认图 a_t = tf.constant(3) b_t = tf.constant(3) c_t = a_t + b_t #查看默认图--调用方法 default_g = tf.get_dfault_graph() print("默认图: \n", default_g) #查看默认图--查看属性 print("c_t默认图属性: \n", c_t.graph) #开启会话，运行图 with tf.Session() as sess: c_t_value = sess.run(c_t) print(c_t_value) return Noneif __name__ == "__main__": ternsorflow_demo() tensorflow结构分析一个构造图阶段： 流程图：定义数据和操作一个执行图阶段： 调用各方资源，将定义好的数据和操作执行起来 数据流图分析tensor - 张量 - 数据flow - 流动 图与TensorBoard查看默认图的方法,tensorflow默认会创建一个图：调用方法( tf.get_default_graph() )查看属性( op, sess都有图属性 ) 创建图的方法： 123456789101112new_g = tf.Graph()#在自己的图中定义数据和操作 with new_g.as_default(): a_new = tf.constant(3) b_new = tf.constant(32) c_new = a_new + b_new print("c_new: \n", c_t)#开启会话，运行自己的图with tf.Session(graph=new_g) as sess: c_new_value = sess.run(c_new) print(c_new_value) TensorBoard可视化:1.数据序列化-events文件tf.summary.FileWriter(path, graph=sess.graph) 2.启动tensorboardtensorboard –logdir=”path” Operation介绍 会话 张量张量就是tensor, 有点像ndarrayndarray和tensor类型修改方式: 变量 自实现线性回归 1.8的版本: 123456789101112131415161718192021222324252627282930313233343536373839404142# tensorflow 1.8.0的版本 import tensorflow as tf def liner_regression(): ''' 自实现一个线性回归; 线性回归模型主要参数是权重和偏执 :return: ''' # 1) 准备数据 X = tf.random_normal(shape=[100,1]) y_true = tf.matmul(X, [[0.8]]) + 0.7 # 2) 构建模型 # 定义模型参数 用 变量 weights = tf.Variable(initial_value=tf.random_normal(shape=[1.1])) #权重 bias = tf.Variable(initial_value=tf.random_normal(shape=[1,1])) #偏执 y_predict = tf.matmul(X, weights) + bias # 3) 构造损失函数 error = tf.reduce_mean(tf.square(y_predict - y_true)) # 4) 优化损失 optimizer = tf.train.GradientDescentOptimizer(learning_rate=0.01).minimize(error) # 显式地初始化变量 init = tf.global_variables_initializer() # 开启会话 with tf.Session() as sess: # 初始化bianl sess.run(init) # # 查看初始化模型参数之后的值 # print("训练前模型参数为：权重%f, 偏置%f, 损失%f" % ( weights.eval(), bias.eval(), error.eval() ) ) # # 开始训练 # sess.run(optimizer) # print("训练前模型参数为：权重%f, 偏置%f, 损失%f" % ( weights.eval(), bias.eval(), error.eval() ) ) for i in range(1000): # 开始训练, 不断优化模型参数, 理论是损失越小越好 sess.run(optimizer) print("第%d次训练后模型参数为：权重%f, 偏置%f, 损失%f" % ( i, weights.eval(), bias.eval(), error.eval() ) ) 2.0的版本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# tensorflow 2.0.0的版本 import tensorflow as tfprint(tf.__version__)import numpy as npimport matplotlib.pyplot as pltnp.random.seed(199346745)# 产生测试数据w_known = [1.4, 0.4, -0.4, .3, -1.9]DIM = len(w_known)N = 1000BATCH = 300x = np.random.random((N, DIM))# default DIM=5y_ = sum(w_known[i]*x[:,i] for i in range(len(w_known)))err = 0.01*np.random.normal(size=N)y = (y_ + err).reshape((N, 1))# 查看测试数据分布plt.hist(err, 30)plt.show()plt.hist(y.reshape(1000), 30)plt.show()# 得益于tf2.0的动态图特性，可以在函数中直接循环训练def lr(x, y, BATCH=None, niter=1000): if BATCH is None: BATCH = N losses = [] w = tf.Variable(tf.random.normal(shape=(DIM, 1), mean=0)) for i in range(niter): randidx = np.random.choice(N, size=BATCH) x2, y2 = (tf.constant(x[randidx], dtype='float32'), tf.constant(y[randidx], dtype='float32')) loss = lambda: tf.losses.MeanSquaredError()(tf.matmul(x2, w), y2) opt = tf.keras.optimizers.SGD(1e-1) opt.minimize(loss, var_list=[w]) losses.append(loss().numpy()) return w, lossesw, losses = lr(x, y, 300)# 查看loss的变化plt.plot(losses)plt.show()# 查看w和设定的w的距离tf.losses.MeanSquaredError()(w, tf.reshape(tf.constant(w_known),(5,1))) 增加变量显示 增加命名空间 保存和加载模型 文件通用读取流程数据io操作,三种方式：占位符&amp;free_dict搭配使用QueueRunner通用文件读取流程（图片和二进制数据，TFRecords）]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>ml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习2-算法详解]]></title>
    <url>%2F2019%2F12%2F02%2Fpython-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A02%2F</url>
    <content type="text"><![CDATA[基础知识几个基本概念基本流程 特征，特征向量，特征空间，假设空间 机器学习实质：就是在假设空间中去搜索一个适合当前数据的假设 机器学习方法的三要素 模型 策略 经验风险与结构风险损失函数 经验风险 经验风险问题 结构风险 正则化项 范数 模型评估与选择 了解模型选择的原则误差误差：模型的预测值与真实值之间的差异训练：通过已知的样本数据学习，从而得到模型的过程训练误差：模型作用于训练集时的误差泛化：由具体的、个别的扩大为一般的，即从特殊都一般，称为泛化。对机器学习的模型来讲，泛化是指模型作用于新的样本数据（非训练集）泛化误差：模型作用于新的样本数据时的误差 欠拟合和过拟合 模型选择 掌握交叉验证法评估模型评估思路 留出法 交叉验证法 留一法 自助法 几种方法适用模型 熟悉常见模型的性能指标 分类算法的性能度量 聚类算法的性能度量 了解模型评估的误差与方差 假设检验 假设检验过程 例子 偏差，方差与噪声 泛化误差的推导 回归分析 回归的定义 线性与非线性 线性回归 几个基本假设 建立回归模型流程 回归模型的特点 一元线性回归 一元线性回归模型 最小二乘估计 最大似然估计 有偏估计与无偏估计 各种检验方法：t, f检验等]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>ml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习1-概览及常用算法]]></title>
    <url>%2F2019%2F11%2F27%2Fpython-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A01%2F</url>
    <content type="text"><![CDATA[有监督学习标记特征，进行训练分类–classification回归–regression[一组连续值] 分类算法按原理分类 基于统计的：如贝叶斯分类 基于规则的：如决策树算法 基于神经网络的：神经网络算法 基于距离的：KNN（K最近邻） 常用评估指标 精确率：预测结果与实际结果的比例 召回率：预测结果中某类结果的正确覆盖率 F1-Score：统计量，综合评估分类模型，取值0-1之间 KNN 计算步骤 常见的距离公式 优缺点 决策树 无监督学习无特征，发现其隐藏结构或者模式； 聚类 k-means 半监督学习算法 集成学习 Bagging投票的方式，生成最终模型 boosting通过算法得到模型和错误分类，然后利用错误分类加大权重进行训练，不断通过这种方式生成最终模型 随机森林由多个决策树生成，进行拟合 深度学习低层次特征通过抽象，加工来做成抽象度更高的特征进行表示 增强学习 迁移学习]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>ml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-springboot&vscode]]></title>
    <url>%2F2019%2F07%2F03%2Fjava-springboot%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[vscode配置springboot环境安装vscode扩展Spring Boot ToolsSpring InitializrSpring Boot Dashboard 基础依赖Java Extension Pack中包括：Language Support for Java(TM) by Red Hat - Visual Studio Marketplace主要功能：代码导航，自动补全，重构，代码片段 Debugger for Java - Visual Studio Marketplace主要功能就是Debugging啦。 Java Test Runner - Visual Studio Marketplace运行和调试JUnit的测试用例。 Maven for Java - Visual Studio Marketplace对Maven的支持。 Java Dependency Viewer - Visual Studio Marketplace浏览查看当前Java工程的所有依赖情况。 Cloudfoundry Manifest YML Support vscode创建springboot项目安装扩展程序后，打开命令面板（（P）并键入Spring Initializr以开始生成Maven或Gradle项目，然后按照向导进行操作。 maven创建项目本地安装好maven，配置vscode的maven插件 当你在 VS Code 中直接打开一个 maven 项目时，插件会自动构建项目。Maven for Java 插件会扫描项目下的 pom.xml 文件并在侧边栏上显示所有的 maven 项目以及它们的模块… 当我们新建一个项目时，可以利用插件生成 maven 项目原型。操作步骤如下： 按下 ⌘+⇧+P 打开命令面板，执行 Generate from Maven Archetype 命令。在弹出的对话框中选择一个生成项目的目录,接着选择基于 maven-archetype-quickstart 创建。选择完成后，会开始项目的生成，期间需要在终端中填入必要的信息。 运行和调试项目初始化完成后，切换到调试面板（⌘+⇧+D）,添加调试配置。然后按下 F5 即可运行项目。 测试通过 Java Test Runner 插件，可以很方便的执行、调试和管理 Java 单元测试用例。当我们打开一个测试类时，插件会自动进行识别并提供了一些便捷操作，如下图所示。]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-sklean_svm]]></title>
    <url>%2F2019%2F04%2F18%2Fpython-sklean_svm%2F</url>
    <content type="text"><![CDATA[0x01 svm模型训练 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101# -*- coding: utf-8 -*-# author: Bing# email: wulitouhaha@vip.qq.comimport sklearn, refrom sklearn.model_selection import train_test_splitfrom sklearn import cross_validationfrom sklearn import datasetsfrom sklearn import svmfrom sklearn.externals import joblibfrom sklearn.metrics import classification_reportfrom sklearn import metrics# 判断特征维度def get_evil_char(url): # 判断恶意字符的出现的个数，做为一个维度 return len(re.findall(&quot;[&lt;&gt;,\&apos;\&quot;()/]&quot;, url, re.IGNORECASE))def get_evil_word(url): # 判断恶意函数的出现的个数，做为一个维度 return len(re.findall(&quot;(alert)|(script=)|(eval)|(src=)|(prompt)&quot;,url,re.IGNORECASE))Dimensions = [&quot;A&quot;, &quot;N&quot;, &quot;Z&quot;] # A-&lt; N-&gt; Z-代表各种html标签;判断这个三个维度def labels(Data): #把参数泛化, 并获取词频 preData = [] #泛化后，数据 preCount = [] #泛化后，字母出现的次数;词频矩阵 for i in Data: tt = i.replace(&quot;&lt;&quot;, &quot;A&quot;) tt = tt.replace(&quot;&gt;&quot;, &quot;N&quot;) tt = tt.replace(&quot;script&quot;, &quot;Z&quot;) preData.append(tt) preCount.append([tt.count(&quot;A&quot;), tt.count(&quot;N&quot;), tt.count(&quot;Z&quot;)]) return preCount, preData# 预测结果百分比def do_metrics(y_test,y_pred): print( &quot;metrics.accuracy_score:&quot; ) print( metrics.accuracy_score(y_test, y_pred) ) print( &quot;metrics.confusion_matrix:&quot; ) print( metrics.confusion_matrix(y_test, y_pred) ) print( &quot;metrics.precision_score:&quot; ) print( metrics.precision_score(y_test, y_pred) ) print( &quot;metrics.recall_score:&quot; ) print( metrics.recall_score(y_test, y_pred) ) print( &quot;metrics.f1_score:&quot; ) print( metrics.f1_score(y_test,y_pred) )# 测试数据badCase = [ &quot;&quot;&quot;&lt;script&gt;&lt;/script&gt;&quot;&quot;&quot;, &quot;&quot;&quot;&quot;&gt;&lt;img src=# onerror=alert(/1/)&gt;&quot;&quot;&quot;, &quot;&quot;&quot;&lt;script&gt;alert(11)&lt;/script&gt;&quot;&quot;&quot;,]goodCase = [ &quot;&quot;&quot;?te=2oildfml&amp;test=sdfhk&quot;&quot;&quot;, &quot;&quot;&quot;&quot;te=292hsd%2342&amp;test=sdf23hi9ehk==&quot;&quot;&quot;, &quot;&quot;&quot;te=2372987893&amp;test=好的首肯定会&quot;&quot;&quot;,]xss_list, xss_data = labels(badCase) # xss_list 为xss通过词频泛化出的一个词频矩阵； xss_data为泛化后的数据safe_list, safe_data = labels(goodCase)x = xss_list + safe_list# 打上结果标记safe_lable = [0 for i in range(0,len(goodCase))]xss_lable = [1 for i in range(0,len(badCase))] # 黑名单数据打上1的标记y = xss_lable + safe_lable # 训练模型x_train, x_test, y_train, y_test = cross_validation.train_test_split(x,y, test_size=0.4, random_state=0)clf = svm.SVC(kernel=&apos;linear&apos;, C=1).fit(x_train, y_train)y_Predict = clf.predict(x_test)# --- SVM验证 ---test = [ &apos;AND 1=1&apos;, &apos;ORDER BY 1-- &apos;, &apos;&lt;script&gt;alert(xss)&lt;/script&gt;/&apos;, &apos;and (select substring(@@version,1,1))=\&apos;X\&apos;&apos;, &apos;www.baidu.com&apos;, &apos;&lt;?php @eval($_POST[\&apos;c\&apos;]);?&gt;&apos;]# 数据向量化X_predict, X_data = labels(test)# 模型预测y_Predict = clf.predict(X_predict)mapvalues = &#123;1:&apos;Bad &apos;,0:&apos;Good&apos;&#125;for i in range(len(X_predict)): print( mapvalues[y_Predict[i]] + &apos;:&apos; + test[i] )# 保存训练模型# joblib.dump(clf, &quot;xss-svm-200000-module.m&quot;)# 加载模型验证# clf = joblib.load(&quot;xss-svm-200000-module.m&quot;)# y_test = []# y_test = clf.predict(x)# print( metrics.accuracy_score(y_test,y) ) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# -*- coding: utf-8 -*-# author: Bing# email: wulitouhaha@vip.qq.comimport sklearn, refrom sklearn.model_selection import train_test_splitfrom sklearn import cross_validationfrom sklearn import datasetsfrom sklearn import svmfrom sklearn.externals import joblibfrom sklearn.metrics import classification_reportfrom sklearn.externals import joblibfrom sklearn import metricsfrom sklearn import preprocessingx = []y = []# 判断特征维度def get_evil_char(url): # 判断符号的出现的个数，做为一个维度 return len(re.findall(&quot;[&lt;&gt;,\&apos;\&quot;/]&quot;, url, re.IGNORECASE))def get_evil_word(url): # 判断关键词的出现的个数，做为一个维度 return len(re.findall(&quot;(alert)|(script=)|(eval)|(src=)|(prompt)|(onerror)|(onload)|(onfocus)|(onmouseover)|(string.fromcharcode)|(document.cookie)|(%3c)|(%3e)|(%20)|(iframe)|(href)|(javascript)|(data)&quot;,url,re.IGNORECASE))def get_feature(url): return [ get_evil_char(url), get_evil_word(url) ]def labels(filename,data,label): with open(filename, &quot;rb&quot;) as f: for line in f: data.append(get_feature(line.decode().strip())) if label: y.append(1) else: y.append(0) return data # 测试数据labels(&apos;xss-200000.txt&apos;,x,1)labels(&apos;good-xss-200000.txt&apos;,x,0)# 训练模型x_train, x_test, y_train, y_test = cross_validation.train_test_split(x,y, test_size=0.4, random_state=0)clf = svm.SVC(kernel=&apos;linear&apos;, C=1).fit(x_train, y_train)y_Predict = clf.predict(x_test)# --- SVM验证 ---test = [ &apos;AND 1=1&apos;, &apos;ORDER BY 1-- &apos;, &apos;&lt;script&gt;alert(xss)&lt;/script&gt;/&apos;, &apos;and (select substring(@@version,1,1))=\&apos;X\&apos;&apos;, &apos;www.baidu.com&apos;, &apos;&lt;?php @eval($_POST[\&apos;c\&apos;]);?&gt;&apos;]# 数据向量化z_test = []for i in test: z_test.append( get_feature( i ) )# 模型预测z_pred = clf.predict(z_test)mapvalues = &#123;1:&apos;Bad &apos;,0:&apos;Good&apos;&#125;for i in range(len(z_test)): print( mapvalues[z_pred[i]] + &apos;:&apos; + test[i] )# 保存训练模型# joblib.dump(clf, &quot;xss-svm-200000-module.m&quot;)# 加载模型验证# clf = joblib.load(&quot;xss-svm-200000-module.m&quot;)# y_test = []# y_test = clf.predict(x)# print( metrics.accuracy_score(y_test,y) ) 0x02 tf-idf模型训练1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889# -*- coding: utf-8 -*-# author: Bing# email: wulitouhaha@vip.qq.comimport numpy as npimport urllibbadCase = [ &quot;&quot;&quot;&lt;script&gt;&lt;/script&gt;&quot;&quot;&quot;, &quot;&quot;&quot;&quot;&gt;&lt;img src=# onerror=alert(/1/)&gt;&quot;&quot;&quot;, &quot;&quot;&quot;&lt;script&gt;alert(11)&lt;/script&gt;&quot;&quot;&quot;,]goodCase = [ &quot;&quot;&quot;?te=2oildfml&amp;test=sdfhk&quot;&quot;&quot;, &quot;&quot;&quot;&quot;te=292hsd%2342&amp;test=sdf23hi9ehk==&quot;&quot;&quot;, &quot;&quot;&quot;te=2372987893&amp;test=好的首肯定会&quot;&quot;&quot;,]# 数据预处理def getQueryFromFile(filename=&apos;badqueries.txt&apos;): directory = &quot;C:\\fwaf&quot; filepath = directory + &quot;\\&quot; + filename data = open(filepath,&apos;r&apos;).readlines() data = list(set(data)) queries = set() for d in data: d = d.strip() try: d = str(urllib.unquote(d).decode(&apos;utf8&apos;)) #converting url encoded data to simple string queries.add(d) except: print(&apos;decode &apos; + d + &apos; error&apos;) return list(queries)badQueries = getQueryFromFile(&apos;badqueries.txt&apos;)tempvalidQueries = getQueryFromFile(&apos;goodqueries.txt&apos;)tempAllQueries = badQueries + tempvalidQueriesybad = np.ones(len(badQueries))ygood = np.zeros(len(tempvalidQueries))y = np.hstack((ybad, ygood))queries = tempAllQueries# 构造3-gram特征，使用TF-IDF提取URL文本特征，并进行文本向量化# tokenizer function, this will make 3 grams of each query# 构造3-gram特征def getNGrams(query): tempQuery = str(query) ngrams = [] for i in range(0,len(tempQuery)-3): ngrams.append(tempQuery[i:i+3]) return ngramsfrom sklearn.feature_extraction.text import TfidfVectorizerfrom sklearn.cross_validation import train_test_split# converting data to vectorsvectorizer = TfidfVectorizer(tokenizer=getNGrams)# TF-IDFX = vectorizer.fit_transform(queries)#splitting dataX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)from sklearn.linear_model import LogisticRegressionlgs = LogisticRegression()lgs.fit(X_train, y_train) #training our modelprint(lgs.score(X_test, y_test)) #checking the accuracyX_predict = [ &apos;AND 1=1&apos;, &apos;ORDER BY 1-- &apos;, &apos;&lt;script&gt;alert(xss)&lt;/script&gt;/&apos;, &apos;and (select substring(@@version,1,1))=\&apos;X\&apos;&apos;, &apos;www.baidu.com&apos;, &apos;&lt;?php @eval($_POST[\&apos;c\&apos;]);?&gt;&apos;]X_vecpredict = vectorizer.transform(X_predict)y_Predict = lgs.predict(X_vecpredict) #printing predicted valuesmapvalues=&#123;1:&apos;Bad &apos;,0:&apos;Good&apos;&#125;for i in range(len(X_predict)): print mapvalues[y_Predict[i]]+&apos;:&apos;+X_predict[i] 0x03 模型验证123456789101112131415161718192021222324252627282930313233343536373839# -*- coding: utf-8 -*-# author: Bing# email: wulitouhaha@vip.qq.comimport refrom sklearn.externals import joblib# 判断特征维度def get_evil_char(url): # 判断恶意字符的出现的个数，做为一个维度 return len(re.findall(&quot;[&lt;&gt;,\&apos;\&quot;()/]&quot;, url, re.IGNORECASE))def get_evil_word(url): # 判断恶意函数的出现的个数，做为一个维度 return len(re.findall(&quot;(alert)|(script=)|(eval)|(src=)|(prompt)|(onerror)|(onload)|(onfocus)|(onmouseover)|(string.fromcharcode)|(document.cookie)|(%3c)|(%3e)|(%20)|(iframe)|(href)|(javascript)|(data)&quot;,url,re.IGNORECASE))def get_feature(url): return [ get_evil_char(url), get_evil_word(url) ]# 机器验证test = [ &apos;AND 1=1&apos;, &apos;ORDER BY 1-- &apos;, &apos;&lt;script&gt;alert(xss)&lt;/script&gt;/&apos;, &apos;and (select substring(@@version,1,1))=\&apos;X\&apos;&apos;, &apos;www.baidu.com&apos;, &apos;&lt;?php @eval($_POST[\&apos;c\&apos;]);?&gt;&apos;]# 数据向量化z_test = []for i in test: z_test.append( get_feature( i ) )# 模型预测clf = joblib.load(&quot;xss-svm-200000-module.m&quot;)z_pred = clf.predict(z_test)mapvalues = &#123;1:&apos;Bad &apos;,0:&apos;Good&apos;&#125;for i in range(len(z_test)): print( mapvalues[z_pred[i]] + &apos;:&apos; + test[i] ) 资源https://github.com/0xbing/research/tree/master/ai]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>ml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-并发]]></title>
    <url>%2F2019%2F04%2F15%2Fpython-%E5%B9%B6%E5%8F%91%2F</url>
    <content type="text"><![CDATA[0x01 多协程老代码，从以前的blog转过来做下记录 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#使用200协程扫描端口，大约需要35秒扫完65535#!/user/bin python# -*- coding:utf-8 -*- # Author:Bing# Contact:amazing_bing@outlook.com# DateTime: 2017-01-17 19:06:06# Description: coding import syssys.path.append("..")import geventfrom gevent import monkeyfrom gevent.pool import Poolmonkey.patch_all()import socket,os,time#判断是否为域名def is_domain(domain): domain_regex = re.compile( r'(?:[A-Z0-9_](?:[A-Z0-9-_]&#123;0,247&#125;[A-Z0-9])?\.)+(?:[A-Z]&#123;2,6&#125;|[A-Z0-9-]&#123;2,&#125;(?&lt;!-))\Z', re.IGNORECASE) return True if domain_regex.match(domain) else False#判断是否为ipdef is_host(host): ip_regex = re.compile(r'(^(25[0-5]|2[0-4][0-9]|[0-1]&#123;1&#125;[0-9]&#123;2&#125;|[1-9]&#123;1&#125;[0-9]&#123;1&#125;|[1-9])\.(25[0-5]|2[0-4][0-9]|[0-1]&#123;1&#125;[0-9]&#123;2&#125;|[1-9]&#123;1&#125;[0-9]&#123;1&#125;|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]&#123;1&#125;[0-9]&#123;2&#125;|[1-9]&#123;1&#125;[0-9]&#123;1&#125;|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]&#123;1&#125;[0-9]&#123;2&#125;|[1-9]&#123;1&#125;[0-9]&#123;1&#125;|[0-9])$)', re.IGNORECASE) return True if ip_regex.match(host) else False def nessus_target_check(test): if is_domain(test) or is_host(test) : return str(test) else : return Falseclass Work(object): def __init__(self, scan_id = "", scan_target = "", scan_type = "" ,scan_args = "", back_fn = None): self.pool = Pool(200) self.timeout = 0.1 self.scan_id = scan_id self.target = scan_target self.scan_type = scan_type self.args = scan_args self.back_fn = back_fn self.result = [] def get_port_service(self,text): service_path = "nmap-services.txt" #这个地方需要修改为你自己nmap指纹的地址 port_server = str(text)+"/tcp" with open(service_path,"r") as server: for finger in server.readlines(): port = finger.strip().split(";")[1] if port == port_server: fingers = str(finger.strip().split(";")[0]) return (port_server,fingers) return (port_server,"unknown") def port_scan(self,port): target = nessus_target_check(self.target) if target == False : return &#123; "status" : 2 , "data" : "NMAP &gt;&gt;&gt;&gt; :格式错误" &#125; try: sd = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sd.settimeout(self.timeout) try: sd.connect((target,int(port))) self.result.append(self.get_port_service(port)) except socket.error: pass sd.close() except: pass def run(self): res = [] for port in range(65535): res.append(port) self.pool.map(self.port_scan,res) data = [] for line in self.result: data.append(&#123; "bug_name" : str(line[0]) ,"bug_summary" : str(line[1]) &#125;) result = &#123; "status" : 1 , "data" : data , "scan_id": self.scan_id , "scan_type": "nmap" &#125; self.back_fn(result) def save(nmap_result): print nmap_result,"----------------"t = Work(scan_target = "127.0.0.1",back_fn = save)t.run() 0x02 多进程12345678910111213141516171819202122232425262728293031323334353637383940414243# 使用200进程扫描端口，大约需要160多秒扫完65535#!/user/bin python# -*- coding:utf-8 -*- # Author:Bing# Contact:amazing_bing@outlook.com# DateTime: 2017-01-17 19:06:06# Description: coding import socketfrom datetime import datetimefrom multiprocessing.dummy import Pool as ThreadPoolremote_server_ip = "www.baidu.com"ports = [] socket.setdefaulttimeout(0.5) def scan_port(port): try: s = socket.socket(2,1) res = s.connect_ex((remote_server_ip,port)) if res == 0: # 如果端口开启 发送 hello 获取banner print 'Port &#123;&#125;: OPEN'.format(port) s.close() except Exception,e: print str(e.message) for i in range(1,65535): ports.append(i) # Check what time the scan startedt1 = datetime.now() pool = ThreadPool(processes = 200)results = pool.map(scan_port,ports)pool.close()pool.join() print 'Multiprocess Scanning Completed in ', datetime.now() - t1 0x03 多线程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596# 使用200线程扫描端口，大约需要2多秒扫完65535import syssys.path.append(&quot;..&quot;)import threading, socket, sys, cmd, os, Queuefrom core.settings import *#线程锁lock = threading.Lock()#制作扫描端口队列def GetQueue(host): PortQueue = Queue.Queue() for port in range(1,65535): PortQueue.put((host,port)) return PortQueueclass ScanThread(threading.Thread): def __init__(self,SingleQueue,outip): threading.Thread.__init__(self) self.setDaemon(True) #设置后台运行，让join结束 self.SingleQueue = SingleQueue self.outip = outip def get_port_service(self,text): service_path = &quot;nmap-services.txt&quot; #这个地方需要修改为你自己nmap指纹的地址 port_server = str(text)+&quot;/tcp&quot; with open(service_path,&quot;r&quot;) as server: for finger in server.readlines(): port = finger.strip().split(&quot;;&quot;)[1] if port == port_server: fingers = str(finger.strip().split(&quot;;&quot;)[0]) return (port_server,fingers) return (port_server,&quot;unknown&quot;) def Ping(self,scanIP, Port): global OpenPort, lock sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.settimeout(0.1) address = (scanIP, Port) try: sock.connect(address) except: sock.close() return False sock.close() if lock.acquire(): #print &quot;IP:%s Port:%d&quot; % (scanIP, Port) self.outip.put(self.get_port_service(Port)) lock.release() return True def run(self): while not self.SingleQueue.empty(): #获取扫描队列，并扫描 host,port = self.SingleQueue.get() self.Ping(host,port)class Work(object): def __init__(self, scan_id = &quot;&quot;, scan_target = &quot;&quot;, scan_type = &quot;&quot; ,scan_args = &quot;&quot;, back_fn = None): self.scan_id = scan_id self.target = scan_target self.scan_type = scan_type self.args = scan_args self.back_fn = back_fn self.result = [] def run(self): ThreadList = [] #扫描队列 SingleQueue = GetQueue(self.target) #存储结果队列 resultQueue = Queue.Queue() #启动200线程并发 for i in range(0, 200): t = ScanThread(SingleQueue,resultQueue) ThreadList.append(t) for t in ThreadList: t.start() for t in ThreadList: #需要设置线程为后台，然后没法结束；join等待结束后台线程 t.join(0.1) data = [] while not resultQueue.empty(): line = resultQueue.get() data.append(&#123; &quot;bug_name&quot; : str(line[0]) ,&quot;bug_summary&quot; : str(line[1]) &#125;) result = &#123; &quot;status&quot; : 1 , &quot;data&quot; : data , &quot;scan_id&quot;: self.scan_id , &quot;scan_type&quot;: &quot;nmap&quot; &#125; self.back_fn(result)def save(nmap_result): print nmap_result,&quot;----------------&quot;t = Work(scan_target = &quot;127.0.0.1&quot;,back_fn = save)t.run()]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go-并发]]></title>
    <url>%2F2019%2F04%2F15%2Fgo-%E5%B9%B6%E5%8F%91%2F</url>
    <content type="text"><![CDATA[0x01 异步并发仅作模板案列 1234567891011121314151617181920212223242526272829303132333435363738package mainimport ( "fmt" "sync" "time" // "runtime")func main() &#123; // runtime.GOMAXPROCS(4) go spinner(100 * time.Millisecond) wg := sync.WaitGroup&#123;&#125; for i := 0; i &lt; 10; i++ &#123; wg.Add(1) go calc(&amp;wg, i) &#125; wg.Wait() fmt.Println("all goroutine finish")&#125;func calc(w *sync.WaitGroup, i int) &#123; fmt.Println("calc:", i) time.Sleep(2 *time.Second) defer w.Done()&#125;func spinner(delay time.Duration) &#123; for &#123; for _, r := range `-\|/` &#123; fmt.Printf("\r%c", r) time.Sleep(delay) &#125; &#125;&#125; 123456789101112131415161718192021222324252627package mainimport ( "fmt" "runtime")func main() &#123; runtime.GOMAXPROCS( runtime.NumCPU() ) c := make(chan bool, 10) for i := 0; i &lt; 10; i++ &#123; go Poc(c, i) &#125; for i :=0; i &lt; 10; i++ &#123; &lt;- c &#125;&#125;func Poc(c chan bool, index int) &#123; a :=1 for i := 0; i &lt; 1000000; i++ &#123; a += i &#125; fmt.Println( index, a ) c &lt;- true&#125; 参考https://segmentfault.com/a/1190000016703769https://beego.me/docs/module/httplib.mdhttps://www.kancloud.cn/liupengjie/go/570005]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-组件]]></title>
    <url>%2F2019%2F03%2F26%2Fvue-%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[vue上传template的模板： 1234567891011121314&lt;el-input v-model=&quot;formLabelAlign.filename&quot;&gt;&lt;/el-input&gt; &lt;el-upload class=&quot;upload-demo&quot; ref=&quot;upload&quot; :action=&quot;action&quot; :http-request=&quot;beforeAvatarUpload&quot; :limit=&quot;1&quot; :on-exceed=&quot;handleExceed&quot; :multiple=&quot;false&quot; :auto-upload=&quot;false&quot;&gt; &lt;el-button slot=&quot;trigger&quot; size=&quot;small&quot; type=&quot;primary&quot;&gt;选取文件&lt;/el-button&gt; &lt;el-button style=&quot;margin-left: 10px;&quot; size=&quot;small&quot; type=&quot;success&quot; @click=&quot;submitUpload&quot; icon=&quot;el-icon-upload&quot;&gt;上传到服务器&lt;/el-button&gt; &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;只能上传xlsx文件&lt;/div&gt;&lt;/el-upload&gt; methods里面的方法: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 文件上传数量超过Limit限制handleExceed(files, fileList) &#123; this.$message.warning(`当前限制选择 1个文件`);&#125;,// 上传文件beforeAvatarUpload(fileObj) &#123;// const isJPG = file.type === &apos;image/jpeg&apos;;// const isGIF = file.type === &apos;image/gif&apos;;// const isPNG = file.type === &apos;image/png&apos;;// const isBMP = file.type === &apos;image/bmp&apos;;// const isCSV = file.type === &quot;.csv&quot;// const isXLS = file.type === &quot;application/vnd.ms-excel&quot;// const isXLSX = file.type === &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;// console.log( file.type );// const isLt2M = file.size / 1024 / 1024 &lt; 2;// // if (!isCSV || !isXLS || !isXLSX) &#123;// this.$message.error(&quot;上传头像图片只能是 Excels格式!&quot;);// &#125;// if (!isLt2M) &#123;// this.$message.error(&quot;上传头像图片大小不能超过 2MB!&quot;);// &#125;// return isCSV || isXLS || isXLSX &amp;&amp; isLt2M; let formData = new FormData(); // 声明一个FormData对象 formData.append(&apos;name&apos;, fileObj.file.name) formData.append(&apos;file&apos;, fileObj.file) let config = &#123; headers: &#123; &apos;Content-Type&apos;: &apos;multipart/form-data&apos; &#125; &#125; axios.post(this.action, formData, config).then((res) =&gt; &#123; if(res.data.status)&#123; this.formLabelAlign.filename = res.data.data; this.$message.success(&quot;上传成功!&quot;); &#125;else&#123; this.$message.error(&quot;上传失败!&quot;); &#125; &#125;) ; // 发送请求&#125;,// 提交上传数据submitUpload ()&#123; this.$refs.upload.submit() ; console.log(&quot;sdfs&quot;) ;&#125;, axios 使用请求头设置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115import axios from &apos;axios&apos; //引用axiosimport &#123;getCookie&#125; from &apos;./util&apos; //引用刚才我们创建的util.js文件，并使用getCookie方法// axios 配置axios.defaults.timeout = 5000; axios.defaults.baseURL = &apos;http://192.168.73.61:5000/&apos;; //这是调用数据接口// http request 拦截器，通过这个，我们就可以把Cookie传到后台axios.interceptors.request.use( config =&gt; &#123; const token = getCookie(&apos;session&apos;); //获取Cookie // config.data = JSON.stringify(config.data); if (token) &#123; config.headers = &#123; &quot;Content-Type&quot;: &quot;application/json; charset=UTF-8&quot;, //设置跨域头部 &quot;Authorization&quot;: token , &#125;; &#125; return config; &#125;, err =&gt; &#123; return Promise.reject(err); &#125;);// http response 拦截器axios.interceptors.response.use( response =&gt; &#123; //response.data.errCode是我接口返回的值，如果值为2，说明Cookie丢失，然后跳转到登录页，这里根据大家自己的情况来设定// if(response.data.errCode == 2) &#123;// router.push(&#123;// path: &apos;/login&apos;,// query: &#123;redirect: router.currentRoute.fullPath&#125; //从哪个页面跳转// &#125;)// &#125; return response; &#125;, error =&gt; &#123; return Promise.reject(error.response.data) &#125;);export default axios;/** * fetch 请求方法 * @param url * @param params * @returns &#123;Promise&#125; */export function fetch(url, params = &#123;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.get(url, &#123; params: params &#125;) .then(response =&gt; &#123; resolve(response.data); &#125;) .catch(err =&gt; &#123; reject(err) &#125;) &#125;)&#125;/** * post 请求方法 * @param url * @param data * @returns &#123;Promise&#125; */export function post(url, data = &#123;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.post(url, data) .then(response =&gt; &#123; resolve(response.data); &#125;, err =&gt; &#123; reject(err); &#125;) &#125;)&#125;/** * patch 方法封装 * @param url * @param data * @returns &#123;Promise&#125; */export function patch(url, data = &#123;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.patch(url, data) .then(response =&gt; &#123; resolve(response.data); &#125;, err =&gt; &#123; reject(err); &#125;) &#125;)&#125;/** * put 方法封装 * @param url * @param data * @returns &#123;Promise&#125; */export function put(url, data = &#123;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.put(url, data) .then(response =&gt; &#123; resolve(response.data); &#125;, err =&gt; &#123; reject(err); &#125;) &#125;)&#125; axios多并发访问12345678发送并发请求axios .all([axios.get(&apos;/profile&apos;), axios.post(&apos;/user&apos;)]) .then(axios.spread((res1, res2)=&gt;&#123; console.log(res1) console.log(res2) &#125;))axios.all([]) 返回的结果是一个数组，使用 axios.spread 可将数组 [res1,res2] 展开为 res1, res2 axios请求配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&#123; // 请求地址 url: &apos;/user&apos;, // 请求类型 method: &apos;get&apos;, // 请根路径 baseURL: &apos;http://www.mt.com/api&apos;, // 请求前的数据处理 transformRequest:[function(data)&#123;&#125;], // 请求后的数据处理 transformResponse: [function(data)&#123;&#125;], // 自定义的请求头 headers:&#123;&apos;x-Requested-With&apos;:&apos;XMLHttpRequest&apos;&#125;, // URL查询对象 params:&#123; id: 12 &#125;, // 查询对象序列化函数 paramsSerializer: function(params)&#123; &#125; // request body data: &#123; key: &apos;aa&apos;&#125;, // 超时设置s timeout: 1000, // 跨域是否带Token withCredentials: false, // 自定义请求处理 adapter: function(resolve, reject, config)&#123;&#125;, // 身份验证信息 auth: &#123; uname: &apos;&apos;, pwd: &apos;12&apos;&#125;, // 响应的数据格式 json / blob /document /arraybuffer / text / stream responseType: &apos;json&apos;, // xsrf 设置 xsrfCookieName: &apos;XSRF-TOKEN&apos;, xsrfHeaderName: &apos;X-XSRF-TOKEN&apos;, // 下传和下载进度回调 onUploadProgress: function(progressEvent)&#123; Math.round( (progressEvent.loaded * 100) / progressEvent.total ) &#125;, onDownloadProgress: function(progressEvent)&#123;&#125;, // 最多转发数，用于node.js maxRedirects: 5, // 最大响应数据大小 maxContentLength: 2000, // 自定义错误状态码范围 validateStatus: function(status)&#123; return status &gt;= 200 &amp;&amp; status &lt; 300; &#125;, // 用于node.js httpAgent: new http.Agent(&#123; keepAlive: treu &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // 用于设置跨域请求代理 proxy: &#123; host: &apos;127.0.0.1&apos;, port: 8080, auth: &#123; username: &apos;aa&apos;, password: &apos;2123&apos; &#125; &#125;, // 用于取消请求 cancelToken: new CancelToken(function(cancel)&#123;&#125;)&#125; 全局配置12axios.defaults.baseURL = ‘http://www.xx.com/api&apos;axios.defaults.headers.post[‘Content-Type’] = ‘application/x-www-form-urlencoded’; 其它1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import axios from &apos;axios&apos;import store from &apos;@/store&apos;;// axios.defaults.headers.post[&quot;Content-Type&quot;] = &quot;application/json; charset=UTF-8&quot; ;// axios.defaults.timeout = 5000 ; //响应时间// axios.defaults.baseURL = &quot;http://192.168.76.16:5000/&quot; ; //配置接口地址// axios.defaults.headers.common[&quot;Authorization&quot;] = store.state.token ;// 请求拦截器axios.interceptors.request.use(function(config) &#123; return config; &#125;, function(error) &#123; return Promise.reject(error); &#125;)// 响应拦截器axios.interceptors.response.use(function(response) &#123; return response;&#125;, function(error) &#123; return Promise.reject(error);&#125;)// 封装axios的post请求--同步请求export function fetchPOST(url, params) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.post(url, params) .then(response =&gt; &#123; resolve(response.data); &#125;) .catch((error) =&gt; &#123; reject(error); &#125;) &#125;)&#125;// 封装axios的get请求--同步请求export function fetchGET(url, params) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.get(url, params) .then(response =&gt; &#123; resolve(response); &#125;) .catch((error) =&gt; &#123; reject(error); &#125;) &#125;)&#125;export default &#123; secPost(url, params) &#123; // console.log(url,params,&quot;POST&quot;); return fetchPOST(url, params); &#125;, secGet(url, params) &#123; // console.log(url,params,&quot;GET&quot;); return fetchGET(url, params); &#125;&#125; cookie设置123456789101112131415161718192021222324//获取cookie、export function getCookie(name) &#123; var arr, reg = new RegExp(&quot;(^| )&quot; + name + &quot;=([^;]*)(;|$)&quot;); if (arr = document.cookie.match(reg)) return (arr[2]); else return null;&#125;//设置cookie,增加到vue实例方便全局调用export function setCookie (c_name, value, expiredays) &#123; var exdate = new Date(); exdate.setDate(exdate.getDate() + expiredays); document.cookie = c_name + &quot;=&quot; + escape(value) + ((expiredays == null) ? &quot;&quot; : &quot;;expires=&quot; + exdate.toGMTString());&#125;;//删除cookieexport function delCookie (name) &#123; var exp = new Date(); exp.setTime(exp.getTime() - 1); var cval = getCookie(name); if (cval != null) document.cookie = name + &quot;=&quot; + cval + &quot;;expires=&quot; + exp.toGMTString();&#125;;]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-sqlalchemy]]></title>
    <url>%2F2019%2F03%2F20%2Fpython-sqlalchemy%2F</url>
    <content type="text"><![CDATA[0x01 安装服务基础环境12python3.6mysql5.0 安装mysql1234sudo yum install mysql-serversudo systemctl start mysqldsudo grep &apos;temporary password&apos; /var/log/mysqld.log 查看初始化密码sudo mysql_secure_installation 安装flask项目的依赖123456789flaskflask-mysqldbflask_scriptflask_migrateflask_apschedulerpyjwtflask_restfulflask_corssqlalchemy 0x02 中文乱码解决sqlite bug解决123456sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table:第一次启动应用的时候,BUG解决:$ python db.py shell&gt;&gt;&gt; from app.users.model import db&gt;&gt;&gt; db.create_all()&gt;&gt;&gt; exit flask_sqlalchemy 中文乱码解决方式1.修改代码部分 1将&quot;db = SQLAlchemy(app)&quot;改为&quot;db = SQLAlchemy(app, use_native_unicode=&quot;utf8&quot;)&quot; 2.进入mysql的配置文件目录, 编辑my.cnf配置文件 12345678910cd /etc/mysql/vim my.cnf[mysqld]character_set_server = utf8[client]default-character-set = utf8[mysql]default-character-set = utf8 3.重启mysql 1sudo systemctl restart mysqld 4.进入mysql，重新查看状态 1234567891011121314151617181920mysql&gt; status--------------mysql Ver 14.14 Distrib 5.7.25, for Linux (x86_64) using EditLine wrapperConnection id: 2Current database:Current user: test@localhostSSL: Not in useCurrent pager: stdoutUsing outfile: &apos;&apos;Using delimiter: ;Server version: 5.7.25 MySQL Community Server (GPL)Protocol version: 10Connection: Localhost via UNIX socketServer characterset: utf8Db characterset: utf8Client characterset: utf8Conn. characterset: utf8UNIX socket: /var/lib/mysql/mysql.sockUptime: 27 sec 5.如果还是不行，修改数据库的连接方式 12&apos;mysql://root:password@localhost/database&apos; 改成如下：&apos;mysql+mysqlconnector://root:password@localhost/database&apos; 0x03 基础数据模板app/init.py 1db = SQLAlchemy(use_native_unicode=&quot;utf8&quot;) app/models/monitor_analysis_logger.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/usr/bin/env python# coding=UTF-8&apos;&apos;&apos;@Author: Bing@Description: @Date: 2019-02-25 14:58:11&apos;&apos;&apos;import timefrom flask_sqlalchemy import SQLAlchemyfrom sqlalchemy.exc import SQLAlchemyErrorfrom app import dbclass MonitorAnalysisLogger(db.Model): &apos;&apos;&apos; @Description: 监控分析引擎运行日志 @param &#123;type&#125; @return: &apos;&apos;&apos; __tablename__ = &quot;monitor_analysis_logger&quot; id = db.Column(db.Integer, primary_key=True, autoincrement=True) engine = db.Column(db.String(250), unique=True, nullable=False, comment=&quot;监控引擎名称&quot;) message = db.Column(db.Text, nullable=False, comment=&quot;日志信息&quot;) ctime = db.Column(db.Integer, comment=&quot;创建时间&quot;) def __init__(self, engine, message): self.engine = engine self.message = message def __str__(self): return &quot;MonitorAnalysisLogger(id=&apos;%s&apos;)&quot; % self.id def get(self, id): return self.query.filter_by(id=id).first() def add(self, obj): db.session.add(obj) return session_commit() def update(self): return session_commit() def delete(self, id): self.query.filter_by(id=id).delete() return session_commit()def session_commit(): try: db.session.commit() except SQLAlchemyError as e: db.session.rollback() reason = str(e) return reason 一些基础操作： 123456789101112131415161718192021222324252627282930313233查询所有:result = MonitorResourceConfig.query.all() # 单个first(), 最后一个last()for row in result: temp = &#123;&#125; temp[&quot;id&quot;] = row.id temp[&quot;topic&quot;] = row.topic temp[&quot;category&quot;] = row.category temp[&quot;segmentation&quot;] = row.segmentation temp[&quot;paramater&quot;] = row.paramater temp[&quot;uid&quot;] = Users.get(Users, row.uid).username temp[&quot;status&quot;] = row.status temp[&quot;ctime&quot;] = row.ctime data.append(temp)return jsonify(common.trueReturn(data, &quot;&quot;))增加数据:count = MonitorResourceConfig.query.filter_by(topic=topic).count()if count == 0: monitor = MonitorResourceConfig(topic=topic, category=category, segmentation=segmentation, paramater=paramater, uid = user.id ) result = MonitorResourceConfig.add(MonitorResourceConfig, monitor) if monitor.id: return jsonify(common.trueReturn(&quot;&quot;, &quot;添加成功&quot;)) else: return jsonify(common.falseReturn(&quot;&quot;, &quot;添加失败&quot; ))更新:ids = request.json.get(&quot;id&quot;)monitor = MonitorResourceConfig.query.filter_by(id=ids).first()if monitor.status == 1: monitor.status = 0else: monitor.status = 1monitor.update() 0x04 sqlalchemy常用操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#查询一个trace中flow个数（to count flows of specific trace）session.query(Flow).filter(Flow.trace_id == 1).count()#查询一个trace中不同srcIP的个数 （to count distinct srcIP）from sqlalchemy import distinctfrom config import *session = DBSession()session.query(Flow.srcIP).filter(Flow.trace_id == 1).distinct().count()#查询一个trace中不同的dstIP和dstPort对的个数（to count distinct dstIP and dstPort）session.query(Flow.dstIP, Flow.dstPort).filter(Flow.trace_id == 1).distinct().count()#查询指定列的数据，返回一个KeyedTuple数据类型的列表( get a tuple list of specified columns )n = session.query(Flow.dstIP, Flow.dstPort).filter(Flow.trace_id == 1).all()# The type of n is list.# The type of n[0] is sqlalchemy.util._collections.KeyedTuple#查询指定列中的所有不同值( get a distinct tuple list of specified columns)n = session.query(Flow.dstIP, Flow.dstPort).filter(Flow.trace_id == 1).distinct().all()#获得一列数据的平均值（get average value of a column）# sql language： select avg(txPkt) from Flowfrom sqlalchemy.sql import funcq = session.query(func.avg(Flow.txPkt)).filter(Flow.trace_id == 1)#多列数据平均值的计算（compute average values of columns）q = session.query((func.avg(Flow.txPkt)+func.avg(Flow.rxPkt))/2).filter(Flow.trace_id == 1)#对查询到的数据排序（order by ）from sqlalchemy import descq = session.query(Flow.timestamp).filter(trace_id == 1).order_by(desc(Flow.timestamp))q = Monitor.query.order_by(Monitor.id.desc()).limit(100)#分组查询q = session.query(Flow.dstIP, Flow.dstPort, func.count(Flow.id)).filter(Flow.trace_id == tid).group_by(Flow.dstIP, Flow.dstPort).all()#查询中，常用的过滤操作等于(equals)， 例如 query.filter(name == &apos;Jack&apos;)不等于(not equals)， 例如 query.filter(name != &apos;Jack&apos;)在列表中(in)， 例如 query.filter(name.in_([&apos;Micheal&apos;, &apos;Bob&apos;, &apos;Jack&apos;]))不在列表中(not in)， 例如query.filter(~name.in_([&apos;Micheal&apos;, &apos;Bob&apos;, &apos;Jack&apos;]))空值(null), 例如 query.filter(name == None)不是空值(not null), 例如 query.filter(name != None)与(and), 例如 query.filter(and_(name == &apos;Andy&apos;, fullname == &apos;Andy Liu&apos; ))and_可以省略， 例如 VulCategrory.query.filter_by( platform = platform, vul = vultype ).first()或(or), 例如 query.filter(or_(name == &apos;Andy&apos;, name == &apos;Micheal&apos;))#修改一个数据（update a value）session.query(Flow).filter(Flow.dstIP == dstIP, Flow.dstPort == dstPort, Flow.trace_id == 1).update(&#123;&apos;cluster_id&apos; : 0&#125;)#插入一行数据（insert a row） session = DBSession() cluster = Clusters(trace_id = tid, cluster_id = cid, \ dstIP = dIP, dstPort = dPort, \ avgPkt = aPkt, avgByte = aByte, \ size = count) session.add(cluster) session.commit() # commit or flush session.close()#删除一行数据（delete a row ） session = DBSession() session.query(Clusters).filter(Clusters.trace_id = 2).delete() session.commit() # commit or flush session.close()#简单查询 print(session.query(User).all())print(session.query(User.name, User.fullname).all()) print(session.query(User, User.name).all()) #带条件查询 print(session.query(User).filter_by(name=&apos;user1&apos;).all()) print(session.query(User).filter(User.name == &quot;user&quot;).all()) print(session.query(User).filter(User.name.like(&quot;user%&quot;)).all()) #多条件查询 print(session.query(User).filter(and_(User.name.like(&quot;user%&quot;), User.fullname.like(&quot;first%&quot;))).all()) print(session.query(User).filter(or_(User.name.like(&quot;user%&quot;), User.password != None)).all()) #sql过滤 print(session.query(User).filter(&quot;id&gt;:id&quot;).params(id=1).all()) #关联查询 print(session.query(User, Address).filter(User.id == Address.user_id).all()) print(session.query(User).join(User.addresses).all()) print(session.query(User).outerjoin(User.addresses).all()) #聚合查询 print(session.query(User.name, func.count(&apos;*&apos;).label(&quot;user_count&quot;)).group_by(User.name).all()) print(session.query(User.name, func.sum(User.id).label(&quot;user_id_sum&quot;)).group_by(User.name).all()) #子查询 stmt = session.query(Address.user_id, func.count(&apos;*&apos;).label(&quot;address_count&quot;)).group_by(Address.user_id).subquery() print(session.query(User, stmt.c.address_count).outerjoin((stmt, User.id == stmt.c.user_id)).order_by(User.id).all()) #exists print(session.query(User).filter(exists().where(Address.user_id == User.id))) print(session.query(User).filter(User.addresses.any()))限制返回字段查询person = session.query(Person.name, Person.created_at,Person.updated_at).filter_by(name=&quot;zhongwei&quot;).order_by(Person.created_at).first()记录总数查询：from sqlalchemy import func# count User records, without# using a subquery.session.query(func.count(User.id))# return count of user &quot;id&quot; grouped# by &quot;name&quot;session.query(func.count(User.id)).group_by(User.name)# 去重复from sqlalchemy import distinct# count distinct &quot;name&quot; valuessession.query(func.count(distinct(User.name)))# 去重复必须使用dbfrom app import dbresult_vul = db.session.query(distinct(VulCategrory.platform))]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-打包优化]]></title>
    <url>%2F2019%2F03%2F13%2Fvue-%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[0x01 安装分析模块这里推荐使用 webpack-bundle-analyzer —— Webpack 插件和 CLI 实用程序，她可以将内容束展示为方便交互的直观树状图，让你明白你所构建包中真正引入的内容；我们可以借助她，发现它大体有哪些模块组成，找到不合时宜的存在，然后优化它。我们可以在 项目的 package.json 文件中注入如下命令，以方便运行她(npm run analyz)，默认会打开 http://127.0.0.1:8888 作为展示。 安装webpack-bundle-analyzer 1npm install --save-dev webpack-bundle-analyzer 配置方式1： 123456789101112// vue.config.jschainWebpack: config =&gt; &#123;config .plugin(&apos;webpack-bundle-analyzer&apos;) .use(require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin)&#125;// package.json&quot;analyz&quot;: &quot;npm_config_report=true npm run build&quot;测试：npm run serve 配置方式2–失败： 1234567891011121314151617// vue.config.jsconst BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPluginconfigureWebpack: config =&gt; &#123; if (process.env.NODE_ENV === &apos;production&apos;) &#123; return &#123; plugins: [ new BundleAnalyzerPlugin() ] &#125; &#125;&#125; // package.json&quot;analyz&quot;: &quot;npm_config_report=true npm run build&quot;测试:npm run analyz //默认8888 端口 0x02 分析尽量使用模块化引入按需异步加载模块确定引入的必要性避免类库引而不用路由懒加载引入外部CDN生产环境，压缩混淆并移除consoleWebpack3 新功能: Scope Hoisting 12345module.exports = &#123; plugins: [ new webpack.optimize.ModuleConcatenationPlugin() ]&#125; 0x03 引入外部CDN配置vue配置文件123456789101112131415161718192021222324252627282930313233module.exports = &#123; // 配置webpack configureWebpack: &#123; // 配置在打包的时候不打包的模块 externals: &#123; vue: &quot;Vue&quot;, jquery: &apos;window.$&apos;, &quot;element-ui&quot;: &quot;ELEMENT&quot;, &apos;vue-router&apos;: &apos;VueRouter&apos;, &apos;axios&apos;: &apos;axios&apos;, &apos;i18n&apos;: &apos;i18n&apos;, &quot;echarts&quot;: &quot;echarts&quot;, &#125;, &#125;, // 配置分析插件 chainWebpack: config =&gt; &#123; config .plugin(&apos;webpack-bundle-analyzer&apos;) .use(require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin) &#125;, runtimeCompiler: true, devServer: &#123; host: &apos;0.0.0.0&apos;, port: 8082, https: false, hotOnly: false, proxy: null, &#125;, baseUrl: &apos;/&apos;, outputDir: &apos;dist&apos;, lintOnSave: false, productionSourceMap: false,&#125; main.js配置进行加载1234567891011121314151617181920212223242526272829303132333435363738394041424344import Vue from &apos;vue&apos;;import App from &apos;./App.vue&apos;;import router from &apos;./router&apos;;import store from &apos;./store&apos;;// import ElementUI from &apos;element-ui&apos;;import ELEMENT from &apos;element-ui&apos;;// 全局访问接口import &quot;@/config/api&quot;; // 全局格式转换和cookie设置，请求函数import &quot;@/utils/func.js&quot;// 全局css样式// import &apos;element-ui/lib/theme-chalk/index.css&apos;import &apos;font-awesome/css/font-awesome.min.css&apos;;Vue.config.productionTip = false;Vue.use(ELEMENT);new Vue(&#123; router, store, render: h =&gt; h(App), created() &#123; //当用户打开页面时前端需要检查他是否已经登录 this.checkLogin(); &#125;, watch: &#123; //全局路由发生变化时检查是否登陆 &quot;$route&quot; : &apos;checkLogin&apos; &#125;, methods: &#123; checkLogin()&#123; //检查是否存在session var data, result; data = &#123; &quot;action&quot;: &quot;get&quot;, &quot;mod&quot;: &quot;base&quot;, &quot;id&quot;: &quot;autoSync@state&quot; &#125;; result = this.secReq(this.api.globalConfig , &quot;get&quot;, data); if(result.hasOwnProperty(&quot;code&quot;) &amp;&amp; result.code === &quot;ok&quot;)&#123; if(this.$route.path == &quot;/login&quot;)&#123; this.$router.push(&quot;/home&quot;); &#125; &#125;else&#123; this.$router.push(&apos;/login&apos;); &#125; &#125; &#125;&#125;).$mount(&apos;#app&apos;) 在index.html页面引入CDN123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/element-ui@2.3.7/lib/theme-chalk/index.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css&quot;&gt; &lt;title&gt;openstar&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;!-- built files will be auto injected --&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue/2.5.2/vue.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue-router/3.0.1/vue-router.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/axios/0.18.0/axios.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/vue-i18n/7.6.0/vue-i18n.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/element-ui@2.3.7/lib/index.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/echarts/4.1.0/echarts.min.js&quot;&gt;&lt;/script&gt; &lt;!-- &lt;script src=&quot;//cdn.bootcss.com/vuex/2.2.1/vuex.min.js&quot;&gt;&lt;/script&gt; --&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[env-vscode配置]]></title>
    <url>%2F2019%2F02%2F20%2Fenv-vscode%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[vscode插件配置koroFileHeader快捷键：ctrl+alt+i 头部注释；ctrl+alt+t 函数注释 1234567891011121314151617181920212223242526&quot;fileheader.configObj&quot;: &#123; &quot;createFileTime&quot;: true,//设置为true则为文件新建时候作为date，否则注释生成时间为date &quot;autoAdd&quot;: true,//自动生成注释，老是忘记的同学可以设置 &quot;annotationStr&quot;: &#123; &quot;head&quot;: &quot;/*&quot;, &quot;middle&quot;: &quot; * @&quot;, &quot;end&quot;: &quot; */&quot;, &quot;use&quot;: true //设置自定义注释可用 &#125;, &quot;headInsertLine&quot;: &#123; &quot;php&quot;: 2 &#125;&#125;,&quot;fileheader.customMade&quot;: &#123; &quot;Author&quot;: &quot;Bing&quot;, &quot;Date&quot;: &quot;&quot;, &quot;version&quot;: &quot;0.1&quot;, &quot;Description&quot; : &quot;&quot;,&#125;, // 头部注释&quot;fileheader.cursorMode&quot;: &#123; &quot;Description&quot;: &quot;&quot;, &quot;Author&quot;: &quot;Bing&quot;, &quot;Date&quot;: &quot;&quot;, &quot;param&quot;: &quot;&quot;, &quot;return&quot; : &quot;&quot;,&#125; // 函数注释 snippet1234567891011121314&#123; // Place your snippets for python here. Each snippet is defined under a snippet name and has a prefix, body and // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are: // $1, $2 for tab stops, $0 for the final cursor position, and $&#123;1:label&#125;, $&#123;2:another&#125; for placeholders. Placeholders with the // same ids are connected. // Example: &quot;python ... headers&quot;: &#123; &quot;prefix&quot;: &quot;py_header&quot;, &quot;body&quot;: [ &quot;#!/usr/bin/env python \n# -*- coding: utf-8 -*- \n# Author: Bing \n# Email: wulitouhaha@vip.qq.com\n# Date: $&#123;CURRENT_YEAR&#125;-$&#123;CURRENT_MONTH&#125;-$&#123;CURRENT_DATE&#125; $&#123;CURRENT_HOUR&#125;:$&#123;CURRENT_MINUTE&#125;:$&#123;CURRENT_SECOND&#125; \n# Description: test \n\n$1&quot; ], &quot;description&quot;: &quot;Log output to console&quot; &#125;,&#125;]]></content>
      <categories>
        <category>misc</category>
      </categories>
      <tags>
        <tag>env</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-js常用方法]]></title>
    <url>%2F2019%2F02%2F15%2Fvue-js%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[0x01 数组–去重复 12345678910function unique(array) &#123; var res = []; for (var i = 0, len = array.length; i &lt; len; i++) &#123; var current = array[i]; if (res.indexOf(current) === -1) &#123; res.push(current) &#125; &#125; return res;&#125; 0x02 对象–统计参数和出现的重复次数12345678910111213141516function uniqueCount(arr) &#123; var a = [], b = [], prev; arr.sort(); for ( var i = 0; i &lt; arr.length; i++ ) &#123; if ( arr[i] !== prev ) &#123; a.push(arr[i]); b.push(1); &#125; else &#123; b[b.length-1]++; &#125; prev = arr[i]; &#125; return [a, b];&#125; 0x03 对象–对应的键和值进行排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var trend_title = [&quot;01&quot;,&quot;02&quot;, &quot;03&quot;, &quot;04&quot;, &quot;05&quot;, &quot;06&quot;, &quot;07&quot;, &quot;08&quot;, &quot;09&quot;, &quot;10&quot;, &quot;11&quot;, &quot;12&quot;, &quot;13&quot;, &quot;14&quot;, &quot;15&quot;, &quot;16&quot;, &quot;17&quot;, &quot;18&quot;, &quot;19&quot;, &quot;20&quot;, &quot;21&quot;, &quot;22&quot;, &quot;23&quot;, &quot;00&quot; ,];var trendResult = &#123; &quot;01&quot;: 0, &quot;02&quot;: 0, &quot;03&quot;: 0, &quot;04&quot;: 0, &quot;05&quot;: 0, &quot;06&quot;: 0, &quot;07&quot;: 0, &quot;08&quot;: 0, &quot;09&quot;: 0, &quot;10&quot;: 0, &quot;11&quot;: 0, &quot;12&quot;: 0, &quot;13&quot;: 0, &quot;14&quot;: 0, &quot;15&quot;: 0, &quot;16&quot;: 0, &quot;17&quot;: 0, &quot;18&quot;: 0, &quot;19&quot;: 0, &quot;20&quot;: 0, &quot;21&quot;: 0, &quot;22&quot;: 0, &quot;23&quot;: 0, &quot;00&quot;: 0&#125;var trend_data = [];for(var i in trend_title)&#123; trend_data.push(trendResult[trend_title[i]]) ;&#125; 0x04 vue-table索引替换123456789101112131415161718192021222324252627282930313233343536373839404142434445result = [] 为table数据// 索引上移up(index) &#123; if (index === 0) &#123; return; &#125; this.swapItems(this.results, index, index - 1);&#125;,// 索引置顶upIndex(index) &#123; if (index === 0) &#123; return; &#125; this.swapItems(this.results, index, 0, &quot;up&quot;);&#125;,// 索引下移down(index) &#123; if (index === this.results.length - 1) &#123; return; &#125; this.swapItems(this.results, index, index + 1);&#125;,// 索引置底downIndex(index) &#123; if (index === this.results.length - 1) &#123; return; &#125; this.swapItems(this.results, index, 0, &apos;down&apos;);&#125;,// 交换索引swapItems(arr, index1, index2, direction) &#123; if (direction == &apos;up&apos;) &#123; //置顶 arr.unshift(arr[index1]); arr.splice(index1 + 1, 1); return arr; &#125; if (direction == &apos;down&apos;) &#123; //置底 arr.push(arr[index1]); arr.splice(index1, 1); return arr; &#125; arr[index1] = arr.splice(index2, 1, arr[index1])[0]; return arr;&#125;, 0x05 时间分割1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495function DateFormt(date,fmt) &#123; if(date instanceof Date)&#123;&#125;else&#123; date = new Date() &#125; var o = &#123; &quot;M+&quot;: date.getMonth() + 1, //月份 &quot;d+&quot;: date.getDate(), //日 &quot;h+&quot;: date.getHours(), //小时 &quot;m+&quot;: date.getMinutes(), //分 &quot;s+&quot;: date.getSeconds(), //秒 &quot;q+&quot;: Math.floor((date.getMonth() + 3) / 3), //季度 &quot;S&quot;: date.getMilliseconds() //毫秒 &#125;; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (date.getFullYear() + &quot;&quot;).substr(4 - RegExp.$1.length)); for (var k in o) if (new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length))); return fmt;&#125;function X_list( etime,dtime,T)&#123; T = T || &quot;10m&quot; // 10m 1h 1d var relist = [] if(T==&quot;10m&quot;)&#123; while(true)&#123; if(etime&gt;dtime)&#123; break &#125; var str_date = DateFormt(etime,&quot;yyyy-MM-dd&quot;) //relist = [] for(var i=0;i&lt;24;i++)&#123; for(var ii=0;ii&lt;=5;ii++)&#123; var hh = &quot;&quot; var mm = &quot;&quot; hh = (i.toString().length == 1) ? (&quot;0&quot;+i.toString()) : (i.toString()) mm = ii.toString()+&quot;0&quot; relist.push(str_date+&apos; &apos;+hh+mm) &#125; &#125; etime.setDate(etime.getDate()+1) &#125; &#125; else if(T==&quot;1h&quot;)&#123; var tmp_etime = new Date(etime) var tmp_dtime = new Date(dtime) tmp_dtime.setDate(tmp_dtime.getDate()+1) var all_list = X_list(tmp_etime,tmp_dtime) var j = 1 while(true)&#123; if(etime&gt;dtime)&#123; break &#125; var str_date = DateFormt(etime,&quot;yyyy-MM-dd&quot;) for(var i=0;i&lt;24;i++)&#123; var hh = &quot;&quot; hh = (i.toString().length == 1) ? (&quot;0&quot;+i.toString()) : (i.toString()) var tmp10m = [] for(var ii = 0;ii&lt;6;ii++)&#123; tmp10m.push(all_list[j]) j++ &#125; relist[str_date+&apos; &apos;+hh] = tmp10m &#125; etime.setDate(etime.getDate()+1) &#125; &#125; else&#123; var tmp_etime = new Date(etime) var tmp_dtime = new Date(dtime) tmp_dtime.setDate(tmp_dtime.getDate()+1) var all_list = X_list(tmp_etime,tmp_dtime) var j = 1 while(true)&#123; if(etime&gt;dtime)&#123; break &#125; var str_date = DateFormt(etime,&quot;yyyy-MM-dd&quot;) var tmp10m = [] for(var ii=0;ii&lt;144;ii++)&#123; tmp10m.push(all_list[j]) j++ &#125; relist[str_date] = tmp10m etime.setDate(etime.getDate()+1) &#125; &#125; return relist&#125;var tmp_etime = new Date()var tmp_dtime = new Date(tmp_etime)// tmp_dtime.setDate(tmp_dtime.getDate()-7)// console.log( tmp_etime, tmp_dtime );console.log( X_list(tmp_dtime ,tmp_etime, &apos;1h&apos;) ); 获取object的键12var test = &#123;&quot;f&quot;:&quot;2323&quot;, &quot;d&quot;: &quot;test&quot;&#125;;console.log( Object.keys(test) );]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-反射]]></title>
    <url>%2F2019%2F02%2F10%2Fjava-%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[0x01 网络编程(UDP传输) 1.发送Send 创建DatagramSocket, 随机端口号 创建DatagramPacket, 指定数据, 长度, 地址, 端口 使用DatagramSocket发送DatagramPacket 关闭DatagramSocket 2.接收Receive 创建DatagramSocket, 指定端口号 创建DatagramPacket, 指定数组, 长度 使用DatagramSocket接收DatagramPacket 关闭DatagramSocket 从DatagramPacket中获取数据 3.接收方获取ip和端口号 String ip = packet.getAddress().getHostAddress(); int port = packet.getPort(); 0x02 网络编程(UDP传输优化) 接收端Receive 12345678910DatagramSocket socket = new DatagramSocket(6666); //创建socket相当于创建码头DatagramPacket packet = new DatagramPacket(new byte[1024], 1024); //创建packet相当于创建集装箱while(true) &#123; socket.receive(packet); //接收货物 byte[] arr = packet.getData(); int len = packet.getLength(); String ip = packet.getAddress().getHostAddress(); System.out.println(ip + &quot;:&quot; + new String(arr,0,len));&#125; 发送端Send 123456789101112DatagramSocket socket = new DatagramSocket(); //创建socket相当于创建码头Scanner sc = new Scanner(System.in);while(true) &#123; String str = sc.nextLine(); if(&quot;quit&quot;.equals(str)) break; DatagramPacket packet = //创建packet相当于创建集装箱 new DatagramPacket(str.getBytes(), str.getBytes().length, InetAddress.getByName(&quot;127.0.0.1&quot;), 6666); socket.send(packet); //发货&#125;socket.close(); 0x03 网络编程(UDP传输多线程) A发送和接收在一个窗口完成123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Demo3_MoreThread &#123; /** * @param args */ public static void main(String[] args) &#123; new Receive().start(); new Send().start(); &#125;&#125;class Receive extends Thread &#123; public void run() &#123; try &#123; DatagramSocket socket = new DatagramSocket(6666); //创建socket相当于创建码头 DatagramPacket packet = new DatagramPacket(new byte[1024], 1024); //创建packet相当于创建集装箱 while(true) &#123; socket.receive(packet); //接收货物 byte[] arr = packet.getData(); int len = packet.getLength(); String ip = packet.getAddress().getHostAddress(); System.out.println(ip + &quot;:&quot; + new String(arr,0,len)); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class Send extends Thread &#123; public void run() &#123; try &#123; DatagramSocket socket = new DatagramSocket(); //创建socket相当于创建码头 Scanner sc = new Scanner(System.in); while(true) &#123; String str = sc.nextLine(); if(&quot;quit&quot;.equals(str)) break; DatagramPacket packet = //创建packet相当于创建集装箱 new DatagramPacket(str.getBytes(), str.getBytes().length, InetAddress.getByName(&quot;127.0.0.1&quot;), 6666); socket.send(packet); //发货 &#125; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 0x04 网络编程(TCP协议) 1.客户端 创建Socket连接服务端(指定ip地址,端口号)通过ip地址找对应的服务器 调用Socket的getInputStream()和getOutputStream()方法获取和服务端相连的IO流 输入流可以读取服务端输出流写出的数据 输出流可以写出数据到服务端的输入流 2.服务端 创建ServerSocket(需要指定端口号) 调用ServerSocket的accept()方法接收一个客户端请求，得到一个Socket 调用Socket的getInputStream()和getOutputStream()方法获取和客户端相连的IO流 输入流可以读取客户端输出流写出的数据 输出流可以写出数据到客户端的输入流 0x05 网络编程(TCP协议代码优化) 客户端 1234567891011Socket socket = new Socket(&quot;127.0.0.1&quot;, 9999); //创建Socket指定ip地址和端口号InputStream is = socket.getInputStream(); //获取输入流OutputStream os = socket.getOutputStream(); //获取输出流BufferedReader br = new BufferedReader(new InputStreamReader(is));PrintStream ps = new PrintStream(os);System.out.println(br.readLine());ps.println(&quot;我想报名就业班&quot;);System.out.println(br.readLine());ps.println(&quot;爷不学了&quot;);socket.close(); 服务端 1234567891011121314ServerSocket server = new ServerSocket(9999); //创建服务器Socket socket = server.accept(); //接受客户端的请求InputStream is = socket.getInputStream(); //获取输入流OutputStream os = socket.getOutputStream(); //获取输出流BufferedReader br = new BufferedReader(new InputStreamReader(is));PrintStream ps = new PrintStream(os);ps.println(&quot;hellow&quot;);System.out.println(br.readLine());ps.println(&quot;test&quot;);System.out.println(br.readLine());server.close();socket.close(); 0x06 网络编程(服务端是多线程的)1234567891011121314151617181920ServerSocket server = new ServerSocket(9999); //创建服务器 while(true) &#123; final Socket socket = server.accept(); //接受客户端的请求 new Thread() &#123; public void run() &#123; try &#123; BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); PrintStream ps = new PrintStream(socket.getOutputStream()); ps.println(&quot;gests&quot;); System.out.println(br.readLine()); ps.println(&quot;esgsd&quot;); System.out.println(br.readLine()); socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;.start(); &#125;&#125; 0x07 网络编程 客户端向服务器写字符串(键盘录入),服务器(多线程)将字符串反转后写回,客户端再次读取到是反转后的字符串123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintStream;import java.net.Socket;import java.net.UnknownHostException;import java.util.Scanner;public class Test1_Client &#123; /** * 客户端向服务器写字符串(键盘录入),服务器(多线程)将字符串反转后写回,客户端再次读取到是反转后的字符串 * @throws IOException * @throws UnknownHostException */ public static void main(String[] args) throws UnknownHostException, IOException &#123; Scanner sc = new Scanner(System.in); //创建键盘录入对象 Socket socket = new Socket(&quot;127.0.0.1&quot;, 54321); //创建客户端,指定ip地址和端口号 BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); //获取输入流 PrintStream ps = new PrintStream(socket.getOutputStream());//获取输出流 ps.println(sc.nextLine()); //将字符串写到服务器去 System.out.println(br.readLine()); //将反转后的结果读出来 socket.close(); &#125;&#125;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintStream;import java.net.ServerSocket;import java.net.Socket;public class Test1_Server &#123; /** * @param args * @throws IOException */ public static void main(String[] args) throws IOException &#123; ServerSocket server = new ServerSocket(54321); System.out.println(&quot;服务器启动,绑定54321端口&quot;); while(true) &#123; final Socket socket = server.accept(); //接受客户端的请求 new Thread() &#123; //开启一条线程 public void run() &#123; try &#123; BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); //获取输入流 PrintStream ps = new PrintStream(socket.getOutputStream());//获取输出流 String line = br.readLine(); //将客户端写过来的数据读取出来 line = new StringBuilder(line).reverse().toString(); //链式编程 ps.println(line); //反转后写回去 socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;.start(); &#125; &#125;&#125; 0x08 网络编程 客户端向服务器上传文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134import java.io.BufferedReader;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintStream;import java.net.Socket;import java.net.UnknownHostException;import java.util.Scanner;public class Test2_UpdateClient &#123; /** * @param args * @throws IOException * @throws UnknownHostException */ public static void main(String[] args) throws UnknownHostException, IOException &#123; // 1.提示输入要上传的文件路径, 验证路径是否存在以及是否是文件夹 File file = getFile(); // 2.发送文件名到服务端 Socket socket = new Socket(&quot;127.0.0.1&quot;, 12345); BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); PrintStream ps = new PrintStream(socket.getOutputStream()); ps.println(file.getName()); // 6.接收结果, 如果存在给予提示, 程序直接退出 String result = br.readLine(); //读取存在后不存在的结果 if(&quot;存在&quot;.equals(result)) &#123; System.out.println(&quot;您上传的文件已经存在,请不要重复上传&quot;); socket.close(); return; &#125; // 7.如果不存在, 定义FileInputStream读取文件, 写出到网络 FileInputStream fis = new FileInputStream(file); byte[] arr = new byte[8192]; int len; while((len = fis.read(arr)) != -1) &#123; ps.write(arr, 0, len); &#125; fis.close(); socket.close(); &#125; private static File getFile() &#123; Scanner sc = new Scanner(System.in); //创建键盘录入对象 System.out.println(&quot;请输入一个文件路径:&quot;); while(true) &#123; String line = sc.nextLine(); File file = new File(line); if(!file.exists()) &#123; System.out.println(&quot;您录入的文件路径不存在,请重新录入:&quot;); &#125;else if(file.isDirectory()) &#123; System.out.println(&quot;您录入的是文件夹路径,请输入一个文件路径:&quot;); &#125;else &#123; return file; &#125; &#125; &#125;&#125;import java.io.BufferedReader;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.PrintStream;import java.net.ServerSocket;import java.net.Socket;public class Test2_UpdateServer &#123; /** * @param args * @throws IOException */ public static void main(String[] args) throws IOException &#123; //3,建立多线程的服务器 ServerSocket server = new ServerSocket(12345); System.out.println(&quot;服务器启动,绑定12345端口号&quot;); //4.读取文件名 while(true) &#123; final Socket socket = server.accept(); //接受请求 new Thread() &#123; public void run() &#123; try &#123; InputStream is = socket.getInputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(is)); PrintStream ps = new PrintStream(socket.getOutputStream()); String fileName = br.readLine(); //5.判断文件是否存在, 将结果发回客户端 File dir = new File(&quot;update&quot;); dir.mkdir(); //创建文件夹 File file = new File(dir,fileName); //封装成File对象 if(file.exists()) &#123; //如果服务器已经存在这个文件 ps.println(&quot;存在&quot;); //将存在写给客户端 socket.close(); //关闭socket return; &#125;else &#123; ps.println(&quot;不存在&quot;); &#125; //8.定义FileOutputStream, 从网络读取数据, 存储到本地 FileOutputStream fos = new FileOutputStream(file); byte[] arr = new byte[8192]; int len; while((len = is.read(arr)) != -1) &#123; fos.write(arr, 0, len); &#125; fos.close(); socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;.start(); &#125; &#125;&#125; 0x09 反射(类的加载概述和加载时机) A:类的加载概述 当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。 加载 就是指将class文件读入内存，并为之创建一个Class对象。任何类被使用时系统都会建立一个Class对象。 连接 验证 是否有正确的内部结构，并和其他类协调一致 准备 负责为类的静态成员分配内存，并设置默认初始化值 解析 将类的二进制数据中的符号引用替换为直接引用 初始化 就是我们以前讲过的初始化步骤 B:加载时机 创建类的实例 访问类的静态变量，或者为静态变量赋值 调用类的静态方法 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象 初始化某个类的子类 直接使用java.exe命令来运行某个主类 0x10 反射(类加载器的概述和分类) A:类加载器的概述 负责将.class文件加载到内存中，并为之生成对应的Class对象。虽然我们不需要关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行。 B:类加载器的分类 Bootstrap ClassLoader 根类加载器 Extension ClassLoader 扩展类加载器 Sysetm ClassLoader 系统类加载器 C:类加载器的作用 Bootstrap ClassLoader 根类加载器 也被称为引导类加载器，负责Java核心类的加载 比如System,String等。在JDK中JRE的lib目录下rt.jar文件中 Extension ClassLoader 扩展类加载器 负责JRE的扩展目录中jar包的加载。 在JDK中JRE的lib目录下ext目录 Sysetm ClassLoader 系统类加载器 负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径 0x11 反射(反射概述) A:反射概述 JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法； 对于任意一个对象，都能够调用它的任意一个方法和属性； 这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 要想解剖一个类,必须先要获取到该类的字节码文件对象。 而解剖使用的就是Class类中的方法，所以先要获取到每一个字节码文件对应的Class类型的对象。 B:三种方式 a:Object类的getClass()方法,判断两个对象是否是同一个字节码文件 b:静态属性class,锁对象 c:Class类中静态方法forName(),读取配置文件 C:案例演示 获取class文件对象的三种方式123456789101112131415161718public class Demo1_Reflect &#123; /** * @param args * @throws ClassNotFoundException */ public static void main(String[] args) throws ClassNotFoundException &#123; Class clazz1 = Class.forName(&quot;com.heima.bean.Person&quot;); Class clazz2 = Person.class; Person p = new Person(); Class clazz3 = p.getClass(); System.out.println(clazz1 == clazz2); System.out.println(clazz2 == clazz3); &#125;&#125; 0x12 反射(Class.forName()读取配置文件举例) 榨汁机(Juicer)榨汁的案例 分别有水果(Fruit)苹果(Apple)香蕉(Banana)桔子(Orange)榨汁(squeeze)1234567891011121314151617181920212223242526272829303132333435363738394041public class Demo2_Reflect &#123; /** * 榨汁机(Juicer)榨汁的案例 * 分别有水果(Fruit)苹果(Apple)香蕉(Banana)桔子(Orange)榨汁(squeeze) * @throws Exception */ public static void main(String[] args) throws Exception &#123; /*Juicer j = new Juicer(); //j.run(new Apple()); j.run(new Orange());*/ BufferedReader br = new BufferedReader(new FileReader(&quot;config.properties&quot;)); //创建输入流对象,关联配置文件 Class&lt;?&gt; clazz = Class.forName(br.readLine()); //读取配置文件一行内容,获取该类的字节码对象 Fruit f = (Fruit) clazz.newInstance(); //通过字节码对象创建实例对象 Juicer j = new Juicer(); j.run(f); &#125;&#125;interface Fruit &#123; public void squeeze();&#125;class Apple implements Fruit &#123; public void squeeze() &#123; System.out.println(&quot;榨出一杯苹果汁儿&quot;); &#125;&#125;class Orange implements Fruit &#123; public void squeeze() &#123; System.out.println(&quot;榨出一杯桔子汁儿&quot;); &#125;&#125;class Juicer &#123; public void run(Fruit f) &#123; f.squeeze(); &#125;&#125; 0x13 反射(通过反射获取带参构造方法并使用) Constructor12345678910111213141516171819202122* Class类的newInstance()方法是使用该类无参的构造函数创建对象, 如果一个类没有无参的构造函数, 就不能这样创建了,可以调用Class类的getConstructor(String.class,int.class)方法获取一个指定的构造函数然后再调用Constructor类的newInstance(&quot;张三&quot;,20)方法创建对象import java.lang.reflect.Constructor;public class Demo3_Constructor &#123; /** * Class类的newInstance()方法是使用该类无参的构造函数创建对象, 如果一个类没有无参的构造函数, * 就不能这样创建了,可以调用Class类的getConstructor * (String.class,int.class)方法获取一个指定的构造函数然后再调用Constructor类的newInstance * (&quot;张三&quot;,20)方法创建对象 * @throws Exception */ public static void main(String[] args) throws Exception &#123; Class clazz = Class.forName(&quot;com.heima.bean.Person&quot;); //Person p = (Person) clazz.newInstance(); 通过无餐构造创建对象 //System.out.println(p); Constructor c = clazz.getConstructor(String.class,int.class); //获取有参构造 Person p = (Person) c.newInstance(&quot;张三&quot;,23); //通过有参构造创建对象 System.out.println(p); &#125;&#125; 0x14 反射(通过反射获取成员变量并使用) Field123456789101112131415161718192021222324252627* Class.getField(String)方法可以获取类中的指定字段(可见的), 如果是私有的可以用getDeclaedField(&quot;name&quot;)方法获取,通过set(obj, &quot;李四&quot;)方法可以设置指定对象上该字段的值, 如果是私有的需要先调用setAccessible(true)设置访问权限,用获取的指定的字段调用get(obj)可以获取指定对象中该字段的值import java.lang.reflect.Constructor;import java.lang.reflect.Field;public class Demo4_Field &#123; /** * Class.getField(String)方法可以获取类中的指定字段(可见的), * 如果是私有的可以用getDeclaedField(&quot;name&quot;)方法获取,通过set(obj, &quot;李四&quot;)方法可以设置指定对象上该字段的值, * 如果是私有的需要先调用setAccessible(true)设置访问权限,用获取的指定的字段调用get(obj)可以获取指定对象中该字段的值 * @throws Exception */ public static void main(String[] args) throws Exception &#123; Class clazz = Class.forName(&quot;com.heima.bean.Person&quot;); Constructor c = clazz.getConstructor(String.class,int.class); //获取有参构造 Person p = (Person) c.newInstance(&quot;张三&quot;,23); //通过有参构造创建对象 //Field f = clazz.getField(&quot;name&quot;); //获取姓名字段 //f.set(p, &quot;李四&quot;); //修改姓名的值 Field f = clazz.getDeclaredField(&quot;name&quot;); //暴力反射获取字段 f.setAccessible(true); //去除私有权限 f.set(p, &quot;李四&quot;); System.out.println(p); &#125;&#125; 0x15 反射(通过反射获取方法并使用) Method1234567891011121314151617181920212223242526* Class.getMethod(String, Class...) 和 Class.getDeclaredMethod(String, Class...)方法可以获取类中的指定方法,调用invoke(Object, Object...)可以调用该方法,Class.getMethod(&quot;eat&quot;) invoke(obj) Class.getMethod(&quot;eat&quot;,int.class) invoke(obj,10)import java.lang.reflect.Constructor;import java.lang.reflect.Method;public class Demo5_Method &#123; /** * Class.getMethod(String, Class...) 和 Class.getDeclaredMethod(String, * Class...)方法可以获取类中的指定方法,调用invoke(Object, * Object...)可以调用该方法,Class.getMethod(&quot;eat&quot;) invoke(obj) * Class.getMethod(&quot;eat&quot;,int.class) invoke(obj,10) * @throws Exception */ public static void main(String[] args) throws Exception &#123; Class clazz = Class.forName(&quot;com.heima.bean.Person&quot;); Constructor c = clazz.getConstructor(String.class,int.class); //获取有参构造 Person p = (Person) c.newInstance(&quot;张三&quot;,23); //通过有参构造创建对象 Method m = clazz.getMethod(&quot;eat&quot;); //获取eat方法 m.invoke(p); Method m2 = clazz.getMethod(&quot;eat&quot;, int.class); //获取有参的eat方法 m2.invoke(p, 10); &#125;&#125; 0x16 反射(通过反射越过泛型检查) A:案例演示1234567891011121314151617181920212223242526* ArrayList&lt;Integer&gt;的一个对象，在这个集合中添加一个字符串数据，如何实现呢？import java.lang.reflect.Method;import java.util.ArrayList;public class Test1 &#123; /** * @param args * ArrayList&lt;Integer&gt;的一个对象，在这个集合中添加一个字符串数据，如何实现呢？ * 泛型只在编译期有效,在运行期会被擦除掉 * @throws Exception */ public static void main(String[] args) throws Exception &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(111); list.add(222); Class clazz = Class.forName(&quot;java.util.ArrayList&quot;); //获取字节码对象 Method m = clazz.getMethod(&quot;add&quot;, Object.class); //获取add方法 m.invoke(list, &quot;abc&quot;); System.out.println(list); &#125;&#125; 0x17 反射(通过反射写一个通用的设置某个对象的某个属性为指定的值) A:案例演示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465* public void setProperty(Object obj, String propertyName, Object value)&#123;&#125;，此方法可将obj对象中名为propertyName的属性的值设置为value。import java.lang.reflect.Field;public class Tool &#123; //此方法可将obj对象中名为propertyName的属性的值设置为value。 public void setProperty(Object obj, String propertyName, Object value) throws Exception &#123; Class clazz = obj.getClass(); //获取字节码对象 Field f = clazz.getDeclaredField(propertyName); //暴力反射获取字段 f.setAccessible(true); //去除权限 f.set(obj, value); &#125;&#125;public class Test3 &#123; /** * * A:案例演示 * public void setProperty(Object obj, String propertyName, Object value)&#123;&#125;， * 此方法可将obj对象中名为propertyName的属性的值设置为value。 * @throws Exception */ public static void main(String[] args) throws Exception &#123; Student s = new Student(&quot;张三&quot;, 23); System.out.println(s); Tool t = new Tool(); t.setProperty(s, &quot;name&quot;, &quot;李四&quot;); System.out.println(s); &#125;&#125;class Student &#123; private String name; private int age; public Student() &#123; super(); &#125; public Student(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; &#125; &#125; 0x18 反射(练习) 已知一个类，定义如下： 123456789101112131415161718192021222324252627282930313233343536* package cn.itcast.heima;* public class DemoClass &#123; public void run() &#123; System.out.println(&quot;welcome to heima!&quot;); &#125; &#125;* (1) 写一个Properties格式的配置文件，配置类的完整名称。 * (2) 写一个程序，读取这个Properties配置文件，获得类的完整名称并加载这个类，用反射的方式运行run方法。import java.io.BufferedReader;import java.io.FileNotFoundException;import java.io.FileReader;public class Test2 &#123; /** * * 已知一个类，定义如下： * package cn.itcast.heima; * public class DemoClass &#123; public void run() &#123; System.out.println(&quot;welcome to heima!&quot;); &#125; &#125; * (1) 写一个Properties格式的配置文件，配置类的完整名称。 * (2) 写一个程序，读取这个Properties配置文件，获得类的完整名称并加载这个类，用反射的方式运行run方法。 * @throws Exception */ public static void main(String[] args) throws Exception &#123; BufferedReader br = new BufferedReader(new FileReader(&quot;xxx.properties&quot;)); //创建输入流关联xxx.properties Class clazz = Class.forName(br.readLine()); //读取配置文件中类名,获取字节码对象 DemoClass dc = (DemoClass) clazz.newInstance(); //通过字节码对象创建对象 dc.run(); &#125;&#125; 0x19 反射(动态代理的概述和实现) A:动态代理概述 代理：本来应该自己做的事情，请了别人来做，被请的人就是代理对象。 举例：春节回家买票让人代买 动态代理：在程序运行过程中产生的这个对象,而程序运行过程中产生对象其实就是我们刚才反射讲解的内容，所以，动态代理其实就是通过反射来生成一个代理 在Java中java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过使用这个类和接口就可以生成动态代理对象。JDK提供的代理只能针对接口做代理。我们有更强大的代理cglib，Proxy类中的方法创建动态代理类对象 public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 最终会调用InvocationHandler的方法 InvocationHandler Object invoke(Object proxy,Method method,Object[] args) 0x20 设计模式(模版(Template)设计模式概述和使用) A:模版设计模式概述 模版方法模式就是定义一个算法的骨架，而将具体的算法延迟到子类中来实现 B:优点和缺点 a:优点 使用模版方法模式，在定义算法骨架的同时，可以很灵活的实现具体的算法，满足用户灵活多变的需求 b:缺点 如果算法骨架有修改的话，则需要修改抽象类1,装饰2,单例3,简单工厂4,工厂方法5,适配器6,模版 0x21 JDK7新特性(JDK7的六个新特性) A:二进制字面量 B:数字字面量可以出现下划线 C:switch 语句可以用字符串 D:泛型简化,菱形泛型 E:异常的多个catch合并,每个异常用或| F:try-with-resources 语句 0x22 JDK8新特性(JDK8的新特性) 接口中可以定义有方法体的方法,如果是非静态,必须用default修饰 如果是静态的就不用了1234567891011121314class Test &#123; public void run() &#123; final int x = 10; class Inner &#123; public void method() &#123; System.out.println(x); &#125; &#125; Inner i = new Inner(); i.method(); &#125; &#125; 局部内部类在访问他所在方法中的局部变量必须用final修饰,为什么?因为当调用这个方法时,局部变量如果没有用final修饰,他的生命周期和方法的生命周期是一样的,当方法弹栈,这个局部变量也会消失,那么如果局部内部类对象还没有马上消失想用这个局部变量,就没有了,如果用final修饰会在类加载的时候进入常量池,即使方法弹栈,常量池的常量还在,也可以继续使用]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[env-centos环境配置]]></title>
    <url>%2F2019%2F02%2F01%2Fenv-centos%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[0x01 安装python3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354551. 准备编译环境# yum -y install gcc make readline-devel sqlite-devel openssl openssl-devel zlib*2. 编译安装# wget -P /root http://python.org/ftp/python/3.6.4/Python-3.6.4.tar.xz# tar xf Python-3.6.4.tar.xz# cd Python-3.6.4/# ./configure --prefix=/usr/local/python-3.6# make &amp;&amp; make install# ln -s /usr/local/python-3.6/bin/python3.6 /usr/bin/python3# ln -s /usr/local/python-3.6/bin/pip3.6 /usr/bin/pip33. 更改pip安装源为国内的源，比如aliyun# mkdir ~/.pip# vi ~/.pip/pip.conf添加内容如下：[global]index-url = http://mirrors.aliyun.com/pypi/simple/[install]trusted-host=mirrors.aliyun.com4. 准备virtualenv环境# pip3 install virtualenv# ln -s /usr/local/python-3.6/bin/virtualenv /usr/bin/virtualenv# cd /home/www/flask_project# virtualenv --no-site-packages --python=/usr/bin/python3 venv35. 安装相关python包# source venv3/bin/active(venv3)# pip3 install flask依次安装完所有的依赖包后,(venv3)# pip3 freeze &gt; requirements.txt6. 测试用Flask自带的服务器能否运行(venv3)# python manage.py 列出虚拟环境列表workon也可以使用lsvirtualenv新建虚拟环境mkvirtualenv [虚拟环境名称]启动/切换虚拟环境workon [虚拟环境名称]删除虚拟环境rmvirtualenv [虚拟环境名称]离开虚拟环境deactivate 0x02 安装Firewall12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# yum install -y firewalld# systemctl start firewalld# systemctl enable firewalld# systemctl restart firewalld.# systemctl status firewalld # systemctl stop firewalld # firewall-cmd --list-all firewall-cmd --zone=work --add-service=smtp# 配置firewalld# 移除服务firewall-cmd --zone=work --remove-service=smtp# 显示支持的区域列表firewall-cmd --get-zones# 设置为家庭区域firewall-cmd --set-default-zone=home# 查看当前区域firewall-cmd --get-active-zones# 设置当前区域的接口firewall-cmd --get-zone-of-interface=enp03s# 显示所有公共区域（public）firewall-cmd --zone=public --list-all# 临时修改网络接口（enp0s3）为内部区域（internal）firewall-cmd --zone=internal --change-interface=enp03s# 永久修改网络接口enp03s为内部区域（internal）firewall-cmd --permanent --zone=internal --change-interface=enp03s# 端口设置# firewall-cmd --add-port=8081/tcp --permanent # firewall-cmd --remove-port=9200/tcp --permanent# ip和端口设置# firewall-cmd --permanent --add-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;192.168.1.1&quot; port protocol=&quot;tcp&quot; port=&quot;5000&quot; accept&quot;# firewall-cmd --permanent --remove-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;192.168.1.1&quot; port protocol=&quot;tcp&quot; port=&quot;11300&quot; accept&quot;# firewall-cmd --permanent --add-rich-rule=&quot;rule family=&apos;ipv4&apos; source address=&apos;222.222.222.222&apos; reject&quot; 单个IP# firewall-cmd --permanent --add-rich-rule=&quot;rule family=&apos;ipv4&apos; source address=&apos;222.222.222.0/24&apos; reject&quot; IP段# 服务设置# 显示服务列表 Amanda, FTP, Samba和TFTP等最重要的服务已经被FirewallD提供相应的服务，可以使用如下命令查看：firewall-cmd --get-services# 允许SSH服务通过firewall-cmd --enable service=ssh# 禁止SSH服务通过firewall-cmd --disable service=ssh# 打开TCP的8080端口firewall-cmd --enable ports=8080/tcp# 临时允许Samba服务通过600秒firewall-cmd --enable service=samba --timeout=600# 显示当前服务firewall-cmd --list-services# 添加HTTP服务到内部区域（internal）firewall-cmd --permanent --zone=internal --add-service=httpfirewall-cmd --reload # 在不改变状态的条件下重新加载防火墙# firewall-cmd --add-service=mysql # 开放mysql端口# firewall-cmd --remove-service=http # 阻止http端口# firewall-cmd --list-services # 查看开放的服务# firewall-cmd --add-port=3306/tcp # 开放通过tcp访问3306# firewall-cmd --remove-port=80tcp # 阻止通过tcp访问3306# firewall-cmd --add-port=233/udp # 开放通过udp访问233# firewall-cmd --list-ports # 查看开放的端口# firewall-cmd --reload #重新加载# 流量转发# firewall-cmd --add-forward-port=port=80:proto=tcp:toport=8080 # 将80端口的流量转发至8080# firewall-cmd --add-forward-port=port=80:proto=tcp:toaddr=192.168.0.1 # 将80端口的流量转发至192.168.0.1# firewall-cmd --add-forward-port=port=80:proto=tcp:toaddr=192.168.0.1:toport=8080 # 将80端口的流量转发至192.168.0.1的8080端口 0x03 安装mysql1234567891011121314151617181920212223242526Centos7 Mysql57:wget https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpmsudo rpm -ivh mysql57-community-release-el7-9.noarch.rpmsudo yum install mysql-serversudo systemctl start mysqld# 获取临时密码sudo grep &apos;temporary password&apos; /var/log/mysqld.log# 设置开机启动sudo systemctl enable mysqld# 安全设置sudo mysql_secure_installation# 修改密码mysql&gt; ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;11111&apos;;# 开放远程登录权限 mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;11111&apos; WITH GRANT OPTION; mysql&gt; FLUSH PRIVILEGES;其它样列:GRANT select,insert,update,delete on test.* to &apos;test&apos;@&apos;%&apos; IDENTIFIED BY &quot;11111&quot;; GRANT select on test.* to &apos;test&apos;@&apos;%&apos; IDENTIFIED BY &quot;11111&quot;; FLUSH PRIVILEGES; 0x04 Vue在nginx配置123456vue在nginx上配置：location / &#123; #default_type text/html; #index index.html; try_files $uri $uri/ /index.html;&#125; 0x05 Docker配置12345创建容器：[这样可以使用systemctl启动服务了]# docker run -d -name centos7 --privileged=true centos:7 /usr/sbin/init进入容器：# docker exec -it centos7 /bin/bash 0x06 Curl使用12345678910111213141516171819202122232425262728# POST请求curl -H &quot;Content-Type: application/json&quot; -X POST --data &apos;&#123;&quot;username&quot;:&quot;admin&quot;, &quot;password&quot;:&quot;admin&quot;&#125;&apos; http://127.0.0.1:5000/api/token/# 如果要把这个网页保存下来，可以使用`-o`参数，这就相当于使用wget命令了curl -o [文件名] www.sina.com# `-i`参数可以显示http response的头信息，连同网页代码一起。curl -i www.sina.com# 假定文件上传的表单是下面这样： &lt;form method=&quot;POST&quot; enctype=&apos;multipart/form-data&apos; action=&quot;upload.cgi&quot;&gt; &lt;input type=file name=upload&gt; &lt;input type=submit name=press value=&quot;OK&quot;&gt; &lt;/form&gt;# 你可以用curl这样上传文件：curl --form upload=@localfilename --form press=OK [URL]curl --referer http://www.example.com http://www.example.comcurl --user-agent &quot;[User Agent]&quot; [URL]curl --cookie &quot;name=xxx&quot; www.example.com# `-c cookie-file`可以保存服务器返回的cookie到文件，`-b cookie-file`可以使用这个文件作为cookie信息，进行后续的请求。curl -c cookies http://example.comcurl -b cookies http://example.com# 有些网域需要HTTP认证，这时curl需要用到`--user`参数。curl --user name:password example.com]]></content>
      <categories>
        <category>misc</category>
      </categories>
      <tags>
        <tag>env</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-spark安装]]></title>
    <url>%2F2019%2F01%2F03%2Fjava-spark%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[0x01 zookeeper集群搭建 安装 Java从官网下载最新版 Java 就可以，Spark官方说明 Java 只要是6以上的版本都可以，我下的是 jdk-8-linux-x64.gz; 在~/workspace目录下直接解压 123456789tar -zxvf jdk-7u75-linux-x64.gz修改环境变量sudo vi /etc/profile，添加下列内容，注意将home路径替换成你的：export WORK_SPACE=/home/spark/workspace/export JAVA_HOME=$WORK_SPACE/jdk1.8export JRE_HOME=/home/spark/work/jdk1.8/jreexport PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATHexport CLASSPATH=$CLASSPATH:.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib然后使环境变量生效，并验证 Java 是否安装成功 $ source /etc/profile #生效环境变量$ java -version #如果打印出如下版本信息，则说明安装成功 123java version &quot;1.8.0_75&quot;Java(TM) SE Runtime Environment (build 1.8.0_75-b13)Java HotSpot(TM) 64-Bit Server VM (build 24.75-b04, mixed mode) 安装zookeeper12345678910111213141516171819202122232425262728293031sudo wget https://archive.apache.org/dist/kafka/0.10.1.0/kafka_2.11-0.10.1.0.tgzsudo tar -zxf kafka_2.11-0.10.1.0.tgz -C /usr/localsudo mv /usr/local/kafka_2.11-0.10.1.0 /usr/local/kafkacd /usr/local/kafka/config/sudo vi zookeeper.properties dataDir=/usr/local/kafka/zookeeper dataLogDir=/usr/local/kafka/log/zookeeper clientPort=2181 maxClientCnxns=100 tickTime=2000 initLimit=10 synvLimit=5 server.1=192.168.1.1:2888:3888 server.1=192.168.1.2:2888:3888sudo mkdir /usr/local/kafka/zookeepersudo mkdir -p /usr/local/kafka/log/zookeepercd /usr/local/kafka/zookeeper/# myid是zk集群用来发现彼此的标识，必须创建，且不能相同；sudo vi myid 1 #每台机器不同进入kafka目录 执行启动zookeeper命令： cd /usr/local/kafka/bin/sudo nohup ./bin/zookeeper-server-start.sh config/zookeeper.properties &amp; 三台机器都执行启动命令，查看zookeeper的日志文件，没有报错就说明zookeeper集群启动成功了。 0x02 kafka集群搭建12345678910111213141516171819202122sudo mkdir -p /usr/local/kafka/log/kafkacd config broker.id=1 #每台机器不同 port=9092 host.name=192.168.1.1 num.network.threads=3 num.io.threads=8 socket.send.buffer.bytes=102400 socket.receive.buffer.bytes=102400 socket.request.max.bytes=104857600 log.dirs=/usr/local/kafka/log/kafka num.partitions=1 num.recovery.threads.per.data.dir=1 log.retention.hours=168 log.segment.bytes=1073741824 log.retention.check.interval.ms=300000 zookeeper.connect=192.168.1.1:2181,192.168.1.2:2181 zookeeper.connection.timeout.ms=6000cd /usr/local/kafka/sudo ./bin/kafka-server-start.sh -daemon config/server.properties 更新kafka的offset异常问题:bin/kafka-consumer-groups.sh –bootstrap-server localhost:9092 –group test-group –reset-offsets –all-topics –to-current –executebin/kafka-consumer-groups.sh –bootstrap-server localhost:9092 –group test-group –reset-offsets –all-topics –to-offset 500000 –execute –更新到指定位置bin/kafka-consumer-groups.sh –bootstrap-server localhost:9092 –group test-group –reset-offsets –all-topics –to-earliest –execute –更新到最初位置 0x03 kafka管理界面1234567sudo unzip kafka-manager-1.3.3.7.zip -d /usr/localsudo mv /usr/local/kafka-manager-1.3.3.7/ /usr/local/kafka-manager cd /usr/local/kafka-manager sudo vi conf/application.conf kafka-manager.zkhosts=&quot;192.168.1.1:2181,192.168.1.2:2181&quot; # 如果zk是集群，这里填写多个zk地址sudo nohup ./bin/kafka-manager -Dconfig.file=conf/application.conf -Dhttp.port=8080 &amp; 0x04 flume配置下载flume的包，查看lib文件夹下是否存在kafka依赖库文件cd /chj/soft/flume-1.8.0/./bin/flume-ng agent –conf conf –conf-file conf/flume-conf.properties –name a1 -Dflume.root.logger=INFO,console 123456789101112131415161718a1.sources = r1a1.sinks = k1a1.channels = c1a1.sources.r1.type = execa1.sources.r1.command = tail -F /usr/local/nginx/logs/access.log a1.sinks.k1.type = org.apache.flume.sink.kafka.KafkaSinka1.sinks.k1.topic = webloga1.sinks.k1.brokerList = 192.168.1.1:9092,192.168.1.2:9092 #把日志写入到kafkaa1.sinks.k1.requiredAcks = 1a1.sinks.k1.batchSize = 20 a1.channels.c1.type = memorya1.channels.c1.capacity = 1000a1.channels.c1.transactionCapacity = 100 a1.sources.r1.channels = c1a1.sinks.k1.channel = c1 0x05 测试1234567891011121314创建：./bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic wordsendertest生产：bin/kafka-console-producer.sh --broker-list 192.168.1.1:9092 --topic test-a消费：bin/kafka-console-consumer.sh --zookeeper 192.168.1.1:2181 --from-beginning --topic test-a列出已创建的topic列表./bin/kafka-topics.sh --list --zookeeper localhost:2181查看消费者是否连接到group，并消费偏移量sudo ./kafka-consumer-groups.sh --bootstrap-server 192.168.1.1:9092 --group ghh --describe 0x06 设置开机启动1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950yum install initscripts -ymkdir /tmp/runlogcd /etc/init.d/sudo vi zookeeper #!/bin/bash export JAVA_HOME=/chj/pkg/jdk export PATH=$JAVA_HOME/bin:$PATH export LOG_DIR=/tmp/kafka/runlog #chkconfig:2345 20 90 #description:zookeeper #processname:zookeeper case $1 in start) echo -n &quot;Starting zookeeper:&quot; /usr/local/kafka/bin/zookeeper-server-start.sh config/zookeeper.properties &gt; $LOG_DIR/server.out 2&gt; $LOG_DIR/server.err &amp; echo &quot; done.&quot; exit 0 ;; stop) echo -n &quot;Stopping Kafka: &quot; /usr/local/kafka/bin/zookeeper-server-stop.sh echo &quot; done.&quot; exit 0 ;; status) c_pid=`ps -ef | grep zookeeper.properties | grep -v grep | awk &apos;&#123;print $2&#125;&apos;` if [ &quot;$c_pid&quot; = &quot;&quot; ] ; then echo &quot;Stopped&quot; exit 3 else echo &quot;Running $c_pid&quot; exit 0 fi ;; restart) stop start ;; *) echo &quot;Usage: zookeeper start|stop|status|restart&quot; ;; esacsudo chmod 755 zookeepersudo service zookeeper statussudo chkconfig --add zookeepersudo chkconfig --listsudo chkconfig zookeeper on 其它同样操作。 0x07 Spark Install on Yarn机器互相1234567891011121314151617181920212223242526272829303132333435配置hosts在每台主机上修改host文件vi /etc/hosts10.1.1.107 master10.1.1.108 slave110.1.1.109 slave2配置之后ping一下用户名看是否生效ping slave1ping slave2SSH 免密码登录安装Openssh serversudo apt-get install openssh-server在所有机器上都生成私钥和公钥ssh-keygen -t rsa #一路回车需要让机器间都能相互访问，就把每个机子上的id_rsa.pub发给master节点，传输公钥可以用scp来传输。scp ~/.ssh/id_rsa.pub spark@master:~/.ssh/id_rsa.pub.slave1在master上，将所有公钥加到用于认证的公钥文件authorized_keys中cat ~/.ssh/id_rsa.pub* &gt;&gt; ~/.ssh/authorized_keys将公钥文件authorized_keys分发给每台slavescp ~/.ssh/authorized_keys spark@slave1:~/.ssh/在每台机子上验证SSH无密码通信ssh masterssh slave1ssh slave2如果登陆测试不成功，则可能需要修改文件authorized_keys的权限（权限的设置非常重要，因为不安全的设置安全设置,会让你不能使用RSA功能 ）chmod 600 ~/.ssh/authorized_keys 安装scala下载spark对应的Scala，注意不要下错版本，我这里下了 2.11.8，官方下载地址; 使用版本: Spark 2.1.3 Sacala 2.11.8 kafka 0.10.1.0 JDK 1.8 12345678910111213sudo wget https://downloads.lightbend.com/scala/2.11.8/scala-2.11.8.tgzsudo tar xf scala-2.11.8.tgz sudo mv scala-2.11.8 /usr/local/scala再次修改环境变量sudo vi /etc/profile，添加以下内容：export SCALA_HOME=/usr/local/scalaexport PATH=$PATH:$SCALA_HOME/bin同样的方法使环境变量生效，并验证 scala 是否安装成功$ source /etc/profile #生效环境变量$ scala -version #如果打印出如下版本信息，则说明安装成功Scala code runner version 2.11.8 -- Copyright 2002-2016, LAMP/EPFL 安装配置Hodoop Yarn下载地址。 需要配置有以下7个文件：hadoop-env.sh，yarn-env.sh，slaves，core-site.xml，hdfs-site.xml，maprd-site.xml，yarn-site.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123sudo wget https://archive.apache.org/dist/hadoop/core/current/hadoop-3.1.1.tar.gzsudo tar zxvf hadoop-3.1.1.tar.gzsudo mv hadoop-3.1.1 /usr/local/hadoopcd /usr/local/hadoop/etc/hadoop1.在hadoop-env.sh中配置JAVA_HOMEexport JAVA_HOME=/usr/local/jdk2.在yarn-env.sh中配置JAVA_HOMEexport JAVA_HOME=/usr/local/jdk3.在slaves中配置slave节点的ip或者host, 没有就先不配置slave1slave24.修改core-site.xml&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://master:9000/&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt;5.修改hdfs-site.xml&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt; &lt;value&gt;master:9001&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:/home/spark/workspace/hadoop-2.6.0/dfs/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;file:/home/spark/workspace/hadoop-2.6.0/dfs/data&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;3&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt;6.修改mapred-site.xml&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt;7.修改yarn-site.xml&lt;configuration&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services.mapreduce.shuffle.class&lt;/name&gt; &lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt; &lt;value&gt;master:8032&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt; &lt;value&gt;master:8030&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.resource-tracker.address&lt;/name&gt; &lt;value&gt;master:8035&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.admin.address&lt;/name&gt; &lt;value&gt;master:8033&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt; &lt;value&gt;master:8088&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt;将配置好的hadoop文件夹分发给所有slavessudo scp -r ~/usr/loacal/hadoop spark@slave1:~/usr/local/启动 Hadoop, 在 master 上执行以下操作，就可以启动 hadoop 了。cd /usr/loacal/hadoop #进入hadoop目录sudo bin/hadoop namenode -format #格式化namenodesudo sbin/start-dfs.sh #启动dfs sudo sbin/start-yarn.sh #启动yarn缺少用户定义造成的问题，在start-dfs.sh, 顶部空白处添加内容： HDFS_DATANODE_USER=root HADOOP_SECURE_DN_USER=hdfs HDFS_NAMENODE_USER=root HDFS_SECONDARYNAMENODE_USER=root 用户定义造成的问题，在start-yarn.sh, 顶部空白处添加内容： YARN_RESOURCEMANAGER_USER=rootHADOOP_SECURE_DN_USER=yarnYARN_NODEMANAGER_USER=root验证 Hadoop 是否安装成功可以通过jps命令查看各个节点启动的进程是否正常。在 master 上应该有以下几个进程：$ sudo jps #run on master3407 SecondaryNameNode3218 NameNode3552 ResourceManager3910 Jps在每个slave上应该有以下几个进程：$ sudo jps #run on slaves2072 NodeManager2213 Jps1962 DataNode或者在浏览器中输入 http://master:8088 ，应该有 hadoop 的管理界面出来了，并能看到 slave1 和 slave2 节点。 安装spark下载地址。 可以兼容hadoop2.7以后 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657sudo wget http://mirror.bit.edu.cn/apache/spark/spark-2.4.0/spark-2.4.0-bin-hadoop2.7.tgzsudo tar zxvf spark-2.4.0-bin-hadoop2.7.tgz sudo mv spark-2.4.0-bin-hadoop2.7 /usr/local/sparkcd /usr/local/spark/conf/sudo cp spark-env.sh.template spark-env.sh export SCALA_HOME=/usr/local/scala export JAVA_HOME=/usr/local/jdk export HADOOP_HOME=/usr/local/hadoop export HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop SPARK_MASTER_IP=master SPARK_LOCAL_DIRS=/usr/local/spark SPARK_DRIVER_MEMORY=1G注：在设置Worker进程的CPU个数和内存大小，要注意机器的实际硬件条件，如果配置的超过当前Worker节点的硬件条件，Worker进程会启动失败。vi slaves在slaves文件下填上slave主机名： slave1 slave2将配置好的spark文件夹分发给所有slaves吧sudo scp -r ~/usr/local/spark spark@slave1:~/usr/local/启动Sparksudo sbin/start-all.sh验证 Spark 是否安装成功用jps检查，在 master 上应该有以下几个进程：$ sudo jps7949 Jps7328 SecondaryNameNode7805 Master7137 NameNode7475 ResourceManager在 slave 上应该有以下几个进程：$ sudo jps3132 DataNode3759 Worker3858 Jps3231 NodeManager进入Spark的Web管理页面： http://master:8080运行示例：#本地模式两线程运行./bin/run-example SparkPi 10 --master local[2]#Spark Standalone 集群模式运行./bin/spark-submit --class org.apache.spark.examples.SparkPi --master spark://master:7077 lib/spark-examples-1.3.0-hadoop2.4.0.jar 100#Spark on YARN 集群上 yarn-cluster 模式运行./bin/spark-submit \ --class org.apache.spark.examples.SparkPi \ --master yarn-cluster \ lib/spark-examples*.jar \ 10 单机运行安装好jdk以后； 下载地址; 其它版本 12345678sudo wget http://mirror.bit.edu.cn/apache/spark/spark-2.4.0/spark-2.4.0-bin-hadoop2.7.tgzsudo tar zxvf spark-2.4.0-bin-hadoop2.7.tgz sudo mv spark-2.4.0-bin-hadoop2.7 /usr/local/sparksudo vim /etc/profile export SPARK_HOME=/usr/local/spark export PATH=$PATH:$SPARK_HOME/bin$ source /etc/profile #生效环境变量$ spark-shell #如果打印出如下版本信息，则说明安装成功; 如果出现主机名报错，修改hosts信息 在sbin的目录下的spark-config.sh 文件下添加JAVA_HOME的索引; 启动 1$ sudo /usr/local/spark/sbin/start-master.sh 添加任务 1234567891011121314151617181920212223242526272829sudo /usr/local/spark/bin/spark-submit --master spark://spark-master:7077 --class com.chj.sec.skyeye /opt/down/Skyeye2.jar如果报错，就需要复制依赖包到集群的master和slave机器的spark目录下的jars里面。--master：用于设置主结点URL的参数。 local：用于执行本地机器的代码。Spark运行一个单一的线程，在一个多核机器上，通过local[n]来指定一个具体使用的内核数，n指使用的内核数目，local[*]来指定运行和Spark机器内核一样多的复杂线程。 spark://host:port：这是一个URL和一个Spark单机集群的端口。 mesos://host:port：这是一个URL和一个部署在Mesos的Spark集群的端口。 yarn：作为负载均衡器，用于从运行Yarn的头结点提交作业。--deploy-mode：允许决定是否在本地（使用client）启动Spark驱动成簇的参数，或者在集群内（使用cluster选项）的其中一台工作机器上启动。默人是client。--name：应用程序名称。注意，创建SparkSession时，如果是以编程方式指定应用程序名称，那么来自命令行的参数会被重写。--py-files：.py、.egg或者.zip文件的逗号分隔列表，包括Python应用程序，这些文件将被交付给每一个执行器来使用。--files：命令给出一个逗号分隔的文件列表，这些文件将被交付给每一个执行器来使用。--conf：参数通过命令行动态地更改应用程序的配置。语法是：&lt;Spark property&gt;=&lt;value for the property&gt;。--properties-file：配置文件。它应该有和conf/spark-defaults.conf文件相同的属性设置，也是可读的。--driver-memory：指定应用程序在驱动程序上分配多少内存的参数。允许的值又一个语法限制，类似于1000M，2G。默认值是1024M。--exectuor-memory：参数指定每个执行器为应用程序分配多少内存。默认值是1G。--help：展示帮助信息和退出。--verbose：在运行应用程序时打印附加调试信息。--version：打印Spark版本。--class: 主类名称，含包名 --name: Application名称 --jars: Driver依赖的第三方jar包 --driver-cores: Driver程序的使用CPU个数，仅限于Spark Alone模式 --supervise: 失败后是否重启Driver，仅限于Spark Alone模式 --total-executor-cores: executor使用的总核数，仅限于Spark Alone、Spark on Mesos模式 --executor-cores: 每个executor使用的内核数，默认为1，仅限于Spark on Yarn模式 --queue: 提交应用程序给哪个YARN的队列，默认是default队列，仅限于Spark on Yarn模式 --num-executors: 启动的executor数量，默认是2个，仅限于Spark on Yarn模式 --archives: 仅限于Spark on Yarn模式 0x08 spark开发新建项目下载Intelij,直接安装； 新建scala项目并配置spark依赖和对应的kafka版本进行开发。 选择 Scala -&gt; SBT, 然点击 Next。 (SBT 是一个互动式的编译工具，详细了解看到 官网 查看。)然后给自己的项目取个名字，接着再根据自己Spark版本，选择合适的Java、Scala版本，最后点击 Finish 即可。 引入依赖包引入Spark的依赖, 进入项目后，点击左上角 File -&gt; Project Structure。 点击 Libraries ，然后点 绿色的加号。这时出现了三个选项： Java， Maven， Scala SDk。 也可以从Modules -&gt; Dependencies 导入本地依赖包。 如果你选择maven方式添加spark，可以参考这里，来获取 对于的maven链接。形如：org.apache.spark:spark-core_2.11:2.4.0; 代表：scala-2.11.* spark-2.4.0; 这个需要和线上的保持一致。接着就可以编写你的项目了！ 编写项目 导出jar包引入Spark的依赖, 进入项目后，点击左上角 File -&gt; Project Structure。 点击 Artifacts，如下: 点击build,选择build Artifacts进行构建 其它kafka连接方式Direct方式连接:将会创建跟kafka分区一样多的RDD partiions，并行的读取kafka topic的partition数据。kafka和RDD partition将会有一对一的对应关系。Receiver方式连接:Receiver-based Approach需要启用WAL才能保证消费不丢失数据，效率比较低。 offset设置:Spark Streaming checkpoints, 将offsets存储在HBase中, 将offsets存储到 ZooKeeper中, Kafka 本身, 其他方式。 spark官方推荐使用ml, 因为ml功能更全面更灵活，未来会主要支持ml，mllib很有可能会被废弃(据说可能是在spark3.0中deprecated）ml主要操作的是DataFrame,DataFrame是Dataset的子集，也就是Dataset[Row], 而DataSet是对RDD的封装，对SQL之类的操作做了很多优化ml中的操作可以使用pipeline, 跟sklearn一样，可以把很多操作(算法/特征提取/特征转换)以管道的形式串起来，然后让数据在这个管道中流动。大家可以脑补一下Linux管道在做任务组合时有多么方便。1.把所有的攻击语句里面的特殊字符和数字，函数转化为指定的字母， 作为观察的几个维度；2.把整个攻击语句泛化后的每个单词转化为数字，生成一个数组维度；3.查看这组数组是否在语句中出现过]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>ml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[project-数据安全分析]]></title>
    <url>%2F2018%2F12%2F26%2Fproject-%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[数据安全分析安全现状当前互联网企业存在很多业务风险，有些风险（比如薅羊毛）虽然没有sql注入漏洞利用来的直接，但是一直被羊毛党、刷单党光顾的企业长期生存下来的几率会很低！账号：垃圾注册、撞库、盗号等交易：盗刷、恶意占用资源、篡改交易金额等活动：薅羊毛短信：短信轰炸web攻击：webshell, 注入, XSS等隐私保护：密码，地址，手机等 安全大数据产线相关产品，通过对业务系统进行多个维度的日志数据采集，对数据解析、与场景和知识关联计算，以帮助用户对安全事件进行规划预防、实时监视、违规响应、追踪溯源，提取无序数据中的深层价值，消除信息孤岛，定位未知风险，制定防御阈值，协同完成安全能力的自动化安全编排、将安全威胁从应急响应升级为持续响应。此外，通过高效的大数据处理能力，助力企业用户明确安全基线和风险边界，基于场景构建业务安全模型，秒级发现威胁事件，持续应对安全威胁，提供有价值的决策建议。 数据安全治理核心是围绕数据内容和价值本身进行，通过在数据收集、存储、使用、分发、销毁全生命周期过程中的内容识别、分级分类、策略制定、过程监管、审结稽查，实现数据资产的有效管理和风险规避，并为各行业用户提供专业的安全咨询、风险评估、数据防护以及风险可视化服务。 目的基于数据挖掘出潜在的安全威胁快速感知风险并及时上报，结合部门其它安全防护服务以降低安全风险对用户或者企业业务和基础设施等上面的危害或减少对资源或者性能方面的损耗。对业务整体的安全状态有个清晰的感知, 后期进行运营快速拦截和处理。 市场产品解决方案分析需求：不影响业务，无脏数据，响应快，能快速识别风险并进行防御等数据生命周期: 根据收集、存储、使用、分发、销毁等流程来打造安全环境，构建安全设施和信任链旁路监控+权限控制：数据流量镜像分析，进行数据分析深度挖掘风险不断迭代更新策略和模型优点：缺点： 业务架构设计已写出，但暂不公开！！！ 技术架构设计已写出，但暂不公开！！！ 风险模型分析已写出，但有些暂不公开，主要懒,markdown格式建立表格麻烦！！！ 安全场景分析已写出，但暂不公开！！！ 数表设计已写出，但暂不公开！！！ 存储设计已写出，但暂不公开！！！ 功能排期已写出，但暂不公开！！！ 资源需求xx人，xx高配机器 态势感知 时间 规划 成果 备注 2018-01.9~02 v0.1设计阶段:架构，数据库，API设计;定义基础的收集数据对象[初步仅采集web数据，进行分析] 补充说明文档 ~ 2018-02~03 v0.1准备阶段:开发, 测试环境搭建v0.1开发阶段[包含前端，后端，agent]:自动WEB日志识别多类型WEB风险识别动态规则更新风险信息警报风险信息拦截 详见：测试的demo地址 ~ 2019-03~04 v0.1测试阶段:接入测试业务内网环境测试阶段 补充说明文档 ~ 2019-04-05 v0.1bug修复和优化阶段:修复测试出现的bug添加机器学习检测风险功能 补充说明文档 ~ todo 部署上线正式版本v1上线v0.1功能叠加和运营阶段:系统安全监控数据库安全监控加入用户中心安全监控根据当时安全产品或需求加入监控（蜜网等）提供各种API支持隐私功能接口特征统计安全产品联动 补充说明文档 ~ 架构设计 检测数据源格式[json]整个系统要做的就是： web日志[waf反响代理记录]: 通过反响代理镜像流量sql日志系统日志 web防护,如下： 1234567891011121314151617&#123; &quot;posts_all&quot;: &quot;&quot;, &quot;args_data&quot;: &quot;&quot;, &quot;request_uri&quot;: &quot;/sdf&lt;img sdf&gt;dsf&quot;, &quot;method&quot;: &quot;GET&quot;, &quot;referer&quot;: &quot;&quot;, &quot;headers&quot;: &#123;&#125;, &quot;remoteIp&quot;: &quot;192.168.1.1&quot;, &quot;time&quot;: &quot;2019-02-18 16:17:29&quot;, &quot;cookie&quot;: &quot;JSESSIONID=xxxx&quot;, &quot;uri&quot;: &quot;/sdf&lt;img sdf&gt;dsf&quot;, &quot;args&quot;: &#123;&#125;, &quot;http_host&quot;: &quot;xx&quot;, &quot;scheme&quot;: &quot;http&quot;, &quot;useragent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&quot;, &quot;query_string&quot;: &quot;&quot;&#125; 系统防护，如下:todo Spark简介应用主机入侵审计webshell检测数据库审计入侵检测数据分析隐私保护RASP身份证OCR生物特征识别人脸检测活体检测识别引擎实时运维 优点Spark最大的特点就是将计算数据、中间结果都存储在内存中，大大减少了IO开销，因而，Spark更适合于迭代运算比较多的数据挖掘与机器学习运算。 a.运行速度快：Spark使用先进的DAG（Directed Acyclic Graph，有向无环图）执行引擎，以支持循环数据流与内存计算，基于内存的执行速度可比Hadoop MapReduce快上百倍，基于磁盘的执行速度也能快十倍；b.容易使用：Spark支持使用Scala、Java、Python和R语言进行编程，简洁的API设计有助于用户轻松构建并行程序，并且可以通过Spark Shell进行交互式编程；c.通用性：Spark提供了完整而强大的技术栈，包括SQL查询、流式计算、机器学习和图算法组件，这些组件可以无缝整合在同一个应用中，足以应对复杂的计算；d.运行模式多样：Spark可运行于独立的集群模式中，或者运行于Hadoop中，也可运行于Amazon EC2等云环境中，并且可以访问HDFS、Cassandra、HBase、Hive等多种数据源。 优点：高数据处理速度天然的动态性Spark中的内存计算可重用性容错实时流处理懒惰评估支持多种语言：Java，R，Scala，Python支持复杂的分析与Hadoop集成Spark GraphX 支持图形和图形并行计算成本效益 缺点不支持实时处理小文件问题没有文件管理系统成本非常昂贵算法的数量较少手动优化迭代处理延迟 处理主要包括以下三个类型： 复杂的批量数据处理：时间跨度通常在数十分钟到数小时之间；基于历史数据的交互式查询：时间跨度通常在数十秒到数分钟之间；基于实时数据流的数据处理：时间跨度通常在数百毫秒到数秒之间。目前已有很多相对成熟的开源软件用于处理以上三种情景，比如，可以利用Hadoop MapReduce来进行批量数据处理，可以用Impala来进行交互式查询（Impala与Hive相似，但底层引擎不同，提供了实时交互式SQL查询），对于流式数据处理可以采用开源流计算框架Storm。 访问和接口 Spark Streaming: Spark Streaming支持高吞吐量、可容错处理的实时流数据处理，其核心思路是将流式计算分解成一系列短小的批处理作业。Spark Streaming支持多种数据输入源，如Kafka、Flume和TCP套接字等；BlinkDB: 暂不介绍。Spark SQL: 允许开发人员直接处理RDD，同时也可查询Hive、HBase等外部数据源。Spark SQL的一个重要特点是其能够统一处理关系表和RDD，使得开发人员可以轻松地使用SQL命令进行查询，并进行更复杂的数据分析；GraphX: Spark中用于图计算的API，可认为是Pregel在Spark上的重写及优化，Graphx性能良好，拥有丰富的功能和运算符，能在海量数据上自如地运行复杂的图算法。MlBase: 暂不介绍。vMLlib: 提供常用机器学习算法的实现，包括聚类、分类、回归、协同过滤等，降低了机器学习的门槛，开发人员只要具备一定的理论知识就能进行机器学习的工作；Spark Core: Spark的基本功能，如内存计算、任务调度、部署模式、故障恢复、存储管理等;Spark建立在统一的抽象RDD之上。存储：HDFS, S3资源管理调度：Mesos, Hadoop YARN 运行架构 Application: 基于Spark的用户程序，包含了一个driver program和集群中多个的excutor；Driver: 运行application的main函数并且创建SparkContent，通常用SparkContext代表Driver Program；RDD：是弹性分布式数据集（Resilient Distributed Dataset）的简称，是分布式内存的一个抽象概念，提供了一种高度受限的共享内存模型；DAG：是Directed Acyclic Graph（有向无环图）的简称，反映RDD之间的依赖关系；Executor：是运行在工作节点（Worker Node）上的一个进程，负责运行任务，并为应用程序存储数据；Spark所采用的Executor有两个优点：一是利用多线程来执行具体的任务（Hadoop MapReduce采用的是进程模型），减少任务的启动开销；二是Executor中有一个BlockManager存储模块，会将内存和磁盘共同作为存储设备，当需要多轮迭代计算时，可以将中间结果存储到这个存储模块里，下次需要时，就可以直接读该存储模块里的数据，而不需要读写到HDFS等文件系统里，因而有效减少了IO开销；或者在交互式查询场景下，预先将表缓存到该存储系统上，从而可以提高读写IO性能。应用：用户编写的Spark应用程序；一个应用（Application）由一个任务控制节点（Driver）和若干个作业（Job）构成，一个作业由多个阶段（Stage）构成，一个阶段由多个任务（Task）组成。当执行一个应用时，任务控制节点会向集群管理器（Cluster Manager）申请资源，启动Executor，并向Executor发送应用程序代码和文件，然后在Executor上执行任务，运行结束后，执行结果会返回给任务控制节点，或者写到HDFS或者其他数据库中。任务：运行在Executor上的工作单元；作业：一个作业包含多个RDD及作用于相应RDD上的各种操作；阶段：是作业的基本调度单位，一个作业会分为多组任务，每组任务被称为“阶段”，或者也被称为“任务集”。 行业使用场景 金融业：它有助于访问和分析银行部门的许多参数，例如电子邮件，社交媒体档案，通话录音，论坛等等电子商务行业： 有助于获得有关实时交易的信息。而且，这些被传递给流聚类算法。媒体和娱乐业：从实时的游戏事件中，识别模式旅游业：可以帮助用户通过加快个性化建议来规划一次完美的旅程 机器学习特征数据维度恶意数据判断的维度，分类可以根据训练和测试的样本进行分类，生成model 123456789101112131415&#123; &quot;1&quot; : &quot;(\s)|(\t)|(\r\n)|(\n)|(%20)&quot;, &quot;2&quot; : &quot;[&lt;&gt;\&apos;\&quot;()/~`|\?\+\*\^\$\\\.&#123;&#125;\[\]!@#%&amp;_-]&quot;, &quot;3&quot; : &quot;(#) | (\&apos;\&apos;\&apos;) | (\&quot;\&quot;\&quot;) | (\/\/) | (%00) | (\/\*).*(\*\/) | (--) | (--\+) | (--a) | (\/!\*).*(\*\/)&quot;, &quot;4&quot; : &quot;(alert)|(script=)|(eval)|(src=)|(prompt)|(onerror)|(onload)|(onfocus)|(onmouseover)|(string.fromcharcode)|(document.cookie)|(iframe)|(href)|(javascript)|(data)&quot;, &quot;5&quot; : &quot;(whoami) | (id)&quot;, &quot;6&quot; : &quot;\d+&quot;,&#125;pattern = re.compile(r&quot;(\s)|(\t)|(\r\n)|(\n)&quot;, re.M|re.I) # 空格，制表符，换行符 [需要包含&lt;font color=&quot;#660000&quot;&gt;编码数据, 待自己添加&lt;/font&gt;]pattern2 = re.compile(r&quot;[&lt;&gt;\&apos;\&quot;()/~`|\?\+\*\^\$\\\.&#123;&#125;\[\]!@#%&amp;_-]&quot;, re.M|re.I) # 特殊字符 ,;=[正常]pattern3 = re.compile(r&quot;(#) | (\&apos;\&apos;\&apos;) | (\&quot;\&quot;\&quot;) | (\/\/) | (%00) | (\/\*).*(\*\/) | (--) | (--\+) | (--a) | (\/!\*).*(\*\/) &quot;, re.M|re.I) # 注释pattern4 = re.compile(r&quot;(alert)|(script=)|(eval)|(src=)|(prompt)|(onerror)|(onload)|(onfocus)|(onmouseover)|(string.fromcharcode)|(document.cookie)|(iframe)|(href)|(javascript)|(data)&quot;, re.M|re.I) # 函数pattern5 = re.compile(r&quot;(whoami) | (id) &quot;, re.M|re.I) # 命令pattern6 = re.compile(r&quot;\d+&quot;, re.M|re.I) # 数字 扩展黑白名单，ip，手机号，设备指纹等；从细颗粒到粗颗粒，依次执行1和2，将所有黑白名单遍历扩展维度信息，比如手机号地域运营商，ip地域运营商，ip出口类型，设备指纹，Referer，ua，密码hash，征信等，维度越多，可以建立规则越多，风控越精准；扩展风控规则，针对需要解决的场景问题，添加特定规则，分值也应根据自身场景来调整。阈值预警将用户的行为轨迹综合考虑，建立复合场景的规则条件。比如：登录-&gt;活动-&gt;订单-&gt;支付，将事件关联分析综合考虑；保存事件减少漏报和误报。当然，这将是个漫长的过程 参数抽取 —用于规则检测对http请求数据进行拆解，提取如下参数，这部分的难点在于如何正确的识别编码方式并解码：Ø GET、POST、Cookie请求参数Ø GET、POST、Cookie参数名本身Ø 请求的URL路径Ø http请求头，如Content_type、Content-Length(对应strust2-045) 参数泛化 —用于机器检测/训练需要将参数值泛化为规律性的观测经验，并取字符的unicode数值作为观察序列，泛化的方法如下：Ø 大小写英文字母泛化为”A”，对应的unicode数值为65Ø 数字泛化为”N”，对应的unicode数值为78Ø 中文或中文字符泛化为“C”，对应的unicode数值为67Ø 特殊字符和其他字符集的编码不作泛化，直接取unicode数值Ø 参数值为空的取0 样例简单抽取定义表，如下:access_ip, access_time, access_url, access_status, user_agent – weblog 简单告警定义表，如下：SRC_IP,DST_IP,LEVEL,TYPE,DETAIL192.168.1,192.168.6,high,php_injection, 恶意信息192.168.1,192.168.6,middle,xss_injection, 恶意信息192.168.1,192.168.6,low,sql_injection, 恶意信息 配置开发环境下载压缩包第一步是选择适当版本的压缩包，可以到官网进行下载。截至到2018年2月，Spark最新版本是2.3.0版本。然后下载压缩包到自己的目录下就好。 配置环境下载压缩包的时候，来配置一下环境。先看看官方文档，里面有句关于环境依赖的说明: Spark runs on Java 8+, Python 2.7+/3.4+ and R 3.1+. For the Scala API, Spark 2.3.0 uses Scala 2.11. You will need to use a compatible Scala version (2.11.x).Note that support for Java 7, Python 2.6 and old Hadoop versions before 2.6.5 were removed as of Spark 2.2.0. Support for Scala 2.10 was removed as of 2.3.0.也就是说，Spark 2.3.0 的其他语言版本要求是： 2.11.x的Scala，Java 8+，Python 2.7+或者3.1+， R 要3.1+。根据自己常用开发语言安装即可。 参考如下：使用IDEA安装Scala(https://docs.scala-lang.org/getting-started-intellij-track/getting-started-with-scala-in-intellij.html) 使用sbt在命令行安装(https://docs.scala-lang.org/getting-started-sbt-track/getting-started-with-scala-and-sbt-on-the-command-line.html) 设置环境变量1tar xzf spark-2.3.0-bin-hadoop2.7.tgz Spark需要两个环境变量： JAVA_HOME 和 SPARK_HOME在ubuntu下，直接编辑用户目录下的 .bashrc即可： 12export JAVA_HOME=&lt;path-to-the-root-of-your-Java-installation&gt; (eg: /usr/lib/jvm/java-7-oracle/)export SPARK_HOME=&lt;path-to-the-root-of-your-spark-installation&gt; (eg: /path/spark/in/spark-1.6.1-bin-hadoop2.6/) 检验是否成功进入到解压目录下，执行 1./bin/spark-shell 即可进入spark命令行界面。然后也可以打开 http://localhost:4040 ，通过web UI查看任务情况。 配置开发环境我自己使用的是IDEA， 所以介绍一下IDEA中如何创建Spark项目。 安装IDEA这一步网上很多教程，可以自己搜一下。 创建项目在初始页面，点击 Create New Project ，或者在已经打开的项目的左上角点击File -&gt; New -&gt; Project ，可以看到以下画面： 选择 Scala -&gt; SBT ， 然点击 Next。 (SBT 是一个互动式的编译工具，详细了解看到 官网 查看。)然后给自己的项目取个名字，接着再根据自己Spark版本，选择合适的Java、Scala版本，最后点击 Finish 即可。 配置项目这一步介绍怎么引入Spark的依赖。进入项目后，点击左上角 File -&gt; Project Structure.点击 Libraries ，然后点 绿色的加号。这时出现了三个选项： Java， Maven， Scala SDk。 如果你选择maven方式添加spark，可以参考这里，来获取 对于的maven链接。形如：org.apache.spark:spark-core_2.11:2.3.1 (下载版本2.11为scala版本，2.3.1是spark版本;在运行spark-shell可查看) 当然，如果你已经下载好了Spark的压缩包，并且已经解压了，那就可以用引入Jar包的方式引入Spark，只要选择spark解压目录下名为jars的目录就OK了。注意添加library时，要添加给两个默认的module。 Hello World1）创建包在对应 src/main/scala 目录下，创建自己的包：org.apache.spark.examples。 2 ）创建Scala文件然后选中这个包下，右键点击 New ，选择 Scala Class。 然后取名为：PiTest， kind记得选为 Object。 代码附上如下： 123456789101112131415161718192021package org.apache.spark.examplesimport org.apache.spark.sql.SparkSessionimport scala.math.randomobject PiTest &#123; def main(args: Array[String]) &#123; val spark = SparkSession .builder .appName(&quot;Spark Pi&quot;) .getOrCreate() val slices = if (args.length &gt; 0) args(0).toInt else 2 val n = math.min(100000L * slices, Int.MaxValue).toInt // avoid overflow val count = spark.sparkContext.parallelize(1 until n, slices).map &#123; i =&gt; val x = random * 2 - 1 val y = random * 2 - 1 if (x * x + y * y &lt;= 1) 1 else 0 &#125;.reduce(_ + _) println(s&quot;Pi is roughly $&#123;4.0 * count / (n - 1)&#125;&quot;) spark.stop() &#125;&#125; 配置VM参数别急着运行，spark在运行的时候，会去读取一个环境变量，叫做“spark.master”。 传递给spark的master url可以有如下几种： 12345678local 本地单线程local[K] 本地多线程（指定K个内核）local[*] 本地多线程（指定所有可用内核）spark://HOST:PORT 连接到指定的 Spark standalone cluster master，需要指定端口。mesos://HOST:PORT 连接到指定的 Mesos 集群，需要指定端口。yarn-client客户端模式 连接到 YARN 集群。需要配置 HADOOP_CONF_DIR。yarn-cluster集群模式 连接到 YARN 集群。需要配置 HADOOP_CONF_DIR。我们在本地运行，就可以选为local模式。 点击Run -&gt; Edit Configuration，在 VM Options 中添加变量。或者直接在代码中指定： 12345val spark = SparkSession .builder .config(&quot;spark.master&quot;, &quot;local&quot;) .appName(&quot;Spark Pi&quot;) .getOrCreate() 运行最后，右键选择 Run PiTest ，然后就可以看到输出了。部分日志如下： 12345678910111218/12/27 17:05:33 INFO DAGScheduler: ResultStage 0 (reduce at PiTest.scala:22) finished in 0.514 s18/12/27 17:05:33 INFO DAGScheduler: Job 0 finished: reduce at PiTest.scala:22, took 1.573511 sPi is roughly 3.144575722878614418/12/27 17:05:33 INFO SparkUI: Stopped Spark web UI at http://192.168.99.1:404018/12/27 17:05:33 INFO MapOutputTrackerMasterEndpoint: MapOutputTrackerMasterEndpoint stopped!18/12/27 17:05:33 INFO MemoryStore: MemoryStore cleared18/12/27 17:05:33 INFO BlockManager: BlockManager stopped18/12/27 17:05:33 INFO BlockManagerMaster: BlockManagerMaster stopped18/12/27 17:05:33 INFO OutputCommitCoordinator$OutputCommitCoordinatorEndpoint: OutputCommitCoordinator stopped!18/12/27 17:05:33 INFO SparkContext: Successfully stopped SparkContext18/12/27 17:05:33 INFO ShutdownHookManager: Shutdown hook called18/12/27 17:05:33 INFO ShutdownHookManager: Deleting directory C:\Users\amazi\AppData\Local\Temp\spark-b0eadbe9-19c3-43fe-ac58-7c6bb0662438 参考http://dblab.xmu.edu.cn/blog/spark/https://waltyou.github.io/Spark-Install/https://waltyou.github.io/Spark-Tuning-Practice/http://wuchong.me/blog/2015/04/04/spark-on-yarn-cluster-deploy/https://dongkelun.com/2018/05/17/sparkKafka/https://aiyanbo.gitbooks.io/spark-programming-guide-zh-cn/content/spark-sql/data-sources/parquet-files.html]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>ml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[project-代码审计]]></title>
    <url>%2F2018%2F12%2F26%2Fproject-%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[0x01 时间规划 时间 规划 成果 备注 ~ ~ ~ ~ 0x02 相关介绍converityconverity 流程： 完成。converity 规则： 可以通过命令的访问指定自定义规则进行扫描； 具体编写规则的文档，可在converity的doc目录下找到。 实施：1.SDL加入代码审核的流程研究，出个可行实施方案，具体功能点和风险点，具体相关人员的工作。2.通知相关人员，统一邮件达成共识，确定其可行性。3.完成以后邮件和联系每个人确定最终方案和具体相关人员的工作和交付物，时间节点。4.最终文档归类。 0x03 架构分析Gerrit+Jenkins+Converity[v0.1] 0x04 安装和使用待更新 参考–规则https://bbs.huaweicloud.com/blogs/9a2708f3ce5b11e7b8317ca23e93a891https://blog.lixiaohei.cn/articles/2018/10/09/1539070489208.htmlhttps://www.huaweicloud.com/s/Jee7j-WFuOW3peWFt-mAhuWQkeWIhuaekCU/t_60?timeRange=0]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>CodeAudit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-rsa]]></title>
    <url>%2F2018%2F12%2F23%2Fjava-rsa%2F</url>
    <content type="text"><![CDATA[0x01 背景介绍一般信息安全注重三个点！安全性和完整性，可靠性。 针对这几个点：目前用的比较的安全方式就是加密，签名。 如：各大公司采用的证书就是基于这几种方式。本次主要简单讲解rsa。 0x02 RSA介绍RSA是一种非对称密钥。被广泛用来做签名和加密。 ras长度有1024, 2048 … 0x03 RSA使用1.利用程序直接生成 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180package com.test.tools;import sun.misc.BASE64Decoder;import java.math.BigInteger;import java.security.*;import java.security.interfaces.RSAPublicKey;import java.security.spec.PKCS8EncodedKeySpec;import java.security.spec.RSAPublicKeySpec;import java.security.spec.X509EncodedKeySpec;import java.util.Base64;import javax.crypto.Cipher;/** * 非对称加密RSA * @author bing */public class RSAUtils &#123; /** * 公钥加密 * @param content * @param publicKey * @return * @throws Exception */ public static String encrypt(String data, PublicKey publicKey) throws Exception &#123; Cipher cipher = Cipher.getInstance("RSA"); cipher.init(Cipher.ENCRYPT_MODE, publicKey); //加密的数据必须为字节 return Base64.getEncoder().encodeToString(cipher.doFinal(data.getBytes())); &#125; /** * 私钥解密 * @param content * @param privateKey * @return * @throws Exception */ public static String decrypt(String data, PrivateKey privateKey) throws Exception &#123; byte[] bytes = Base64.getDecoder().decode(data); Cipher cipher = Cipher.getInstance("RSA"); cipher.init(Cipher.DECRYPT_MODE, privateKey); return new String(cipher.doFinal(bytes)); &#125; /** * 签名 * @param data * @param privateKey * @return * @throws Exception * @throws Exception */ public static String sign(String content, byte[] privateKeyBytes) throws Exception &#123; //单例获取key工厂类，将拿到的privateKeyBytes创建PKCS8EncodedKeySpec对象，通过其获取PrivateKey对象 KeyFactory keyFactory = KeyFactory.getInstance("RSA"); // 用key工厂对象生成私钥 PrivateKey priKey = keyFactory.generatePrivate(new PKCS8EncodedKeySpec(privateKeyBytes)); //获取Signature对象，签名算法为SHA1WithRSA，此处还有较多可选择比如MD2withRSA/MD5withRSA/SHA1withRSA/SHA256withRSA等 Signature signature = Signature.getInstance("SHA1WithRSA"); //初始化签名 signature.initSign(priKey); //签名的数据必须为字节 signature.update(content.getBytes()); byte[] encodeResult = signature.sign(); return Base64.getEncoder().encodeToString(encodeResult); &#125; /** * 验证 * @param data * @param sign * @param publicKey * @return * @throws Exception */ public static boolean verify(String content, String sign, byte[] publicKeyBytes) throws Exception &#123; byte[] bytes = Base64.getDecoder().decode(sign); //单例获取key工厂类，将拿到的publicKey创建X509EncodedKeySpec对象，通过其获取PublicKey对象 KeyFactory keyFactory = KeyFactory.getInstance("RSA"); PublicKey pubKey = keyFactory.generatePublic(new X509EncodedKeySpec(publicKeyBytes)); //获取Signature对象，签名算法为SHA1WithRSA，此处还有较多可选择比如MD2withRSA/MD5withRSA/SHA1withRSA/SHA256withRSA等 Signature signature = Signature.getInstance("SHA1WithRSA"); signature.initVerify(pubKey); signature.update( content.getBytes() ); boolean bverify = signature.verify( bytes ); return bverify; &#125; /** * 生成密钥对 * @return * @throws Exception */ public static KeyPair genKeyPair() throws Exception &#123; KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA"); keyPairGenerator.initialize(1024); return keyPairGenerator.generateKeyPair(); &#125; /** * base64 to 公钥 * @param key 密钥字符串 to publickey * @throws Exception */ public static PublicKey getPublicKey(String key) throws Exception &#123; byte[] keyBytes; keyBytes = (new BASE64Decoder()).decodeBuffer(key); X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance("RSA"); PublicKey publicKey = keyFactory.generatePublic(keySpec); return publicKey; &#125; public static void main(String[] args) throws Exception &#123; String data = "this is a securet message dfgsgdfgfgdfg"; KeyPair keyPair = genKeyPair(); PublicKey publicKey = keyPair.getPublic(); PrivateKey privateKey = keyPair.getPrivate(); byte[] publicKeyBytes = publicKey.getEncoded(); byte[] privateKeyBytes = privateKey.getEncoded(); // 打印rsa公私密钥的modulus和exponent RSAPublicKey publicKeyT = (RSAPublicKey) keyPair.getPublic(); System.out.println("测试公钥 modulus：" + publicKeyT.getModulus().toString(16) ); //BigInteger to 16进制 System.out.println("测试公钥 format:" + publicKeyT.getFormat()); BigInteger modulus = publicKeyT.getModulus() ; BigInteger publicExponent = publicKeyT.getPublicExponent(); KeyFactory keyFactory = KeyFactory.getInstance("RSA"); RSAPublicKeySpec rsaPublicKeySpec = new RSAPublicKeySpec(modulus,publicExponent); PublicKey publicKeyT2 = keyFactory.generatePublic(rsaPublicKeySpec); byte[] test = publicKeyT2.getEncoded(); System.out.println("测试公钥：" + Base64.getEncoder().encodeToString( test ) ); // 测试公钥转换modulus和exponent String t2 = "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAu+Aq3Pa7PFYG047xTEAcFmvgFt65FAtmFMMkgL3Gl6K+3tIviClRUlKNr5W1wvJNrzB8Z2/YD9Qebc1crmAxU4CcxRNUlSBfnlKMRTqNeB9RY1tcD0TxGU6RFC3BHKudWghF0vk9U8zCG20ax9ZtncqlzNB4GthuF2haVzJhAeGYwshcK+kdyilKfuv9AfmrOgQ9HVMIPEmlWL/rE4kfvYbBLhCI1M/PZvlHXVQKHdevJiz5+0CBjpBuOkMYyK84Vl8rieS1iL6tBcCZtzVoFoMalNePwLjk4UWY2yxwNA6k655ePijRlr1jEk1RvauCcrGFt22sfP27roMRAlA+JQIDAQAB"; RSAPublicKey t3 = (RSAPublicKey) getPublicKey(t2); System.out.println("自定义公钥 modulus：" + t3.getModulus().toString(16) ); //BigInteger to 16进制 System.out.println("长度：" + t3.getModulus().toString(2).length() ); // 获取公，私钥，并以base64格式打印出来// System.out.println("公钥：" + Base64.getEncoder().encodeToString( publicKeyBytes ) );// System.out.println("私钥：" + Base64.getEncoder().encodeToString( privateKeyBytes ) ); // 公钥加密 System.out.println( "公钥的长度：" + publicKeyBytes.length ); String encryptedString = encrypt(data, publicKey); System.out.println("加密数据：" + encryptedString); System.out.println("加密数据长度: " + encryptedString.length() ); // 私钥解密 System.out.println( "私钥的长度：" + privateKeyBytes.length ); String decryptedString = decrypt(encryptedString, privateKey); System.out.println("解密数据：" + decryptedString); // 私钥签名 String sign = sign(data, privateKeyBytes); System.out.println("签名：" + sign); System.out.println("签名后的数据长度：" + sign.length() ); // 公钥验签 boolean flag = verify(data, sign, publicKeyBytes); System.out.println("验证：" + flag); &#125;/*** RSA 1024最大加密明文大小 :117 - 128*/&#125; 2.利用openssl命令直接生成 12345OpenSSL中RSA私钥文件生成命令为：openssl genrsa -out private_rsa.pem 2048生成RSA公钥命令为：openssl rsa -in private_rsa.pem -pubout -out public_rsa.pem 3.单片机一般16进制数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707116进制密钥生成命令:openssl rsa -in phone_rsa_private_key.pem -text -out private.txt使用命令,可得到如下几个部分:RSAPrivateKey ::= SEQUENCE &#123; version Version, //版本 modulus INTEGER, -- n //模 publicExponent INTEGER, -- e //公钥指数 privateExponent INTEGER, -- d //私钥指数 prime1 INTEGER, -- p prime2 INTEGER, -- q exponent1 INTEGER, -- d mod (p-1) exponent2 INTEGER, -- d mod (q-1) coefficient INTEGER, -- (inverse of q) mod p otherPrimeInfos OtherPrimeInfos OPTIONAL &#125;公钥语法为：(n, e)私钥语法为：(n, d)获取密钥的模和指数：# /usr/bin/python# encoding: utf-8import base64def str2key(s): # 对字符串解码 b_str = base64.b64decode(s) if len(b_str) &lt; 162: return False hex_str = &apos;&apos; # 按位转换成16进制 for x in b_str: h = hex(ord(x))[2:] h = h.rjust(2, &apos;0&apos;) hex_str += h # 找到模数和指数的开头结束位置 m_start = 29 * 2 e_start = 159 * 2 m_len = 128 * 2 e_len = 3 * 2 modulus = hex_str[m_start:m_start + m_len] exponent = hex_str[e_start:e_start + e_len] return modulus,exponentif __name__ == &quot;__main__&quot;: pubkey = &quot;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDC7kw8r6tq43pwApYvkJ5laljaN9BZb21TAIfT/vexbobzH7Q8SUdP5uDPXEBKzOjx2L28y7Xs1d9v3tdPfKI2LR7PAzWBmDMn8riHrDDNpUpJnlAGUqJG9ooPn8j7YNpcxCa1iybOlc2kEhmJn5uwoanQq+CA6agNkqly2H4j6wIDAQAB&quot; key = str2key(pubkey) print key使用密钥的模和指数，生成公钥及加密import rsamessage = &apos;test&apos;modulus = int(key[0], 16)exponent = int(key[1], 16)rsa_pubkey = rsa.PublicKey(modulus, exponent)crypto = rsa.encrypt(message, rsa_pubkey)b64str = base64.b64encode(crypto)print b64str第二种直接把数据的模和指数计算出来，进行格式转换。 0x04 AES加解密123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package test;import java.security.Key;import java.security.SecureRandom;import java.util.Base64;import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import javax.crypto.spec.SecretKeySpec;public class DemoAESUtil &#123; /** * 加密 * @param str * @param key * @return * @throws Exception */ public static String encrypt(String str, String key) throws Exception &#123; Cipher cipher = Cipher.getInstance(&quot;AES&quot;); cipher.init(Cipher.ENCRYPT_MODE, generateKey(key)); byte[] bytes = cipher.doFinal(str.getBytes()); return Base64.getEncoder().encodeToString(bytes); &#125; /** * 解密 * @param str * @param key * @return * @throws Exception */ public static String decrypt(String str, String key) throws Exception &#123; byte[] bytes = Base64.getDecoder().decode(str); Cipher cipher = Cipher.getInstance(&quot;AES&quot;); cipher.init(Cipher.DECRYPT_MODE, generateKey(key)); return new String(cipher.doFinal(bytes)); &#125; /** * 生成key * @param key * @return * @throws Exception */ private static Key generateKey(String key) throws Exception &#123; KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;AES&quot;); keyGenerator.init(128, new SecureRandom(key.getBytes())); // 密钥长度 128/192/256 return new SecretKeySpec(keyGenerator.generateKey().getEncoded(), &quot;AES&quot;); &#125; public static void main(String[] args) throws Exception &#123; String str = &quot;hello world&quot;; String key = &quot;password&quot;; // 加密 String encryptedString = encrypt(str, key); System.out.println(&quot;加密后：&quot; + encryptedString); // 解密 String decryptedString = decrypt(encryptedString, key); System.out.println(&quot;解密后：&quot; + new String(decryptedString)); &#125; &#125; 0x05 其它编码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240package utils;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.serializer.SerializerFeature;import java.util.Base64;public class XstormEncode &#123; // unicode转中文 public static String unicodeToString(String s) &#123; String[] split = s.split("\\\\"); StringBuilder builder = new StringBuilder(); for (int i = 0; i &lt; split.length ; i++) &#123; if (split[i].startsWith("u"))&#123; builder.append((char) Integer.parseInt(split[i].substring(1,5), 16)); if(split[i].length()&gt;5)&#123; builder.append(split[i].substring(5)); &#125; &#125;else &#123; builder.append(split[i]); &#125; &#125; return builder.toString(); &#125; // 中文字符转unicode public static String stringToUnicode(String unicode) &#123; char[] chars = unicode.toCharArray(); StringBuilder builder = new StringBuilder(); for (int i = 0; i &lt; chars.length ; i++) &#123; if (chars[i]&gt;= 0 &amp;&amp; chars[i]&lt;=127)&#123; builder.append(chars[i]); &#125;else &#123; builder.append("\\u"); String hx = Integer.toString(chars[i], 16); if (hx.length()&lt;4)&#123; builder.append("0000".substring(hx.length())).append(hx); &#125;else &#123; builder.append(hx); &#125; &#125; &#125;// return builder.toString(); // 方式2 return JSON.toJSONString(unicode, SerializerFeature.BrowserCompatible); &#125; // 字符转base64 public static String bs64Encode(String str) &#123; return Base64.getEncoder().encodeToString( str.getBytes()); &#125; // base64转字符 public static String bs64Decode(String str) &#123; byte[] bytes = Base64.getDecoder().decode( str ); return new String(bytes); &#125; // 获取类型方法 public String getType(Object o) &#123; return o.getClass().toString(); //使用Object类型的getClass()方法 &#125; /** * @Title:bytes2HexString * @Description:字节数组转16进制字符串 * @param b * 字节数组 * @return 16进制字符串 * @throws */ public static String bytes2HexString(byte[] b) &#123; StringBuffer result = new StringBuffer(); for (int i = 0; i &lt; b.length; i++) &#123; result.append(String.format("%02X",b[i])); &#125; return result.toString(); &#125; /** * @Title:hexString2Bytes * @Description:16进制字符串转字节数组 * @param src * 16进制字符串 * @return 字节数组 * @throws */ public static byte[] hexString2Bytes(String src) &#123; int l = src.length() / 2; byte[] ret = new byte[l]; for (int i = 0; i &lt; l; i++) &#123; ret[i] = Integer.valueOf(src.substring(i * 2, i * 2 + 2), 16).byteValue(); &#125; return ret; &#125; /** * @Title:string2HexUTF8 * @Description:字符UTF8串转16进制字符串 * @param strPart * 字符串 * @return 16进制字符串 * @throws */ public static String string2HexUTF8(String strPart) &#123; return string2HexString(strPart,"UTF-8"); &#125; /** * @Title:string2HexUTF8 * @Description:字符UTF-16LE串转16进制字符串,此UTF-16LE等同于C#中的Unicode * @param strPart * 字符串 * @return 16进制字符串 * @throws */ public static String string2HexUTF16LE(String strPart) &#123; return string2HexString(strPart,"UTF-16LE"); &#125; /** * @Title:string2HexUnicode * @Description:字符Unicode串转16进制字符串 * @param strPart * 字符串 * @return 16进制字符串 * @throws */ public static String string2HexUnicode(String strPart) &#123; return string2HexString(strPart,"Unicode"); &#125; /** * @Title:string2HexGBK * @Description:字符GBK串转16进制字符串 * @param strPart * 字符串 * @return 16进制字符串 * @throws */ public static String string2HexGBK(String strPart) &#123; return string2HexString(strPart,"GBK"); &#125; /** * @Title:string2HexString * @Description:字符串转16进制字符串 * @param strPart 字符串 * @param tochartype hex目标编码 * @return 16进制字符串 * @throws */ public static String string2HexString(String strPart,String tochartype) &#123; try&#123; return bytes2HexString(strPart.getBytes(tochartype)); &#125;catch (Exception e)&#123; return ""; &#125; &#125; /////////////////////////////////////////////////// ///////////////////////////////////////////////// /** * @Title:hexUTF82String * @Description:16进制UTF-8字符串转字符串 * @param src * 16进制字符串 * @return 字节数组 * @throws */ public static String hexUTF82String(String src) &#123; return hexString2String(src,"UTF-8","UTF-8"); &#125; /** * @Title:hexUTF16LE2String * @Description:16进制UTF-8字符串转字符串，,此UTF-16LE等同于C#中的Unicode * @param src * 16进制字符串 * @return 字节数组 * @throws */ public static String hexUTF16LE2String(String src) &#123; return hexString2String(src,"UTF-16LE","UTF-8"); &#125; /** * @Title:hexGBK2String * @Description:16进制GBK字符串转字符串 * @param src * 16进制字符串 * @return 字节数组 * @throws */ public static String hexGBK2String(String src) &#123; return hexString2String(src,"GBK","UTF-8"); &#125; /** * @Title:hexUnicode2String * @Description:16进制Unicode字符串转字符串 * @param src * 16进制字符串 * @return 字节数组 * @throws */ public static String hexUnicode2String(String src) &#123; return hexString2String(src,"Unicode","UTF-8"); &#125; /** * @Title:hexString2String * @Description:16进制字符串转字符串 * @param src * 16进制字符串 * @return 字节数组 * @throws */ public static String hexString2String(String src,String oldchartype, String chartype) &#123; byte[] bts=hexString2Bytes(src); try&#123;if(oldchartype.equals(chartype)) return new String(bts,oldchartype); else return new String(new String(bts,oldchartype).getBytes(),chartype); &#125; catch (Exception e)&#123; return""; &#125; &#125;&#125; 参考https://github.com/ghyg525/util_java_safehttps://tools.ietf.org/html/rfc5246 –sslhttp://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[env-git使用]]></title>
    <url>%2F2018%2F12%2F20%2Fenv-git%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[0x01 新建分支12$ git checkout -b test remotes/origin/test 在origin/master的基础上，创建一个新分支:newBrach$ git merge origin/master 表示在当前分支上，合并origin/master 0x02 代码提交的一般过程12345git fetch origingit add filesgit commit -a -m &quot;msg&quot;git push origin HEAD:refs/for/branchrefs/for/master是对应远程master的临时分支，作代码review使用，当review通过以后，提交的改动会合并至master分支。 0x03 对服务器上有新代码，本地分支已经滞后情况的处理12345678执行git rebase remote解决冲突：git rebase --continue方式二：git rebase origin/master #查看有“CONFLICT (content): ”的地方，手工解决冲突后，下一步git add dev/controller/web/index.php #这只是一个举例，即要先add操作git rebase --continue 0x04 审核不通过的处理12git commit --amend在本地修改代码，改完后执行git add -A添加所有修改，然后执行git commit --amend, 在弹出的编辑窗口中，不要修改之前的change-id，其它信息也可保持不变，直接保存，退出。这里使用git commit --amend而不使用git commit -m的原因，就是要保持同一个change-id，这样在gerrit的审核界面中，还是同一个review界面，不会产生新的，只是增加了一个新的patch set 2 0x05 代码审核权限管理123456审核权限有两种+1和+2 。+1权限表示同意代码提交，+2权限表示同意代码提交并赋予提交资格（界面上会多出一个submit按钮）如果有多个人同时+1了，但是没有被+2，代码仍然无法提交。而只要被+2了，不管是否有+1，代码都可以提交。git config --global alias.st statusgit config --global alias.co checkoutgit config --global alias.ct commitgit config --global alias.df diffgit config --global alias.br branch 0x06 问题解决BUG：多次提交，未上传出现多个commit的解决方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859601,查看提交历史，git log首先你要知道自己想合并的是哪几个提交，可以使用git log命令来查看提交历史，假如最近4条历史如下：commit 3ca6ec340edc66df13423f36f52919dfa3......commit 1b4056686d1b494a5c86757f9eaed844......commit 53f244ac8730d33b353bee3b24210b07......commit 3a4226b4a0b6fa68783b07f1cee7b688.......历史记录是按照时间排序的，时间近的排在前面。2,git rebase想要合并1-3条，有两个方法1.从HEAD版本开始往过去数3个版本git rebase -i HEAD~32.指名要合并的版本之前的版本号git rebase -i 3a4226b请注意3a4226b这个版本是不参与合并的，可以把它当做一个坐标3,选取要合并的提交1.执行了rebase命令之后，会弹出一个窗口，头几行如下：pick 3ca6ec3 &apos;注释**********&apos;pick 1b40566 &apos;注释*********&apos;pick 53f244a &apos;注释**********&apos;2.将pick改为squash或者s,之后保存并关闭文本编辑窗口即可。改完之后文本内容如下：s 3ca6ec3 &apos;注释**********&apos;s 1b40566 &apos;注释*********&apos;s 53f244a &apos;注释**********&apos;3.然后保存退出，Git会压缩提交历史，如果有冲突，需要修改，修改的时候要注意，保留最新的历史，不然我们的修改就丢弃了。修改以后要记得敲下面的命令：git add . git rebase --continue如果你想放弃这次压缩的话，执行以下命令：git rebase --abort4.如果没有冲突，或者冲突已经解决，则会出现如下的编辑窗口：# This is a combination of 4 commits. #The first commit’s message is: 注释......# The 2nd commit’s message is: 注释......# The 3rd commit’s message is: 注释......# Please enter the commit message for your changes. Lines starting # with ‘#’ will be ignored, and an empty message aborts the commit.5.输入wq保存并推出, 再次输入git log查看 commit 历史信息，你会发现这两个 commit 已经合并了。 0x07 gitlab使用123456789101112131415161718192021222324252627常用命令:git branch -a #列出所有本地分支和远程分支git branch --track [branch] [remote-branch] #新建一个分支，与指定的远程分支建立追踪关系git checkout -b test #新建test并切换到test分支test为自己的分支git checkout testgit add *git commit -m &apos;跟新代码test&apos;git push origin testgit checkout mastergit pullgit merge testgit add *git commit -m &apos;合并主分支&apos;git pushgit checkout testgit pull origin master然后就可以直接开发了...忽略更新文件:git update-index --assume-unchanged application/config/database.php忽略本地修改:git fetch --allgit reset --hard origin/master]]></content>
      <categories>
        <category>misc</category>
      </categories>
      <tags>
        <tag>env</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-加解密]]></title>
    <url>%2F2018%2F11%2F06%2Fjava-%E5%8A%A0%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[0x01 RSA加解密和签名的应用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144package test;import java.security.*;//import java.security.KeyFactory;//import java.security.KeyPair;//import java.security.KeyPairGenerator;//import java.security.NoSuchAlgorithmException;//import java.security.PrivateKey;//import java.security.PublicKey;//import java.security.Signature;import java.security.spec.PKCS8EncodedKeySpec;import java.security.spec.X509EncodedKeySpec;import java.util.Base64;import javax.crypto.Cipher;/** * 非对称加密RSA * @author 0x00 */public class RSAUtils &#123; /** * 公钥加密 * @param content * @param publicKey * @return * @throws Exception */ public static String encrypt(String data, PublicKey publicKey) throws Exception &#123; Cipher cipher = Cipher.getInstance(&quot;RSA&quot;); cipher.init(Cipher.ENCRYPT_MODE, publicKey); //加密的数据必须为字节 return Base64.getEncoder().encodeToString(cipher.doFinal(data.getBytes())); &#125; /** * 私钥解密 * @param content * @param privateKey * @return * @throws Exception */ public static String decrypt(String data, PrivateKey privateKey) throws Exception &#123; byte[] bytes = Base64.getDecoder().decode(data); Cipher cipher = Cipher.getInstance(&quot;RSA&quot;); cipher.init(Cipher.DECRYPT_MODE, privateKey); return new String(cipher.doFinal(bytes)); &#125; /** * 签名 * @param data * @param privateKey * @return * @throws Exception * @throws Exception */ public static String sign(String content, byte[] privateKeyBytes) throws Exception &#123; //单例获取key工厂类，将拿到的privateKeyBytes创建PKCS8EncodedKeySpec对象，通过其获取PrivateKey对象 KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;); // 用key工厂对象生成私钥 PrivateKey priKey = keyFactory.generatePrivate(new PKCS8EncodedKeySpec(privateKeyBytes)); //获取Signature对象，签名算法为SHA1WithRSA，此处还有较多可选择比如MD2withRSA/MD5withRSA/SHA1withRSA/SHA256withRSA等 Signature signature = Signature.getInstance(&quot;SHA1WithRSA&quot;); //初始化签名 signature.initSign(priKey); //签名的数据必须为字节 signature.update(content.getBytes()); byte[] encodeResult = signature.sign(); return Base64.getEncoder().encodeToString(encodeResult); &#125; /** * 验证 * @param data * @param sign * @param publicKey * @return * @throws Exception */ public static boolean verify(String content, String sign, byte[] publicKeyBytes) throws Exception &#123; byte[] bytes = Base64.getDecoder().decode(sign); //单例获取key工厂类，将拿到的publicKey创建X509EncodedKeySpec对象，通过其获取PublicKey对象 KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;); PublicKey pubKey = keyFactory.generatePublic(new X509EncodedKeySpec(publicKeyBytes)); //获取Signature对象，签名算法为SHA1WithRSA，此处还有较多可选择比如MD2withRSA/MD5withRSA/SHA1withRSA/SHA256withRSA等 Signature signature = Signature.getInstance(&quot;SHA1WithRSA&quot;); signature.initVerify(pubKey); signature.update( content.getBytes() ); boolean bverify = signature.verify( bytes ); return bverify; &#125; /** * 生成密钥对 * @return * @throws Exception */ public static KeyPair genKeyPair() throws Exception &#123; KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(&quot;RSA&quot;); keyPairGenerator.initialize(1024); return keyPairGenerator.generateKeyPair(); &#125; public static void main(String[] args) throws Exception &#123; String data = &quot;this is a securet message dfgsgdfgfgdfg&quot;; KeyPair keyPair = genKeyPair(); PublicKey publicKey = keyPair.getPublic(); PrivateKey privateKey = keyPair.getPrivate(); byte[] publicKeyBytes = publicKey.getEncoded(); byte[] privateKeyBytes = privateKey.getEncoded(); // 获取公，私钥，并以base64格式打印出来// System.out.println(&quot;公钥：&quot; + Base64.getEncoder().encodeToString( publicKeyBytes ) );// System.out.println(&quot;私钥：&quot; + Base64.getEncoder().encodeToString( privateKeyBytes ) ); // 公钥加密 String encryptedString = encrypt(data, publicKey); System.out.println(&quot;加密后：&quot; + encryptedString); System.out.println(&quot;加密后的数据长度: &quot; + encryptedString.length() ); // 私钥解密 String decryptedString = decrypt(encryptedString, privateKey); System.out.println(&quot;解密后：&quot; + decryptedString); // 私钥签名 String sign = sign(data, privateKeyBytes); System.out.println(&quot;签名：&quot; + sign); System.out.println(&quot;签名后的数据长度：&quot; + sign.length() ); // 公钥验签 boolean flag = verify(data, sign, publicKeyBytes); System.out.println(&quot;验证：&quot; + flag); &#125; &#125; 0x02 AES加解密123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package test;import java.security.Key;import java.security.SecureRandom;import java.util.Base64;import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import javax.crypto.spec.SecretKeySpec;public class DemoAESUtil &#123; /** * 加密 * @param str * @param key * @return * @throws Exception */ public static String encrypt(String str, String key) throws Exception &#123; Cipher cipher = Cipher.getInstance(&quot;AES&quot;); cipher.init(Cipher.ENCRYPT_MODE, generateKey(key)); byte[] bytes = cipher.doFinal(str.getBytes()); return Base64.getEncoder().encodeToString(bytes); &#125; /** * 解密 * @param str * @param key * @return * @throws Exception */ public static String decrypt(String str, String key) throws Exception &#123; byte[] bytes = Base64.getDecoder().decode(str); Cipher cipher = Cipher.getInstance(&quot;AES&quot;); cipher.init(Cipher.DECRYPT_MODE, generateKey(key)); return new String(cipher.doFinal(bytes)); &#125; /** * 生成key * @param key * @return * @throws Exception */ private static Key generateKey(String key) throws Exception &#123; KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;AES&quot;); keyGenerator.init(128, new SecureRandom(key.getBytes())); // 密钥长度 128/192/256 return new SecretKeySpec(keyGenerator.generateKey().getEncoded(), &quot;AES&quot;); &#125; public static void main(String[] args) throws Exception &#123; String str = &quot;hello world&quot;; String key = &quot;password&quot;; // 加密 String encryptedString = encrypt(str, key); System.out.println(&quot;加密后：&quot; + encryptedString); // 解密 String decryptedString = decrypt(encryptedString, key); System.out.println(&quot;解密后：&quot; + new String(decryptedString)); &#125; &#125; 参考https://github.com/ghyg525/util_java_safehttps://tools.ietf.org/html/rfc5246 –ssl]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-正则和基础类]]></title>
    <url>%2F2018%2F10%2F28%2Fjava-%E6%AD%A3%E5%88%99%E5%92%8C%E5%9F%BA%E7%A1%80%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[0x01 字符类* [abc] a、b 或 c（简单类） * [^abc] 任何字符，除了 a、b 或 c（否定） * [a-zA-Z] a到 z 或 A到 Z，两头的字母包括在内（范围） * [0-9] 0到9的字符都包括0x02 预定义字符类* . 任何字符。 * \d 数字：[0-9] * \w 单词字符：[a-zA-Z_0-9]0x03 Greedy 数量词* X? X，一次或一次也没有 * X* X，零次或多次 * X+ X，一次或多次 * X{n} X，恰好 n 次 * X{n,} X，至少 n 次 * X{n,m} X，至少 n 次，但是不超过 m 次0x04 Math类概述Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。成员方法 * public static int abs(int a) * public static double ceil(double a) * public static double floor(double a) * public static int max(int a,int b) min自学 * public static double pow(double a,double b) * public static double random() * public static int round(float a) 参数为double的自学 * public static double sqrt(double a) 0x05 Pattern和Matcher的概述模式和匹配器的典型调用顺序 * 典型的调用顺序是 * Pattern p = Pattern.compile(“a*b”); * Matcher m = p.matcher(“aaaaab”); * boolean b = m.matches();System.currentTimeMillis() //获取当前毫秒值 0x06 BigInteger的概述可以让超过Integer范围内的数据进行运算构造方法 * public BigInteger(String val) 成员方法 * public BigInteger add(BigInteger val) * public BigInteger subtract(BigInteger val) * public BigInteger multiply(BigInteger val) * public BigInteger divide(BigInteger val) * public BigInteger[] divideAndRemainder(BigInteger val) 0x06 BigDecimal的概述* 由于在运算的时候，float类型和double很容易丢失精度，演示案例。 * 所以，为了能精确的表示、计算浮点数，Java提供了BigDecimal * 不可变的、任意精度的有符号十进制数。构造方法 * public BigDecimal(String val) 成员方法 * public BigDecimal add(BigDecimal augend) * public BigDecimal subtract(BigDecimal subtrahend) * public BigDecimal multiply(BigDecimal multiplicand) * public BigDecimal divide(BigDecimal divisor) 0x07 Date类的概述类 Date 表示特定的瞬间，精确到毫秒。构造方法 * public Date() * public Date(long date) 成员方法 * public long getTime() * public void setTime(long time) 0x08 DateFormat类的概述* DateFormat 是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。是抽象类，所以使用其子类SimpleDateFormat0x09 SimpleDateFormat构造方法* public SimpleDateFormat() * public SimpleDateFormat(String pattern)成员方法 * public final String format(Date date) * public Date parse(String source) 0x0a Calendar类的概述* Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。成员方法 * public static Calendar getInstance() * public int get(int field) * public void add(int field,int amount) * public final void set(int year,int month,int date)]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-对象]]></title>
    <url>%2F2018%2F10%2F28%2Fjava-%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[0x01 面向对象面向对象思想特点* a:是一种更符合我们思想习惯的思想 * b:可以将复杂的事情简单化 * c:将我们从执行者变成了指挥者 * 角色发生了转换面向对象开发* 就是不断的创建对象，使用对象，指挥对象做事情。面向对象设计* 其实就是在管理和维护对象之间的关系。面向对象特征* 封装(encapsulation) * 继承(inheritance) * 多态(polymorphism)0x02 编程我们学习编程是为了什么* 为了把我们日常生活中实物用学习语言描述出来我们如何描述现实世界事物* 属性 就是该事物的描述信息(事物身上的名词) * 行为 就是该事物能够做什么(事物身上的动词)Java中最基本的单位是类,Java中用class描述事物也是如此* 成员变量 就是事物的属性 * 成员方法 就是事物的行为定义类其实就是定义类的成员(成员变量和成员方法)* a:成员变量 和以前定义变量是一样的，只不过位置发生了改变。在类中，方法外。 * b:成员方法 和以前定义方法是一样的，只不过把static去掉，后面在详细讲解static的作用。类和对象的概念* a:类：是一组相关的属性和行为的集合 * b:对象：是该类事物的具体体现 * c:举例： * 类 学生 * 对象 具体的某个学生就是一个对象学生事物例子* 学生类 * 案例演示 * 属性:姓名,年龄,性别 * 行为:学习,睡觉0x03 java类在类中的位置不同* 成员变量：在类中方法外 * 局部变量：在方法定义中或者方法声明上在内存中的位置不同* 成员变量：在堆内存(成员变量属于对象,对象进堆内存) * 局部变量：在栈内存(局部变量属于方法,方法进栈内存)生命周期不同* 成员变量：随着对象的创建而存在，随着对象的消失而消失 * 局部变量：随着方法的调用而存在，随着方法的调用完毕而消失初始化值不同* 成员变量：有默认初始化值 * 局部变量：没有默认初始化值，必须定义，赋值，然后才能使用。注意事项：* 局部变量名称可以和成员变量名称一样，在方法中使用的时候，采用的是就近原则。 * 基本数据类型变量包括哪些:byte,short,int,long,float,double,boolean,char * 引用数据类型变量包括哪些:数组,类,接口,枚举; 参数传递的是：地址值 如：[I@23sd23d * 如: 方法的参数是类名12public void print(Student s)&#123;&#125;//print(new Student());* 如果你看到了一个方法的形式参数是一个类类型(引用类型)，这里其实需要的是该类的对象。 匿名对象应用场景123Car c = new Car(); 创建对象c.run();new Car().run(); 匿名对象 * a:调用方法，仅仅只调用一次的时候。 * 那么，这种匿名调用有什么好处吗? * 节省代码 * 注意：调用多次的时候，不适合。匿名对象调用完毕就是垃圾。可以被垃圾回收器回收。 * b:匿名对象可以作为实际参数传递封装概述* 是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。封装好处* 隐藏实现细节，提供公共的访问方式 * 提高了代码的复用性 * 提高安全性封装原则* 将不需要对外提供的内容都隐藏起来。 * 把属性隐藏，提供公共方法对其访问。private关键字特点* a:是一个权限修饰符 * b:可以修饰成员变量和成员方法 * c:被其修饰的成员只能在本类中被访问案例演示 * 封装和private的应用： * A:把成员变量用private修饰 * B:提供对应的getXxx()和setXxx()方法 * private仅仅是封装的一种体现形式,不能说封装就是私有 this关键字特点* 代表当前对象的引用 构造方法A:构造方法概述和作用 * 给对象的数据(属性)进行初始化； 构造方法：不能被调用，但是在创建的时候就会执行。B:构造方法格式特点 * a:方法名与类名相同(大小也要与类名一致) * b:没有返回值类型，连void都没有 * c:没有具体的返回值return; 画图说明一个对象的创建过程做了哪些事情? * Student s = new Student(); * 1,Student.class加载进内存 * 2,声明一个Student类型引用s * 3,在堆内存创建对象, * 4,给对象中属性默认初始化值 * 5,属性进行显示初始化 * 6,构造方法进栈,对对象中的属性赋值,构造方法弹栈 * 7,将对象的地址值赋值给s 1234567891011121314151617181920212223242526272829303132333435class Demo2_Person &#123; public static void main(String[] args) &#123; Person p1 = new Person(); p1.show(); System.out.println(&quot;---------------------&quot;); Person p2 = new Person(&quot;test&quot;,23); p2.show(); System.out.println(&quot;---------------------&quot;); Person p3 = new Person(&quot;test&quot;,24); p3.show(); &#125;&#125; class Person &#123; private String name; private int age; public Person() &#123; System.out.println(&quot;构造&quot;); &#125; public Person(String name,int age) &#123; this.name = name; this.age = age; System.out.println(&quot;重载的有参构造&quot;); //构造方法是将原对象类变成垃圾，在修改成员属性的时候不方便；getXxx(),setXxx() 灵活且方便,不用新建类; &#125; public void show() &#123; System.out.println(name + &quot;...&quot; + age); &#125;&#125; static关键字A:static关键字的特点 * a:随着类的加载而加载 * b:优先于对象存在 * c:被类的所有对象共享 * 举例：咱们班级的学生应该共用同一个班级编号。 * 其实这个特点也是在告诉我们什么时候使用静态? * 如果某个成员变量是被所有对象共享的，那么它就应该定义为静态的。 * 举例： * 饮水机(用静态修饰) * 水杯(不能用静态修饰) * 共性用静态,特性用非静态 * d:可以通过类名调用 * 其实它本身也可以通过对象名调用。 * 推荐使用类名调用。 * 静态修饰的内容一般我们称其为：与类相关的，类成员 A:static的注意事项 * a:在静态方法中是没有this关键字的 * 如何理解呢? * 静态是随着类的加载而加载，this是随着对象的创建而存在。 * 静态比对象先存在。 * b:静态方法只能访问静态的成员变量和静态的成员方法 * 静态方法： * 成员变量：只能访问静态变量 * 成员方法：只能访问静态成员方法 * 非静态方法： * 成员变量：可以是静态的，也可以是非静态的 * 成员方法：可是是静态的成员方法，也可以是非静态的成员方法。 * 简单记： * 静态只能访问静态。 变量静态变量也叫类变量,成员变量也叫对象变量A:所属不同 * 静态变量属于类，所以也称为为类变量 * 成员变量属于对象，所以也称为实例变量(对象变量)B:内存中位置不同 * 静态变量存储于方法区的静态区 * 成员变量存储于堆内存C:内存出现时间不同 * 静态变量随着类的加载而加载，随着类的消失而消失 * 成员变量随着对象的创建而存在，随着对象的消失而消失D:调用不同 * 静态变量可以通过类名调用，也可以通过对象调用 * 成员变量只能通过对 象名调用 代码块 A:代码块概述 在Java中，使用{}括起来的代码被称为代码块。 B:代码块分类 根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块(多线程讲解)。 C:常见代码块的应用 a:局部代码块 在方法中出现；限定变量生命周期，及早释放，提高内存利用率 b:构造代码块 (初始化块) 在类中方法外出现；多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行 c:静态代码块 在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，并且只执行一次。 一般用于加载驱动1234567891011121314151617181920212223242526class Student &#123; static &#123; System.out.println(&quot;Student 静态代码块&quot;); &#125; &#123; System.out.println(&quot;Student 构造代码块&quot;); &#125; public Student() &#123; System.out.println(&quot;Student 构造方法&quot;); &#125;&#125; class Demo2_Student &#123; static &#123; System.out.println(&quot;Demo2_Student静态代码块&quot;); &#125; public static void main(String[] args) &#123; System.out.println(&quot;我是main方法&quot;); Student s1 = new Student(); Student s2 = new Student(); &#125;&#125; 静态代码块优先于主方法执行，构造代码块优先于构造方法执行A:继承(extends) * 让类与类之间产生关系,子父类关系B:继承案例演示： * 动物类,猫类,狗类 * 定义两个属性(颜色,腿的个数)两个功能(吃饭，睡觉)A:继承的好处 * a:提高了代码的复用性 * b:提高了代码的维护性 * c:让类与类之间产生了关系，是多态的前提B:继承的弊端 * 类的耦合性增强了。 * 开发的原则：高内聚，低耦合。 * 耦合：类与类的关系 * 内聚：就是自己完成某件事情的能力A:Java中类的继承特点 * a:Java只支持单继承，不支持多继承。(一个儿子只能有一个爹) * 有些语言是支持多继承，格式：extends 类1,类2,… * b:Java支持多层继承(继承体系)A:继承的注意事项 * a:子类只能继承父类所有非私有的成员(成员方法和成员变量) * b:子类不能继承父类的构造方法，但是可以通过super关键字去访问父类构造方法。 * c:不要为了部分功能而去继承 * 项目经理 姓名 工号 工资 奖金 * 程序员 姓名 工号 工资A:this和super都代表什么 * this:代表当前对象的引用,谁来调用我,我就代表谁 * super:代表当前对象父类的引用B:this和super的使用区别 * a:调用成员变量 * this.成员变量 调用本类的成员变量,也可以调用父类的成员变量 * super.成员变量 调用父类的成员变量 * b:调用构造方法 * this(…) 调用本类的构造方法 * super(…) 调用父类的构造方法 * c:调用成员方法 * this.成员方法 调用本类的成员方法,也可以调用父类的方法 * super.成员方法 调用父类的成员方法A:案例演示 * 父类没有无参构造方法,子类怎么办? * super解决 * this解决B:注意事项 * super(…)或者this(….)必须出现在构造方法的第一条语句上 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 class Fu&#123; public int num = 10; public Fu()&#123; System.out.println(&quot;fu&quot;); &#125; &#125; class Zi extends Fu&#123; public int num = 20; public Zi()&#123; System.out.println(&quot;zi&quot;); &#125; public void show()&#123; int num = 30; System.out.println(num); System.out.println(this.num); System.out.println(super.num); &#125; &#125; class Test1_Extends &#123; public static void main(String[] args) &#123; Zi z = new Zi(); z.show(); &#125; &#125; 看程序写结果2 class Fu &#123; static &#123; System.out.println(&quot;静态代码块Fu&quot;); &#125; &#123; System.out.println(&quot;构造代码块Fu&quot;); &#125; public Fu() &#123; System.out.println(&quot;构造方法Fu&quot;); &#125; &#125; class Zi extends Fu &#123; static &#123; System.out.println(&quot;静态代码块Zi&quot;); &#125; &#123; System.out.println(&quot;构造代码块Zi&quot;); &#125; public Zi() &#123; System.out.println(&quot;构造方法Zi&quot;); &#125; &#125; Zi z = new Zi(); 请执行结果。 方法重写A:什么是方法重写 * 重写:子父类出现了一模一样的方法(注意:返回值类型可以是子父类)B:方法重写的应用： * 当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法。这样，即沿袭了父类的功能，又定义了子类特有的内容。C:案例演示 * a:定义一个手机类。 A:方法重写注意事项 * a:父类中私有方法不能被重写 * 因为父类私有方法子类根本就无法继承 * b:子类重写父类方法时，访问权限不能更低 * 最好就一致 * c:父类静态方法，子类也必须通过静态方法进行重写 * 其实这个算不上方法重写，但是现象确实如此，至于为什么算不上方法重写，多态中我会讲解(静态只能覆盖静态) * 子类重写父类方法的时候，最好声明一模一样。 * Override和Overload的区别?Overload能改变返回值类型吗? * overload可以改变返回值类型,只看参数列表 * 方法重写：子类中出现了和父类中方法声明一模一样的方法。与返回值类型有关,返回值是一致(或者是子父类)的 * 方法重载：本类中出现的方法名一样，参数列表不同的方法。与返回值类型无关。 * 子类对象调用方法的时候： * 先找子类本身，再找父类。A:final概述B:final修饰特点 * 修饰类，类不能被继承 * 修饰变量，变量就变成了常量，只能被赋值一次 * 修饰方法，方法不能被重写 * 基本类型，是值不能被改变 * 引用类型，是地址值不能被改变,对象中的属性可以改变C:案例演示 * final修饰特点A:final修饰变量的初始化时机 * 显示初始化 * 在对象构造完毕前即可 0x04 面向对象(main方法的格式详细解释)格式* public static void main(String[] args) {}针对格式的解释* public 被jvm调用，访问权限足够大。 * static 被jvm调用，不用创建对象，直接类名访问 * void被jvm调用，不需要给jvm返回值 * main 一个通用的名称，虽然不是关键字，但是被jvm识别 * String[] args 以前用于接收键盘录入的对工具类加入文档注释通过javadoc命令生成说明书 * @author(提取作者内容) * @version(提取版本内容) * javadoc -d 指定的文件目录 -author -version ArrayTool.java * @param 参数名称//形式参数的变量名称@return 函数运行完返回的数据 0x05 Math类A:Math类概述 * 类包含用于执行基本数学运算的方法B:Math类特点 * 由于Math类在java.lang包下，所以不需要导包。 * 因为它的成员全部是静态的,所以私有了构造方法C:获取随机数的方法 * public static double random():返回带正号的 double 值，该值大于等于 0.0 且小于 1.0。D:我要获取一个1-100之间的随机数，肿么办? * int number = (int)(Math.random()*100)+1;当一个类里面的方法都是static方法，可以private私有这个类的构造方法，防止其它类来使用创建类调用，直接使用类型.方法的调用即可。 0x06 多态多态概述 * 事物存在的多种形态 多态前提 * 要有继承关系 要有方法重写 要有父类引用指向子类对象 1234567891011121314151617181920212223242526272829303132333435363738 class Test&#123; public static void main(String[] args)&#123; Cat c = new Cat(); c.eat(); System.out.println(c.num); Animal a = new Cat(); //父类引用指向子类对象, 就是向上转型 a.eat(); //成员方法：编译看左边(父类), 运行看右边(子类)[也叫动态绑定] //静态方法：编译看左边, 运行看左边 System.out.println(a.num); //成员变量：编译看左边(父类), 运行看左边(父类) Cat sm = (Cat)a; //一定先有向上转型，才有这个向下转型 sm.test(); &#125; &#125; class Animal &#123; int num = 10; //成员变量 public void eat()&#123; System.out.println(&quot;动物吃饭&quot;); &#125; &#125; class Cat extends Animal &#123; int num = 20; public void eat() &#123; System.out.println(&quot;猫吃鱼&quot;); &#125; public void test() &#123; System.out.println(&quot;test&quot;); &#125; &#125; 结果： &quot;猫吃鱼&quot; 20 &quot;猫吃鱼&quot; 10 &quot;test&quot; 0x07 抽象和接口抽象类不能直接实列，可以通过子类进行示例(父类引用，指向子类对象)抽象类的子类，要不是抽象类，要不就直接重写抽象类中的所有方法 123456789101112131415161718192021222324252627abstract class test&#123; public abstract void eat() &#123; System.out.println(&quot;helloworld !!!&quot;); &#125;&#125;* abstract 不能和其它关键字并用： static , final , private* 接口的定义 interface 接口名 &#123;&#125;* 类实现接口用implements 表示 class 类名 implements 接口名 &#123;&#125;* 接口不能实列化： 可以通过多态来实例化* 接口成员特点 * 成员变量：只能是常量，并且是静态的并公共的 默认修饰符：public static final * 构造方法：接口没有构造方法 * 成员方法：只能是抽象方法 默认修饰符：pulic abstract* 类与类，类与接口，接口与接口的关系 * 类与类： 继承关系，只能但继承，可以多层继承 * 类与接口： 实现关系，可以单实现，也可以多实现 并且还可以再继承一个类的同时实现多个接口 * 接口与接口 继承关系，可以单继承，也可以多继承 0x08 面向对象(package关键字的概述及作用)A:为什么要有包 * 将字节码(.class)进行分类存放 * 包其实就是文件夹B:包的概述 * 举例： 学生：增加，删除，修改，查询 老师：增加，删除，修改，查询 方案1：按照功能分 com.heima.add AddStudent AddTeacher com.heima.delete DeleteStudent DeleteTeacher com.heima.update UpdateStudent UpdateTeacher com.heima.find FindStudent FindTeacher 方案2：按照模块分 com.heima.teacher AddTeacher DeleteTeacher UpdateTeacher FindTeacher com.heima.student AddStudent DeleteStudent UpdateStudent FindStudentA:定义包的格式 * package 包名; * 多级包用.分开即可B:定义包的注意事项 * A:package语句必须是程序的第一条可执行的代码 * B:package语句在一个java文件中只能有一个 * C:如果没有package，默认表示无包名A:如何编译运行带包的类 * a:javac编译的时候带上-d即可 * javac -d . HelloWorld.java * b:通过java命令执行。 * java 包名.HellWord * 不同包下类之间的访问： 先编译，在调用的时候需要加包名 A:为什么要有import * 其实就是让有包的类对调用者可见,不用写全类名了B:导包格式 * import 包名; * 注意： * 这种方式导入是到类的名称。 * 虽然可以最后写*，但是不建议。C:package,import,class有没有顺序关系 修饰符* 权限修饰符：private，默认的，protected，public * 状态修饰符：static，final * 抽象修饰符：abstract类* 权限修饰符：默认修饰符，public * 状态修饰符：final * 抽象修饰符：abstract * 用的最多的就是：public成员变量* 权限修饰符：private，默认的，protected，public * 状态修饰符：static，final * 用的最多的就是：private构造方法* 权限修饰符：private，默认的，protected，public * 用的最多的就是：public成员方法* 权限修饰符：private，默认的，protected，public * 状态修饰符：static，final * 抽象修饰符：abstract * 用的最多的就是：public除此以外的组合规则* 成员变量：public static final * 成员方法： * public static * public abstract * public final12345 本类 同一个包下(子类和无关类) 不同包下(子类) 不同包下(无关类)private Y 默认 Y Yprotected Y Y Ypublic Y Y Y Y 内部类访问特点* a:内部类可以直接访问外部类的成员，包括私有。 * b:外部类要访问内部类的成员，必须创建对象。 * 外部类名.内部类名 对象名 = 外部类对象.内部类对象;123456789101112131415161718 class Outer &#123; public int num = 10; class Inner &#123; public int num = 20; public void show() &#123; int num = 30; System.out.println(?); System.out.println(??); System.out.println(???); &#125; &#125; &#125; class InnerClassTest &#123; public static void main(String[] args) &#123; Outer.Inner oi = new Outer().new Inner(); oi.show(); &#125; &#125; * 局部内部类访问局部变量必须用final修饰 * 局部内部类在访问他所在方法中的局部变量必须用final修饰,为什么? 因为当调用这个方法时,局部变量如果没有用final修饰,他的生命周期和方法的生命周期是一样的,当方法弹栈,这个局部变量也会消失,那么如果局部内部类对象还没有马上消失想用这个局部变量,就没有了,如果用final修饰会在类加载的时候进入常量池,即使方法弹栈,常量池的常量还在,也可以继续使用。 但是jdk1.8取消了这个事情。A:匿名内部类 * 就是内部类的简化写法。B:前提：存在一个类或者接口 * 这里的类可以是具体类也可以是抽象类。C:格式： new 类名或者接口名(){ 重写方法; }D:本质是什么呢? 1234567891011121314151617181920 * 是一个继承了该类或者实现了该接口的子类匿名对象。 //这里写抽象类，接口都行 abstract class Person &#123; public abstract void show(); &#125; class PersonDemo &#123; public void method(Person p) &#123; p.show(); &#125; &#125; class PersonTest &#123; public static void main(String[] args) &#123; //如何调用PersonDemo中的method方法呢? PersonDemo pd = new PersonDemo (); &#125; &#125;]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-数组]]></title>
    <url>%2F2018%2F10%2F28%2Fjava-%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[0x01 数组A:为什么要有数组(容器)* 为了存储同种数据类型的多个值B:数组概念* 数组是存储同一种数据类型多个元素的集合。也可以看成是一个容器。 * 数组既可以存储基本数据类型，也可以存储引用数据类型。C:数组定义格式* 数据类型[] 数组名 = new 数据类型[数组的长度];0x02 数组的初始化动态初始化A:什么是数组的初始化* 就是为数组开辟连续的内存空间，并为每个数组元素赋予值 B:如何对数组进行初始化* a:动态初始化 只指定长度，由系统给出初始化值 * int[] arr = new int[5]; //整形数据，默认初始化为0，布尔型默认是false, 浮点型默认是0.0 * b:静态初始化 给出初始化值，由系统决定长度 C:动态初始化的格式：* 数据类型[] 数组名 = new 数据类型[数组长度];12345数组地址：[I@19bb25a [ 代表数组,几个就代表几维I 代表整形@ 固定19bb25a 代表16进制值的地址值 0x03 内存分配A:栈* 存储局部变量 * 方法在运行的时候会在栈中，运行完成会弹栈B:堆* 存储new出来的数组或对象 C:方法区* 代码默认保存在磁盘，一但运行编译成字节码后会加载到内存的方法区D:本地方法区* 和系统相关 E:寄存器* 给CPU使用数组遍历：就是依次输出数组中的每一个元素。 12345public static void print(int[] arr) &#123; for (int i = 0;i &lt; arr.length ;i++ ) &#123; System.out.print(arr[i] + &quot; &quot;); &#125;&#125; 数组的属性:arr.length数组的长度 数组的最大索引:arr.length - 1; 0x04 二维数组格式int[][] arr = new int[3][2];二维数组格式1的解释注意事项 * a:以下格式也可以表示二维数组 * 1:数据类型 数组名[][] = new 数据类型[m][n]; * 2:数据类型[] 数组名[] = new 数据类型[m][n]; * B:注意下面定义的区别 int x; int y; int x,y; int[] x; int[] y[]; int[] x,y[]; x是一维数组,y是二维数组二维数组遍历 * 外循环控制的是二维数组的长度，其实就是一维数组的个数。 * 内循环控制的是一维数组的长度。 int[][] arr = {{1,2,3},{4,5},{6,7,8,9}}; for (int i = 0;i &lt; arr.length ;i++ ) { //获取到每个二维数组中的一维数组 for (int j = 0;j &lt; arr[i].length ;j++ ) { //获取每个一维数组中的元素 System.out.print(arr[i][j] + &quot; &quot;); } System.out.println(); }]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[env-eclipse配置]]></title>
    <url>%2F2018%2F10%2F28%2Fenv-eclipse%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[0x01 程序的编译和运行的环境配置Eclipse是一个开发工具，可以通过安装各种插件进行各种语言的程序开发； * window – Preferences – Java 编译环境：Compiler 默认选中的就是最高版本。 运行环境：Installed JREs 默认会找你安装的那个JDK。建议配置了Java的环境变量。 问题： 低编译，高运行。可以。 高编译，低运行。不可以。 建议，编译和运行的版本一致。 如何去掉默认注释? * window – Preferences – Java – Code Style – Code Templates 选择你不想要的内容，通过右边Edit编辑。 注意：请只删除注释部分，不是注释部分的不要删除。 行号的显示和隐藏 * 显示：在代码区域的最左边的空白区域，右键 – Show Line Numbers即可。 隐藏：把上面的动作再做一次。 字体大小及颜色 * a:Java代码区域的字体大小和颜色： window – Preferences – General – Appearance – Colors And Fonts –Java修改 – Java Edit Text Font b:控制台 window – Preferences – General – Appearance – Colors And Fonts – Debug – Console font c:其他文件 window – Preferences – General – Appearance – Colors And Fonts – Basic – Text Font 窗体给弄乱了，怎么办? * window – Reset Perspective 控制台找不到了，怎么办? * Window–Show View—Console 取消悬浮提示 * window – Preferences – Java–Editor–Hovers。右边将Combined Hover勾去掉。 这样代码的悬浮框就不会自动出现了。如果想看提示，将光标悬浮在代码上，按F2即可。 0x02 程序的各种快捷键A:Alt+/ 起提示作用B:main+alt+/,syso+alt+/,给出其他提示C:补充输出语句,选中需要输出的部分,alt+/选择最后一项即可C:定义自己的alt + / windows–perference-Java-Editor-Templates–New A:新建 ctrl + nB:格式化 ctrl+shift+fC:导入包 ctrl+shift+oD:注释 ctrl+/,ctrl+shift+/,ctrl+shift+E:代码上下移动 选中代码alt+上/下箭头F:查看源码 选中类名(F3或者Ctrl+鼠标点击)G:查找具体的类 ctrl + shift + tH:查找具体类的具体方法 ctrl + oI:给建议 ctrl+1,根据右边生成左边的数据类型,生成方法J:删除代码 ctrl + dK:抽取方法alt + shift + mL:改名alt + shift + ralt + shift + sA:自动生成构造方法B:自动生成get/set方法 A:jar是什么? jar是多个class文件的压缩包。B:jar有什么用? 用别人写好的东西C:打jar包 选中项目–右键–Export–Java–Jar–自己指定一个路径和一个名称–FinishD:导入jar包 复制到项目路径下并添加至构建路径。 A:删除项目 选中项目 – 右键 – 删除 从项目区域中删除 从硬盘上删除B:导入项目 在项目区域右键找到import 找到General，展开，并找到 Existing Projects into Workspace 点击next,然后选择你要导入的项目 注意：这里选择的是项目名称 什么是断点： 就是一个标记，从哪里开始。 如何设置断点： 你想看哪里的程序，你就在那个有效程序的左边双击即可。 在哪里设置断点： 哪里不会点哪里。 目前：我们就在每个方法的第一条有效语句上都加。 如何运行设置断点后的程序： 右键 – Debug as – Java Application 看哪些地方： Debug：断点测试的地方 在这个地方，记住F6，或者点击也可以。一次看一行的执行过程。 Variables：查看程序的变量变化 ForDemo：被查看的源文件 Console：控制台 如何去断点： a:再次双击即可 b:找到Debug视图，Variables界面，找到Breakpoints，并点击，然后看到所有的断点，最后点击那个双叉。 ==是一个比较运算符号,既可以比较基本数据类型,也可以比较引用数据类型,基本数据类型比较的是值,引用数据类型比较的是地址值equals方法是一个方法,只能比较引用数据类型,所有的对象都会继承Object类中的方法,如果没有重写Object类中的equals方法,equals方法和==号比较引用数据类型无区别,重写后的equals方法比较的是对象中的属性]]></content>
      <categories>
        <category>misc</category>
      </categories>
      <tags>
        <tag>env</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-thread类]]></title>
    <url>%2F2018%2F10%2F28%2Fjava-thread%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[0x01 多线程(多线程的引入)1.什么是线程 * 线程是程序执行的一条路径, 一个进程中可以包含多条线程 * 多线程并发执行可以提高程序的效率, 可以同时完成多项工作2.多线程的应用场景 * 红蜘蛛同时共享屏幕给多个电脑 * 迅雷开启多条线程一起下载 * QQ同时和多个人一起视频 * 服务器同时处理多个客户端请求 0x02 多线程(多线程并行和并发的区别)并行就是两个任务同时运行，就是甲任务进行的同时，乙任务也在进行。(需要多核CPU)并发是指两个任务都请求运行，而处理器只能按受一个任务，就把这两个任务安排轮流进行，由于时间间隔较短，使人感觉两个任务都在运行。比如我跟两个网友聊天，左手操作一个电脑跟甲聊，同时右手用另一台电脑跟乙聊天，这就叫并行。如果用一台电脑我先给甲发个消息，然后立刻再给乙发消息，然后再跟甲聊，再跟乙聊。这就叫并发。 0x03 多线程(Java程序运行原理和JVM的启动是多线程的吗)Java程序运行原理 * Java命令会启动java虚拟机，启动JVM，等于启动了一个应用程序，也就是启动了一个进程。该进程会自动启动一个 “主线程” ，然后主线程去调用某个类的 main 方法。 JVM的启动是多线程的吗 * JVM启动至少启动了垃圾回收线程和主线程，所以是多线程的。 0x04 多线程(多线程程序实现的方式1)重载：重载的时候，方法名要一样，但是参数类型或个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。覆写（重写）：若子类中的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。1.继承Thread * 定义类继承Thread * 重写run方法 * 把新线程要做的事写在run方法中 * 创建线程对象 * 开启新线程, 内部会自动执行run方法 12345678910111213141516171819202122public class Demo2_Thread &#123; /** * @param args */ public static void main(String[] args) &#123; MyThread mt = new MyThread(); //4,创建自定义类的对象 mt.start(); //5,开启线程 for(int i = 0; i &lt; 3000; i++) &#123; System.out.println(&quot;bb&quot;); &#125; &#125;&#125;class MyThread extends Thread &#123; //1,定义类继承Thread public void run() &#123; //2,重写run方法 for(int i = 0; i &lt; 3000; i++) &#123; //3,将要执行的代码,写在run方法中 System.out.println(&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;); &#125; &#125;&#125; 2.实现Runnable * 定义类实现Runnable接口 * 实现run方法 * 把新线程要做的事写在run方法中 * 创建自定义的Runnable的子类对象 * 创建Thread对象, 传入Runnable * 调用start()开启新线程, 内部会自动调用Runnable的run()方法 12345678910111213141516171819202122232425public class Demo3_Runnable &#123; /** * @param args */ public static void main(String[] args) &#123; MyRunnable mr = new MyRunnable(); //4,创建自定义类对象 //Runnable target = new MyRunnable(); Thread t = new Thread(mr); //5,将其当作参数传递给Thread的构造函数 t.start(); //6,开启线程 for(int i = 0; i &lt; 3000; i++) &#123; System.out.println(&quot;bb&quot;); &#125; &#125;&#125;class MyRunnable implements Runnable &#123; //1,自定义类实现Runnable接口 @Override public void run() &#123; //2,重写run方法 for(int i = 0; i &lt; 3000; i++) &#123; //3,将要执行的代码,写在run方法中 System.out.println(&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;); &#125; &#125; &#125; 0x05 多线程(源码实现Runnable的原理)1,看Thread类的构造函数,传递了Runnable接口的引用2,通过init()方法找到传递的target给成员变量的target赋值3,查看run方法,发现run方法中有判断,如果target不为null就会调用Runnable接口子类对象的run方法 0x06 多线程(源码两种方式的区别)a.继承Thread : 由于子类重写了Thread类的run(), 当调用start()时, 直接找子类的run()方法b.实现Runnable : 构造函数中传入了Runnable的引用, 成员变量记住了它, start()调用run()方法时内部判断成员变量Runnable的引用是否为空, 不为空编译时看的是Runnable的run(),运行时执行的是子类的run()方法 继承Thread 好处是:可以直接使用Thread类中的方法,代码简单 弊端是:如果已经有了父类,就不能用这种方法 实现Runnable接口 好处是:即使自己定义的线程类有了父类也没关系,因为有了父类也可以实现接口,而且接口是可以多实现的 弊端是:不能直接使用Thread中的方法需要先获取到线程对象后,才能得到Thread的方法,代码复杂 0x07 多线程(匿名内部类实现线程的两种方式)继承Thread类 1234567new Thread() &#123; //1,new 类()&#123;&#125;继承这个类 public void run() &#123; //2,重写run方法 for(int i = 0; i &lt; 3000; i++) &#123; //3,将要执行的代码,写在run方法中 System.out.println(&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;); &#125; &#125;&#125;.start(); 实现Runnable接口 1234567new Thread(new Runnable()&#123; //1,new 接口()&#123;&#125;实现这个接口 public void run() &#123; //2,重写run方法 for(int i = 0; i &lt; 3000; i++) &#123; //3,将要执行的代码,写在run方法中 System.out.println(&quot;bb&quot;); &#125; &#125;&#125;).start(); 0x08 多线程(获取名字和设置名字)1.获取名字 * 通过getName()方法获取线程对象的名字2.设置名字 * 通过构造函数可以传入String类型的名字 1234567891011121314151617181920212223242526272829303132333435363738new Thread(&quot;xxx&quot;) &#123; public void run() &#123; for(int i = 0; i &lt; 1000; i++) &#123; System.out.println(this.getName() + &quot;....aaaaaaaaaaaaaaaaaaaaaaa&quot;); &#125; &#125;&#125;.start();new Thread(&quot;yyy&quot;) &#123; public void run() &#123; for(int i = 0; i &lt; 1000; i++) &#123; System.out.println(this.getName() + &quot;....bb&quot;); &#125; &#125;&#125;.start(); * 通过setName(String)方法可以设置线程对象的名字* Thread t1 = new Thread() &#123; public void run() &#123; for(int i = 0; i &lt; 1000; i++) &#123; System.out.println(this.getName() + &quot;....aaaaaaaaaaaaaaaaaaaaaaa&quot;); &#125; &#125;&#125;;Thread t2 = new Thread() &#123; public void run() &#123; for(int i = 0; i &lt; 1000; i++) &#123; System.out.println(this.getName() + &quot;....bb&quot;); &#125; &#125;&#125;;t1.setName(&quot;芙蓉姐姐&quot;);t2.setName(&quot;凤姐&quot;);t1.start();t2.start(); 0x09 多线程(获取当前线程的对象)Thread.currentThread(), 主线程也可以获取 12345678910111213141516new Thread(new Runnable() &#123; public void run() &#123; for(int i = 0; i &lt; 1000; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot;...aaaaaaaaaaaaaaaaaaaaa&quot;); &#125; &#125;&#125;).start();new Thread(new Runnable() &#123; public void run() &#123; for(int i = 0; i &lt; 1000; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot;...bb&quot;); &#125; &#125;&#125;).start();Thread.currentThread().setName(&quot;我是主线程&quot;); //获取主函数线程的引用,并改名字System.out.println(Thread.currentThread().getName()); //获取主函数线程的引用,并获取名字 0x0a 多线程(休眠线程)Thread.sleep(毫秒,纳秒), 控制当前线程休眠若干毫秒1秒= 1000毫秒 1秒 = 1000 * 1000 * 1000纳秒 1000000000 12345678910111213141516171819202122232425new Thread() &#123; public void run() &#123; for(int i = 0; i &lt; 10; i++) &#123; System.out.println(getName() + &quot;...aaaaaaaaaaaaaaaaaaaaaa&quot;); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;.start();new Thread() &#123; public void run() &#123; for(int i = 0; i &lt; 10; i++) &#123; System.out.println(getName() + &quot;...bb&quot;); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;.start(); 0x0b 多线程(守护线程)setDaemon(), 设置一个线程为守护线程, 该线程不会单独执行, 当其他非守护线程都执行结束后, 自动退出 123456789101112131415161718192021222324252627282930Thread t1 = new Thread() &#123; public void run() &#123; for(int i = 0; i &lt; 50; i++) &#123; System.out.println(getName() + &quot;...aaaaaaaaaaaaaaaaaaaaaa&quot;); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;;Thread t2 = new Thread() &#123; public void run() &#123; for(int i = 0; i &lt; 5; i++) &#123; System.out.println(getName() + &quot;...bb&quot;); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;;t1.setDaemon(true); //将t1设置为守护线程t1.start();t2.start(); 0x0c 多线程(加入线程)(掌握)join(), 当前线程暂停, 等待指定的线程执行结束后, 当前线程再继续join(int), 可以等待指定的毫秒之后继续 12345678910111213141516171819202122232425262728293031323334final Thread t1 = new Thread() &#123; public void run() &#123; for(int i = 0; i &lt; 50; i++) &#123; System.out.println(getName() + &quot;...aaaaaaaaaaaaaaaaaaaaaa&quot;); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;;Thread t2 = new Thread() &#123; public void run() &#123; for(int i = 0; i &lt; 50; i++) &#123; if(i == 2) &#123; try &#123; //t1.join(); //插队,加入 t1.join(30); //加入,有固定的时间,过了固定时间,继续交替执行 Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(getName() + &quot;...bb&quot;); &#125; &#125;&#125;;t1.start();t2.start(); yield让出cpu 12345678910111213141516171819202122public class Demo6_Yield &#123; /** * yield让出cpu礼让线程 */ public static void main(String[] args) &#123; new MyThread().start(); new MyThread().start(); &#125;&#125;class MyThread extends Thread &#123; public void run() &#123; for(int i = 1; i &lt;= 1000; i++) &#123; if(i % 10 == 0) &#123; Thread.yield(); //让出CPU &#125; System.out.println(getName() + &quot;...&quot; + i); &#125; &#125;&#125; setPriority()设置线程的优先级 123456789101112131415161718192021222324252627282930313233public class Demo7_Priority &#123; /** * @param args */ public static void main(String[] args) &#123; Thread t1 = new Thread()&#123; public void run() &#123; for(int i = 0; i &lt; 100; i++) &#123; System.out.println(getName() + &quot;...aaaaaaaaa&quot; ); &#125; &#125; &#125;; Thread t2 = new Thread()&#123; public void run() &#123; for(int i = 0; i &lt; 100; i++) &#123; System.out.println(getName() + &quot;...bb&quot; ); &#125; &#125; &#125;; //t1.setPriority(10); 设置最大优先级 //t2.setPriority(1); t1.setPriority(Thread.MIN_PRIORITY); //设置最小的线程优先级 t2.setPriority(Thread.MAX_PRIORITY); //设置最大的线程优先级 t1.start(); t2.start(); &#125;&#125; 0x0d 多线程(同步代码块)1.什么情况下需要同步 * 当多线程并发, 有多段代码同时执行时, 我们希望某一段代码执行的过程中CPU不要切换到其他线程工作. 这时就需要同步. * 如果两段代码是同步的, 那么同一时间只能执行一段, 在一段代码没执行结束之前, 不会执行另外一段代码.2.同步代码块 * 使用synchronized关键字加上一个锁对象来定义一段代码, 这就叫同步代码块 * 多个同步代码块如果使用相同的锁对象, 那么他们就是同步的 1234567891011121314151617181920212223class Printer &#123; Demo d = new Demo(); public static void print1() &#123; synchronized(d)&#123; //锁对象可以是任意对象,但是被锁的代码需要保证是同一把锁,不能用匿名对象 System.out.print(&quot;黑&quot;); System.out.print(&quot;马&quot;); System.out.print(&quot;程&quot;); System.out.print(&quot;序&quot;); System.out.print(&quot;员&quot;); System.out.print(&quot;\r\n&quot;); &#125; &#125; public static void print2() &#123; synchronized(d)&#123; System.out.print(&quot;传&quot;); System.out.print(&quot;智&quot;); System.out.print(&quot;播&quot;); System.out.print(&quot;客&quot;); System.out.print(&quot;\r\n&quot;); &#125; &#125;&#125; 0x0e 多线程(同步方法)使用synchronized关键字修饰一个方法, 该方法中所有的代码都是同步的 1234567891011121314151617181920212223class Printer &#123; public static void print1() &#123; synchronized(Printer.class)&#123; //锁对象可以是任意对象,但是被锁的代码需要保证是同一把锁,不能用匿名对象 System.out.print(&quot;黑&quot;); System.out.print(&quot;马&quot;); System.out.print(&quot;程&quot;); System.out.print(&quot;序&quot;); System.out.print(&quot;员&quot;); System.out.print(&quot;\r\n&quot;); &#125; &#125; /* * 非静态同步函数的锁是:this * 静态的同步函数的锁是:字节码对象 */ public static synchronized void print2() &#123; System.out.print(&quot;传&quot;); System.out.print(&quot;智&quot;); System.out.print(&quot;播&quot;); System.out.print(&quot;客&quot;); System.out.print(&quot;\r\n&quot;); &#125;&#125; 0x0f 多线程(线程安全问题)多线程并发操作同一数据时, 就有可能出现线程安全问题使用同步技术可以解决这种问题, 把操作数据的代码进行同步, 不要多个线程一起操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Demo2_Synchronized &#123; /** * @param args * 需求:铁路售票,一共100张,通过四个窗口卖完. */ public static void main(String[] args) &#123; TicketsSeller t1 = new TicketsSeller(); TicketsSeller t2 = new TicketsSeller(); TicketsSeller t3 = new TicketsSeller(); TicketsSeller t4 = new TicketsSeller(); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t4.setName(&quot;窗口4&quot;); t1.start(); t2.start(); t3.start(); t4.start(); &#125;&#125;class TicketsSeller extends Thread &#123; private static int tickets = 100; static Object obj = new Object(); public TicketsSeller() &#123; super(); &#125; public TicketsSeller(String name) &#123; super(name); &#125; public void run() &#123; while(true) &#123; synchronized(obj) &#123; if(tickets &lt;= 0) break; try &#123; Thread.sleep(10);//线程1睡,线程2睡,线程3睡,线程4睡 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(getName() + &quot;...这是第&quot; + tickets-- + &quot;号票&quot;); &#125; &#125; &#125;&#125; 0x11 多线程(火车站卖票的例子用实现Runnable接口)1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Demo4_Ticket &#123; /** * @param args * 火车站卖票的例子用实现Runnable接口 */ public static void main(String[] args) &#123; MyTicket mt = new MyTicket(); new Thread(mt).start(); new Thread(mt).start(); new Thread(mt).start(); new Thread(mt).start(); /* Thread t1 = new Thread(mt); //多次启动一个线程是非法的 t1.start(); t1.start(); t1.start(); t1.start(); */ &#125;&#125;class MyTicket implements Runnable &#123; private int tickets = 100; @Override public void run() &#123; while(true) &#123; synchronized(this) &#123; if(tickets &lt;= 0) &#123; break; &#125; try &#123; Thread.sleep(10); //线程1睡,线程2睡,线程3睡,线程4睡 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;...这是第&quot; + tickets-- + &quot;号票&quot;); &#125; &#125; &#125;&#125; 0x12 多线程(死锁)多线程同步的时候, 如果同步代码嵌套, 使用相同锁, 就有可能出现死锁 * 尽量不要嵌套使用 1234567891011121314151617181920212223242526272829private static String s1 = &quot;筷子左&quot;;private static String s2 = &quot;筷子右&quot;;public static void main(String[] args) &#123; new Thread() &#123; public void run() &#123; while(true) &#123; synchronized(s1) &#123; System.out.println(getName() + &quot;...拿到&quot; + s1 + &quot;等待&quot; + s2); synchronized(s2) &#123; System.out.println(getName() + &quot;...拿到&quot; + s2 + &quot;开吃&quot;); &#125; &#125; &#125; &#125; &#125;.start(); new Thread() &#123; public void run() &#123; while(true) &#123; synchronized(s2) &#123; System.out.println(getName() + &quot;...拿到&quot; + s2 + &quot;等待&quot; + s1); synchronized(s1) &#123; System.out.println(getName() + &quot;...拿到&quot; + s1 + &quot;开吃&quot;); &#125; &#125; &#125; &#125; &#125;.start();&#125; 0x13 多线程(以前的线程安全的类回顾)回顾以前说过的线程安全问题 * 看源码：Vector,StringBuffer,Hashtable,Collections.synchroinzed(xxx) * Vector是线程安全的,ArrayList是线程不安全的 * StringBuffer是线程安全的,StringBuilder是线程不安全的 * Hashtable是线程安全的,HashMap是线程不安全的 0x14 多线程(单例设计模式) 单例设计模式：保证类在内存中只有一个对象。 如何保证类在内存中只有一个对象呢？ (1)控制类的创建，不让其他类来创建本类的对象。private (2)在本类中定义一个本类的对象。Singleton s; (3)提供公共的访问方式。 public static Singleton getInstance(){return s} 单例写法两种： 12345678910111213141516171819202122232425262728293031323334353637383940414243* (1)饿汉式 开发用这种方式。 //饿汉式 class Singleton &#123; //1,私有构造函数 private Singleton()&#123;&#125; //2,创建本类对象 private static Singleton s = new Singleton(); //3,对外提供公共的访问方法 public static Singleton getInstance() &#123; return s; &#125; public static void print() &#123; System.out.println(&quot;11111111111&quot;); &#125; &#125;* (2)懒汉式 面试写这种方式。多线程的问题？* //懒汉式,单例的延迟加载模式 class Singleton &#123; //1,私有构造函数 private Singleton()&#123;&#125; //2,声明一个本类的引用 private static Singleton s; //3,对外提供公共的访问方法 public static Singleton getInstance() &#123; if(s == null) //线程1,线程2 s = new Singleton(); return s; &#125; public static void print() &#123; System.out.println(&quot;11111111111&quot;); &#125; &#125;* (3)第三种格式* class Singleton &#123; private Singleton() &#123;&#125; public static final Singleton s = new Singleton();//final是最终的意思,被final修饰的变量不可以被更改 &#125; 0x15 多线程(Runtime类) Runtime类是一个单例类123Runtime r = Runtime.getRuntime();//r.exec(&quot;shutdown -s -t 300&quot;); //300秒后关机r.exec(&quot;shutdown -a&quot;); //取消关机 0x16 多线程(Timer)Timer类:计时器 1234567891011121314151617181920212223public class Demo5_Timer &#123; /** * @param args * 计时器 * @throws InterruptedException */ public static void main(String[] args) throws InterruptedException &#123; Timer t = new Timer(); t.schedule(new MyTimerTask(), new Date(114,9,15,10,54,20),3000); while(true) &#123; System.out.println(new Date()); Thread.sleep(1000); &#125; &#125;&#125;class MyTimerTask extends TimerTask &#123; @Override public void run() &#123; System.out.println(&quot;起床背英语单词&quot;); &#125; &#125; 0x17 多线程(两个线程间的通信) 1.什么时候需要通信 多个线程并发执行时, 在默认情况下CPU是随机切换线程的 如果我们希望他们有规律的执行, 就可以使用通信, 例如每个线程执行一次打印 2.怎么通信 如果希望线程等待, 就调用wait() 如果希望唤醒等待的线程, 就调用notify(); 这两个方法必须在同步代码中执行, 并且使用同步锁对象来调用 0x18 多线程(三个或三个以上间的线程通信) 多个线程通信的问题 notify()方法是随机唤醒一个线程 notifyAll()方法是唤醒所有线程 JDK5之前无法唤醒指定的一个线程 如果多个线程之间通信, 需要使用notifyAll()通知所有线程, 用while来反复判断条件 0x19 多线程(JDK1.5的新特性互斥锁) 1.同步 使用ReentrantLock类的lock()和unlock()方法进行同步 2.通信 使用ReentrantLock类的newCondition()方法可以获取Condition对象 需要等待的时候使用Condition的await()方法, 唤醒的时候用signal()方法 不同的线程使用不同的Condition, 这样就能区分唤醒的时候找哪个线程了 0x1a 多线程(线程组的概述和使用) A:线程组概述 Java中使用ThreadGroup来表示线程组，它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。 默认情况下，所有的线程都属于主线程组。 public final ThreadGroup getThreadGroup()//通过线程对象获取他所属于的组 public final String getName()//通过线程组对象获取他组的名字 我们也可以给线程设置分组 1,ThreadGroup(String name) 创建线程组对象并给其赋值名字 2,创建线程对象 3,Thread(ThreadGroup?group, Runnable?target, String?name) 4,设置整组的优先级或者守护线程 B:案例演示 线程组的使用,默认是主线程组12345678910111213141516171819202122232425262728293031 MyRunnable mr = new MyRunnable(); Thread t1 = new Thread(mr, &quot;张三&quot;); Thread t2 = new Thread(mr, &quot;李四&quot;); //获取线程组 // 线程类里面的方法：public final ThreadGroup getThreadGroup() ThreadGroup tg1 = t1.getThreadGroup(); ThreadGroup tg2 = t2.getThreadGroup(); // 线程组里面的方法：public final String getName() String name1 = tg1.getName(); String name2 = tg2.getName(); System.out.println(name1); System.out.println(name2); // 通过结果我们知道了：线程默认情况下属于main线程组 // 通过下面的测试，你应该能够看到，默任情况下，所有的线程都属于同一个组 System.out.println(Thread.currentThread().getThreadGroup().getName()); * 自己设定线程组* // ThreadGroup(String name) ThreadGroup tg = new ThreadGroup(&quot;这是一个新的组&quot;); MyRunnable mr = new MyRunnable(); // Thread(ThreadGroup group, Runnable target, String name) Thread t1 = new Thread(tg, mr, &quot;张三&quot;); Thread t2 = new Thread(tg, mr, &quot;李四&quot;); System.out.println(t1.getThreadGroup().getName()); System.out.println(t2.getThreadGroup().getName()); //通过组名称设置后台线程，表示该组的线程都是后台线程 tg.setDaemon(true); 0x1b 多线程(线程的五种状态) 看图说话 新建,就绪,运行,阻塞,死亡 0x1c 多线程(线程池的概述和使用) A:线程池概述 程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。在JDK5之前，我们必须手动实现自己的线程池，从JDK5开始，Java内置支持线程池 B:内置线程池的使用概述 JDK5新增了一个Executors工厂类来产生线程池，有如下几个方法 public static ExecutorService newFixedThreadPool(int nThreads) public static ExecutorService newSingleThreadExecutor() 这些方法的返回值是ExecutorService对象，该对象表示一个线程池，可以执行Runnable对象或者Callable对象代表的线程。它提供了如下方法 Future&lt;?&gt; submit(Runnable task) Future submit(Callable task) 使用步骤： 创建线程池对象 创建Runnable实例 提交Runnable实例 关闭线程池 C:案例演示 提交的是Runnable12345678910111213// public static ExecutorService newFixedThreadPool(int nThreads)ExecutorService pool = Executors.newFixedThreadPool(2);// 可以执行Runnable对象或者Callable对象代表的线程pool.submit(new MyRunnable());pool.submit(new MyRunnable());//结束线程池pool.shutdown();``` ## 0x1d 多线程(多线程程序实现的方式3)* 提交的是Callable // 创建线程池对象ExecutorService pool = Executors.newFixedThreadPool(2); // 可以执行Runnable对象或者Callable对象代表的线程Future f1 = pool.submit(new MyCallable(100));Future f2 = pool.submit(new MyCallable(200)); // V get()Integer i1 = f1.get();Integer i2 = f2.get(); System.out.println(i1);System.out.println(i2); // 结束pool.shutdown(); public class MyCallable implements Callable { private int number; public MyCallable(int number) { this.number = number; } @Override public Integer call() throws Exception { int sum = 0; for (int x = 1; x &lt;= number; x++) { sum += x; } return sum; }} 12345678910111213141516171819202122多线程程序实现的方式3的好处和弊端 * 好处： * 可以有返回值 * 可以抛出异常 * 弊端： * 代码比较复杂，所以一般不用## 0x1e 设计模式(简单工厂模式概述和使用)* A:简单工厂模式概述 * 又叫静态工厂方法模式，它定义一个具体的工厂类负责创建一些类的实例* B:优点 * 客户端不需要在负责对象的创建，从而明确了各个类的职责* C:缺点 * 这个静态工厂类负责所有对象的创建，如果有新的对象增加，或者某些对象的创建方式不同，就需要不断的修改工厂类，不利于后期的维护* D:案例演示 * 动物抽象类：public abstract Animal &#123; public abstract void eat(); &#125; * 具体狗类：public class Dog extends Animal &#123;&#125; * 具体猫类：public class Cat extends Animal &#123;&#125; * 开始，在测试类中每个具体的内容自己创建对象，但是，创建对象的工作如果比较麻烦，就需要有人专门做这个事情，所以就知道了一个专门的类来创建对象。 public class AnimalFactory { private AnimalFactory(){} //public static Dog createDog() {return new Dog();} //public static Cat createCat() {return new Cat();} //改进 public static Animal createAnimal(String animalName) { if(“dog”.equals(animalName)) {} else if(“cat”.equals(animale)) { }else { return null; } }} 123456789## 0x1f 设计模式(工厂方法模式的概述和使用)* A:工厂方法模式概述 * 工厂方法模式中抽象工厂类负责定义创建对象的接口，具体对象的创建工作由继承抽象工厂的具体类实现。* B:优点 * 客户端不需要在负责对象的创建，从而明确了各个类的职责，如果有新的对象增加，只需要增加一个具体的类和具体的工厂类即可，不影响已有的代码，后期维护容易，增强了系统的扩展性* C:缺点 * 需要额外的编写代码，增加了工作量* D:案例演示 动物抽象类：public abstract Animal { public abstract void eat(); }工厂接口：public interface Factory {public abstract Animal createAnimal();}具体狗类：public class Dog extends Animal {}具体猫类：public class Cat extends Animal {}开始，在测试类中每个具体的内容自己创建对象，但是，创建对象的工作如果比较麻烦，就需要有人专门做这个事情，所以就知道了一个专门的类来创建对象。发现每次修改代码太麻烦，用工厂方法改进，针对每一个具体的实现提供一个具体工厂。狗工厂：public class DogFactory implements Factory { public Animal createAnimal() {…} }猫工厂：public class CatFactory implements Factory { public Animal createAnimal() {…} } 123## 0x21 GUI(如何创建一个窗口并显示)* Graphical User Interface(图形用户接口)。 Frame f = new Frame(“my window”);f.setLayout(new FlowLayout());//设置布局管理器f.setSize(500,400);//设置窗体大小f.setLocation(300,200);//设置窗体出现在屏幕的位置f.setIconImage(Toolkit.getDefaultToolkit().createImage(“qq.png”));f.setVisible(true); 12345678910111213141516## 0x22 GUI(布局管理器)* FlowLayout（流式布局管理器） * 从左到右的顺序排列。 * Panel默认的布局管理器。* BorderLayout（边界布局管理器） * 东，南，西，北，中 * Frame默认的布局管理器。* GridLayout（网格布局管理器） * 规则的矩阵* CardLayout（卡片布局管理器） * 选项卡* GridBagLayout（网格包布局管理器） * 非规则的矩阵## 0x23 GUI(窗体监听) package com.bing.gui; import java.awt.Button;import java.awt.FlowLayout;import java.awt.Frame;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent;import java.awt.event.MouseAdapter;import java.awt.event.MouseEvent;import java.awt.event.MouseListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import java.awt.event.WindowListener; public class Encrypt { public static void main(String[] args) { Frame f = new Frame(&quot;java加解密工具&quot;); f.setSize(1800, 1600); f.setLocation(500, 100); // 按钮配置 Button b1 = new Button(&quot;RSA加密&quot;); Button b2 = new Button(&quot;RSA解密&quot;); f.add(b1); f.add(b2); // 流布局设置 f.setLayout(new FlowLayout()); // 窗口调用监听接口,接收参数为类 // f.addWindowListener(new MyWindowsAdapter()); f.addWindowListener(new WindowAdapter() { //直接使用匿名内部类操作,比较简洁 @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); // 鼠标监听 -- 样例 b1.addMouseListener(new MouseAdapter() { @Override public void mouseReleased(MouseEvent e) { // 鼠标释放操作，如果使用点击事件，有时候没点中位置，会不执行 } }); // 键盘监听 -- 样例 b1.addKeyListener(new KeyAdapter() { @Override public void keyReleased(KeyEvent e) { // 键盘释放操作 if(e.getKeyCode() == KeyEvent.VK_SPACE) { System.exit(0); } } }); // 动作监听--对应的是点击和空格键，一般用于暂停和播放视频 b2.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { System.exit(0); } }); f.setVisible(true); }} /* // 实现监听接口1class MyWindowsListener implements WindowListener { @Override public void windowOpened(WindowEvent e) { } @Override public void windowClosing(WindowEvent e) { System.exit(0); } @Override public void windowClosed(WindowEvent e) { } @Override public void windowIconified(WindowEvent e) { } @Override public void windowDeiconified(WindowEvent e) { } @Override public void windowActivated(WindowEvent e) { } @Override public void windowDeactivated(WindowEvent e) { }} // 实现监听接口2class MyWindowsAdapter extends WindowAdapter { @Override public void windowClosing(WindowEvent e) { System.exit(0); } } */ ## 0x24 设计模式(适配器设计模式) * a.什么是适配器 * 在使用监听器的时候, 需要定义一个类事件监听器接口. * 通常接口中有多个方法, 而程序中不一定所有的都用到, 但又必须重写, 这很繁琐. * 适配器简化了这些操作, 我们定义监听器时只要继承适配器, 然后重写需要的方法即可. * b.适配器原理 * 适配器就是一个类, 实现了监听器接口, 所有抽象方法都重写了, 但是方法全是空的. * 适配器类需要定义成抽象的,因为创建该类对象,调用空方法是没有意义的 * 目的就是为了简化程序员的操作, 定义监听器时继承适配器, 只重写需要的方法就可以了.]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-字符操作]]></title>
    <url>%2F2018%2F10%2F27%2Fjava-%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[0x01 java字符串操作实战代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166package test;import java.util.Scanner; public class HelloWord &#123; /** * @param args */ public static void main(String[] args) &#123; /* * int indexof(int ch): 返回字符在此字符串中第一次出现的索引 * int indexof(String str): 返回指定字符串在此字符串中第一次出现的索引 */ System.out.println(&quot;hello world&quot;); // hashcode编码后就是对应的内存地址 Scanner test = new Scanner(System.in); int hashcode = test.hashCode(); System.out.println(&quot;test对象内存地址：&quot; + hashcode); System.out.println(&quot;test对象转换为字符串：&quot; + test.toString()); // 字符串进行判断是输入的字符串还是其它整形hasNextInt() Scanner sc = new Scanner(System.in); if(sc.hasNextLine()) &#123; String i = sc.nextLine(); System.out.println(i); &#125;else &#123; System.out.println(&quot;type error!&quot;); &#125; //字节转换成字符串；new String 默认会调用toString方法; 还有 indexof, substring, length, CharAt等属性 byte[] arr1 = &#123;97, 98, 99&#125;; String s1 = new String(arr1); // 也可以适应 String(arr1, 1, 2); 将arr1字节数组从1索引开始转换2个 System.out.println(s1); Scanner sc2 = new Scanner(System.in); // 获取信息; nextInt只获取整数,如果后面再有nextLine的话，会直接获取nextInt后的换车换行符 int i = sc2.nextInt(); System.out.println(i); String i2 = sc2.nextLine(); System.out.println(i2); //会导致这里出现空白 //concat :把字符串拼接； toUpperCase, getBytes, toCharArray, toLowerCase char[] arr = &#123;&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;&#125; String a = String.valueOf(arr); System.out.println(a); //把字符数组转换成字符串 // replace, trim, compareTo:字符串比较 &#125; &#125; package test;import java.util.Arrays; public class te1 &#123; public static void main(String[] args) &#123; System.out.println(&quot;# 字符串反转&quot;); String sc = &quot;abc&quot;; StringBuffer sb = new StringBuffer(); StringBuffer sb2 = sb.append(sc); StringBuffer sb3 = sb2.reverse(); System.out.println(sb3); System.out.println(sb3.toString()); System.out.println(sb3.hashCode()); System.out.println(&quot;# 整形数组输出&quot;); int[] sc1 = &#123; 1, 2, 3&#125;; System.out.println(sc1.toString()); System.out.println(sc1.hashCode()); System.out.println(&quot;# 字符串数组转字符串&quot;); String[] ary = &#123;&quot;abc&quot;, &quot;123&quot;, &quot;45&quot;&#125;; StringBuffer sb4 = new StringBuffer(); for(int i = 0; i &lt; ary.length; i++)&#123; sb4.append(ary[i]); &#125; String newStr = sb4.toString(); System.out.println(newStr.toString()); System.out.println(newStr.hashCode()); /* * 冒泡排序：轻的上浮，沉的下降。 * 两个相邻位置比较，如果前面的元素比后面的元素大就换位置。 */ int[] arr = &#123;24, 69, 10, 57, 13&#125;; bublleSort(arr); print(arr); /* * 选择排序：用一个索引位置上的元素，依次与其它索引位置上的元素比较 * 小的在前面，大的在后面 */ selectSort(arr); print(arr); /* * 二分查找: * 前提：数组是有序的 */ int[] arr2 = &#123;11,22,33,44,55,66&#125;; System.out.println(getIndex(arr2, 33)); /* * Arrays的应用 */ int[] arr3 = &#123;33,22,11,44,66,55&#125;; System.out.println(Arrays.toString(arr3)); Arrays.sort(arr3); System.out.println(Arrays.toString(arr3)); System.out.println(Integer.toBinaryString(80)); // 二进制 System.out.println(Integer.toOctalString(80)); // 八进制 // 整型转换成字符串 int ---&gt; string int i = 100; String s2 = Integer.toString(i); // 字符串转换成整型 string ---&gt; int String s1 = &quot;100&quot;; int i2 = Integer.parseInt(s1); &#125; public static void bublleSort(int[] arr) &#123; for(int i = 0; i &lt; arr.length-1; i++) &#123; for(int j = 0; j &lt; arr.length-1 -i; j++) &#123; if( arr[j] &gt; arr[j+1] ) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j+1] = temp; &#125; &#125; &#125; &#125; public static void selectSort(int[] arr) &#123; for(int i = 0; i &lt; arr.length - 1; i++ ) &#123; for(int j = i + 1; j &lt; arr.length; j++) &#123; if( arr[i] &gt; arr[j] ) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; &#125; &#125; public static int getIndex(int[] arr, int value) &#123; int min = 0; int max = arr.length - 1; int mid = (min + max)/2; while(arr[mid] != value) &#123; if(arr[mid] &lt; value) &#123; min = mid +1; &#125;else if(arr[mid] &gt; value) &#123; max = mid -1; &#125; mid = (mid + max)/2; if(min &gt; max) &#123; return -1; &#125; &#125; return mid; &#125; public static void print(int[] arr) &#123; for(int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125;]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-集合]]></title>
    <url>%2F2018%2F10%2F26%2Fjava-%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[0x01 集合的由来数组长度是固定,当添加的元素超过了数组的长度时需要对数组重新定义,太麻烦,java内部给我们提供了集合类,能存储任意对象,长度是可以改变的,随着元素的增加而增加,随着元素的减少而减少 数组和集合的区别 * 区别1 : * 数组既可以存储基本数据类型,又可以存储引用数据类型,基本数据类型存储的是值,引用数据类型存储的是地址值 * 集合只能存储引用数据类型(对象)集合中也可以存储基本数据类型,但是在存储的时候会自动装箱变成对象 * 区别2: * 数组长度是固定的,不能自动增长 * 集合的长度的是可变的,可以根据元素的增加而增长数组和集合什么时候用 * 1,如果元素个数是固定的推荐用数组 * 2,如果元素个数不是固定的推荐用集合 0x02 集合框架(对象数组的概述和使用)123456789Student[] arr = new Student[5]; //存储学生对象arr[0] = new Student(&quot;张三&quot;, 23);arr[1] = new Student(&quot;李四&quot;, 24);arr[2] = new Student(&quot;王五&quot;, 25);arr[3] = new Student(&quot;赵六&quot;, 26);arr[4] = new Student(&quot;马哥&quot;, 20);for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]);&#125; 数组和集合存储引用数据类型,存的都是地址值 Collection集合的基本功能测试基本功能演示 12345678910boolean add(E e)boolean remove(Object o)void clear()boolean contains(Object o)boolean isEmpty()int size()boolean addAll(Collection c) // 将c中的元素添加到集合中，而add是将整个集合当成一个对象添加到集合中boolean removeAll(Collection c) // 删除的是交集boolean containsAll(Collection c) // 判断调用的集合是否包含传入的集合boolean retainAll(Collection c) // 判断调用的集合是否改变，改变为true, 不变为false ；默认是取交集后，赋值给调用集合，然后再判断是否改变 基础集合 123456Collection c = new ArrayList(); //父类引用指向子类对象 --定义的有序集合，由索引可重复 ；还有一种是无序集合，由索引，不可重复boolean b1 = c.add(&quot;abc&quot;); // trueboolean b2 = c.add(true); // true boolean b3 = c.add(100); // trueboolean b4 = c.add(&quot;abc&quot;); // trueSystem.out.println(c); 集合遍历 1234567891011Collection coll = new ArrayList();coll.add(new Student(&quot;张三&quot;,23)); //Object obj = new Student(&quot;张三&quot;,23);coll.add(new Student(&quot;李四&quot;,24));coll.add(new Student(&quot;王五&quot;,25));coll.add(new Student(&quot;赵六&quot;,26));Object[] arr = coll.toArray(); //将集合转换成数组，权限提升[向上转型], 变成都为object对象 for (int i = 0; i &lt; arr.length; i++) &#123; Student s = (Student)arr[i]; //强转成Student, 向下转型 System.out.println(s.getName() + &quot;,&quot; + s.getAge());&#125; 集合进行迭代 12345678910Collection c = new ArrayList();c.add(&quot;a&quot;);c.add(&quot;b&quot;);c.add(&quot;c&quot;);c.add(&quot;d&quot;); Iterator it = c.iterator(); //获取迭代器的引用while(it.hasNext()) &#123; //集合中的迭代方法(遍历) System.out.println(it.next());&#125; 0x03 迭代器原理迭代器原理:迭代器是对集合进行遍历,而每一个集合内部的存储结构都是不同的,所以每一个集合存和取都是不一样,那么就需要在每一个类中定义hasNext()和next()方法,这样做是可以的,但是会让整个集合体系过于臃肿,迭代器是将这样的方法向上抽取出接口,然后在每个类的内部,定义自己迭代方式,这样做的好处有二,第一规定了整个集合体系的遍历方式都是hasNext()和next()方法,第二,代码有底层内部实现,使用者不用管怎么实现的,会用即可 List集合的特有功能概述 123456789101112131415 * void add(int index,E element) * E remove(int index) // 传入的参数是整数会当成索引 * E get(int index) * E set(int index,E element) * 通过size()和get()方法结合使用遍历。 List list = new ArrayList(); list.add(new Student(&quot;张三&quot;, 18)); list.add(new Student(&quot;李四&quot;, 18)); list.add(new Student(&quot;王五&quot;, 18)); list.add(new Student(&quot;赵六&quot;, 18)); for(int i = 0; i &lt; list.size(); i++) &#123; Student s = (Student)list.get(i); System.out.println(s.getName() + &quot;,&quot; + s.getAge()); &#125; 案例演示 123456789101112131415 * 需求：我有一个集合，请问，我想判断里面有没有&quot;world&quot;这个元素，如果有，我就添加一个&quot;javaee&quot;元素，请写代码实现。List list = new ArrayList();list.add(&quot;a&quot;);list.add(&quot;b&quot;);list.add(&quot;world&quot;);list.add(&quot;d&quot;);list.add(&quot;e&quot;); /*Iterator it = list.iterator();while(it.hasNext()) &#123; String str = (String)it.next(); if(str.equals(&quot;world&quot;)) &#123; list.add(&quot;javaee&quot;); //这里会抛出ConcurrentModificationException并发修改异常 &#125;&#125;*/ ConcurrentModificationException出现 * 迭代器遍历，集合修改集合 解决方案 123456789101112131415 * a:迭代器迭代元素，迭代器修改元素(ListIterator的特有功能add) * b:集合遍历元素，集合修改元素 ListIterator lit = list.listIterator(); //如果想在遍历的过程中添加元素,可以用ListIterator中的add方法 while(lit.hasNext()) &#123; String str = (String)lit.next(); if(str.equals(&quot;world&quot;)) &#123; lit.add(&quot;javaee&quot;); //list.add(&quot;javaee&quot;); &#125; &#125; * boolean hasNext()是否有下一个 * boolean hasPrevious()是否有前一个 * Object next()返回下一个元素 * Object previous();返回上一个元素 0x04 Vector类概述Vector类特有功能 * public void addElement(E obj) * public E elementAt(int index) * public Enumeration elements()案例演示 123456789101112Vector的迭代 Vector v = new Vector(); //创建集合对象,List的子类 v.addElement(&quot;a&quot;); v.addElement(&quot;b&quot;); v.addElement(&quot;c&quot;); v.addElement(&quot;d&quot;); //Vector迭代 Enumeration en = v.elements(); //获取枚举 while(en.hasMoreElements()) &#123; //判断集合中是否有元素 System.out.println(en.nextElement());//获取集合中的元素 &#125; 0x05 LinkedList链表的特有功能概述123456789101112131415161718192021222324252627282930import java.util.Iterator;import java.util.LinkedList; public class Demo8 &#123; public static void main(String[] args) &#123; LinkedList list= new LinkedList(); list.add(&quot;张三&quot;); list.add(&quot;李四&quot;); list.add(&quot;王五&quot;); /* list.addFirst(&quot;狗娃&quot;); //把元素添加到集合的首位置上。 list.addLast(&quot;狗剩&quot;); //把元素添加到集合的末尾处。 System.out.println(&quot;获取集合中首位置的元素:&quot;+list.getFirst()); System.out.println(&quot;获取集合中末尾的元素：&quot;+ list.getLast()); System.out.println(&quot;删除集合中的首位置元素并返回：&quot;+ list.removeFirst()); System.out.println(&quot;删除集合中的末尾素并返回：&quot;+ list.removeLast()); list.push(&quot;狗娃&quot;); //将该元素插入此集合的开头处。 System.out.println(&quot;删除集合的首元素：&quot;+list.pop()); //移除并返回集合中的第一个元素 list.offer(&quot;狗剩&quot;); System.out.println(&quot;删除集合的首元素: &quot;+list.poll()); System.out.println(&quot;集合中的元素：&quot;+ list); */ Iterator it = list.descendingIterator(); while(it.hasNext())&#123; System.out.println(it.next()); &#125; &#125;&#125; 0x06 集合框架(List的三个子类的特点)A:List的三个子类的特点 * ArrayList: 底层数据结构是数组，查询快，增删慢。 线程不安全，效率高。 Vector: 底层数据结构是数组，查询快，增删慢。 线程安全，效率低。 Vector相对ArrayList查询慢(线程安全的) Vector相对LinkedList增删慢(数组结构) LinkedList: 底层数据结构是链表，查询慢，增删快。 线程不安全，效率高。 Vector和ArrayList的区别 Vector是线程安全的,效率低 ArrayList是线程不安全的,效率高 共同点:都是数组实现的 ArrayList和LinkedList的区别 ArrayList底层是数组结果,查询和修改快 LinkedList底层是链表结构的,增和删比较快,查询和修改比较慢 共同点:都是线程不安全的 B:List有三个儿子，我们到底使用谁呢? * 查询多用ArrayList 增删多用LinkedList 如果都多ArrayList 0x07 集合框架(HashSet存储字符串并遍历)Set集合概述及特点 * 通过API查看即可案例演示 * HashSet存储字符串并遍历 12345678HashSet&lt;String&gt; hs = new HashSet&lt;&gt;();boolean b1 = hs.add(&quot;a&quot;);boolean b2 = hs.add(&quot;a&quot;); //当存储不成功的时候,返回falseSystem.out.println(b1);System.out.println(b2);for(String s : hs) &#123; System.out.println(s);&#125; 0x08 集合框架(HashSet存储自定义对象保证元素唯一性)A:案例演示 * 存储自定义对象，并保证元素唯一性。 重写hashCode()和equals()方法 1234567HashSet&lt;Person&gt; hs = new HashSet&lt;&gt;();hs.add(new Person(&quot;张三&quot;, 23));hs.add(new Person(&quot;张三&quot;, 23));hs.add(new Person(&quot;李四&quot;, 23));hs.add(new Person(&quot;李四&quot;, 23));hs.add(new Person(&quot;王五&quot;, 23));hs.add(new Person(&quot;赵六&quot;, 23)); B:代码优化 * 为了减少比较，优化hashCode()代码写法。 * 最终版就是自动生成即可。 1.HashSet如何保证元素唯一性的原理 * 我们使用Set集合都是需要去掉重复元素的, 如果在存储的时候逐个equals()比较, 效率较低,哈希算法提高了去重复的效率, 降低了使用equals()方法的次数 * 当HashSet调用add()方法存储对象的时候, 先调用对象的hashCode()方法得到一个哈希值, 然后在集合中查找是否有哈希值相同的对象 * 如果没有哈希值相同的对象就直接存入集合 * 如果有哈希值相同的对象, 就和哈希值相同的对象逐个进行equals()比较,比较结果为false就存入, true则不存2.将自定义类的对象存入HashSet去重复 * 类中必须重写hashCode()和equals()方法 * hashCode(): 属性相同的对象返回值必须相同, 属性不同的返回值尽量不同(提高效率) * equals(): 属性相同返回true, 属性不同返回false,返回false的时候存储 0x09 集合框架(LinkedHashSet的概述和使用)A:LinkedHashSet的特点B:案例演示 * LinkedHashSet的特点 * 可以保证怎么存就怎么取 案例演示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 * 需求：编写一个程序，获取10个1至20的随机数，要求随机数不能重复。并把最终的随机数输出到控制台。 * HashSet&lt;Integer&gt; hs = new HashSet&lt;&gt;(); //创建集合对象 Random r = new Random(); //创建随机数对象 while(hs.size() &lt; 10) &#123; int num = r.nextInt(20) + 1; //生成1到20的随机数 hs.add(num); &#125; for (Integer integer : hs) &#123; //遍历集合 System.out.println(integer); //打印每一个元素 &#125; * 使用Scanner从键盘读取一行输入,去掉其中重复字符, 打印出不同的那些字符 * aaaabbbcccddd Scanner sc = new Scanner(System.in); //创建键盘录入对象 System.out.println(&quot;请输入一行字符串:&quot;); String line = sc.nextLine(); //将键盘录入的字符串存储在line中 char[] arr = line.toCharArray(); //将字符串转换成字符数组 HashSet&lt;Character&gt; hs = new HashSet&lt;&gt;(); //创建HashSet集合对象 for(char c : arr) &#123; //遍历字符数组 hs.add(c); //将字符数组中的字符添加到集合中 &#125; for (Character ch : hs) &#123; //遍历集合 System.out.println(ch); &#125; * 将集合中的重复元素去掉* public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;a&quot;); list.add(&quot;a&quot;); list.add(&quot;a&quot;); list.add(&quot;b&quot;); list.add(&quot;b&quot;); list.add(&quot;b&quot;); list.add(&quot;b&quot;); list.add(&quot;c&quot;); list.add(&quot;c&quot;); list.add(&quot;c&quot;); list.add(&quot;c&quot;); System.out.println(list); System.out.println(&quot;去除重复后:&quot;); getSingle(list); System.out.println(list); &#125; /* * 将集合中的重复元素去掉 * 1,void * 2,List&lt;String&gt; list */ public static void getSingle(List&lt;String&gt; list) &#123; LinkedHashSet&lt;String&gt; lhs = new LinkedHashSet&lt;&gt;(); lhs.addAll(list); //将list集合中的所有元素添加到lhs list.clear(); //清空原集合 list.addAll(lhs); //将去除重复的元素添回到list中 &#125; 0x0a 集合框架(TreeSet原理)1.特点 * TreeSet是用来排序的, 可以指定一个顺序, 对象存入之后会按照指定的顺序排列2.使用方式 * a.自然顺序(Comparable) * TreeSet类的add()方法中会把存入的对象提升为Comparable类型 * 调用对象的compareTo()方法和集合中的对象比较 * 根据compareTo()方法返回的结果进行存储 * b.比较器顺序(Comparator) * 创建TreeSet的时候可以制定 一个Comparator * 如果传入了Comparator的子类对象, 那么TreeSet就会按照比较器中的顺序排序 * add()方法内部会自动调用Comparator接口中compare()方法排序 * 调用的对象是compare方法的第一个参数,集合中的对象是compare方法的第二个参数 * c.两种方式的区别 * TreeSet构造函数什么都不传, 默认按照类中Comparable的顺序(没有就报错ClassCastException) * TreeSet如果传入Comparator, 就优先按照Comparator 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596* 在一个集合中存储了无序并且重复的字符串,定义一个方法,让其有序(字典顺序),而且还不能去除重复public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;ccc&quot;); list.add(&quot;ccc&quot;); list.add(&quot;aaa&quot;); list.add(&quot;aaa&quot;); list.add(&quot;bbb&quot;); list.add(&quot;ddd&quot;); list.add(&quot;ddd&quot;); sort(list); System.out.println(list);&#125;/** 对集合中的元素排序,并保留重复* 1,void* 2,List&lt;String&gt; list*/public static void sort(List&lt;String&gt; list) &#123; // 使用Tree进行排序，但是会去掉重复的数值，所以需要改写底层的comparator进行保留重复 TreeSet&lt;String&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;String&gt;() &#123; //定义比较器(new Comparator()&#123;&#125;是Comparator的子类对象); 改写保留重复 @Override public int compare(String s1, String s2) &#123; //重写compare方法 int num = s1.compareTo(s2); //比较内容 return num == 0 ? 1 : num; //如果内容一样返回一个不为0的数字即可 &#125; &#125;); ts.addAll(list); //将list集合中的所有元素添加到ts中 list.clear(); //清空list list.addAll(ts); //将ts中排序并保留重复的结果在添加到list中&#125; * 从键盘接收一个字符串, 程序对其中所有字符进行排序,例如键盘输入: helloitcast程序打印:acehillosttScanner sc = new Scanner(System.in); //创建键盘录入对象System.out.println(&quot;请输入一行字符串:&quot;);String line = sc.nextLine(); //将键盘录入的字符串存储在line中char[] arr = line.toCharArray(); //将字符串转换成字符数组TreeSet&lt;Character&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;Character&gt;() &#123; @Override public int compare(Character c1, Character c2) &#123; //int num = c1.compareTo(c2); int num = c1 - c2; //自动拆箱 return num == 0 ? 1 : num; &#125;&#125;); for(char c : arr) &#123; ts.add(c);&#125; for(Character ch : ts) &#123; System.out.print(ch);&#125; * 程序启动后, 可以从键盘输入接收多个整数, 直到输入quit时结束输入. 把所有输入的整数倒序排列打印.Scanner sc = new Scanner(System.in); //创建键盘录入对象System.out.println(&quot;请输入:&quot;);TreeSet&lt;Integer&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;Integer&gt;() &#123; //将比较器传给TreeSet的构造方法 @Override public int compare(Integer i1, Integer i2) &#123; //int num = i2 - i1; //自动拆箱 int num = i2.compareTo(i1); return num == 0 ? 1 : num; &#125;&#125;); while(true) &#123; String line = sc.nextLine(); //将键盘录入的字符串存储在line中 if(&quot;quit&quot;.equals(line)) //如果字符串常量和变量比较,常量放前面,这样不会出现空指针异常,变量里面可能存储null break; try &#123; int num = Integer.parseInt(line); //将数字字符串转换成数字 ts.add(num); &#125; catch (Exception e) &#123; System.out.println(&quot;您录入的数据有误,请输入一个整数&quot;); &#125; &#125; for (Integer i : ts) &#123; //遍历TreeSet集合 System.out.println(i); &#125; 案例演示 1234567891011121314151617181920212223242526272829* 需求：键盘录入5个学生信息(姓名,语文成绩,数学成绩,英语成绩),按照总分从高到低输出到控制台。Scanner sc = new Scanner(System.in);System.out.println(&quot;请输入5个学生成绩格式是:(姓名,语文成绩,数学成绩,英语成绩)&quot;);TreeSet&lt;Student&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;Student&gt;() &#123; @Override public int compare(Student s1, Student s2) &#123; int num = s2.getSum() - s1.getSum(); //根据学生的总成绩降序排列 return num == 0 ? 1 : num; &#125;&#125;);while(ts.size() &lt; 5) &#123; String line = sc.nextLine(); try &#123; String[] arr = line.split(&quot;,&quot;); int chinese = Integer.parseInt(arr[1]); //转换语文成绩 int math = Integer.parseInt(arr[2]); //转换数学成绩 int english = Integer.parseInt(arr[3]); //转换英语成绩 ts.add(new Student(arr[0], chinese, math, english)); &#125; catch (Exception e) &#123; System.out.println(&quot;录入格式有误,输入5个学生成绩格式是:(姓名,语文成绩,数学成绩,英语成绩&quot;); &#125; &#125;System.out.println(&quot;排序后的学生成绩是:&quot;);for (Student s : ts) &#123; System.out.println(s);&#125; List * a.普通for循环, 使用get()逐个获取 * b.调用iterator()方法得到Iterator, 使用hasNext()和next()方法 * c.增强for循环, 只要可以使用Iterator的类都可以用 * d.Vector集合可以使用Enumeration的hasMoreElements()和nextElement()方法Set * a.调用iterator()方法得到Iterator, 使用hasNext()和next()方法 * b.增强for循环, 只要可以使用Iterator的类都可以用普通for循环,迭代器,增强for循环是否可以在遍历的过程中删除 0x0b 集合框架(Map集合概述和特点)Map接口概述 * 查看API可以知道： * 将键映射到值的对象 * 一个映射不能包含重复的键 * 每个键最多只能映射到一个值Map接口和Collection接口的不同 * Map是双列的,Collection是单列的 * Map的键唯一,Collection的子体系Set是唯一的 * Map集合的数据结构值针对键有效，跟值无关;Collection集合的数据结构是针对元素有效 Map集合的功能概述 * a:添加功能 * V put(K key,V value):添加元素。 * 如果键是第一次存储，就直接存储元素，返回null * 如果键不是第一次存在，就用值把以前的值替换掉，返回以前的值 * b:删除功能 * void clear():移除所有的键值对元素 * V remove(Object key)：根据键删除键值对元素，并把值返回 * c:判断功能 * boolean containsKey(Object key)：判断集合是否包含指定的键 * boolean containsValue(Object value):判断集合是否包含指定的值 * boolean isEmpty()：判断集合是否为空 * d:获取功能 * Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(): * V get(Object key):根据键获取值 * Set keySet():获取集合中所有键的集合 * Collection values():获取集合中所有值的集合 * e:长度功能 * int size()：返回集合中的键值对的个数 0x0c 框架(Map集合的遍历之键找值)A:键找值思路： * 获取所有键的集合 * 遍历键的集合，获取到每一个键 * 根据键找值B:案例演示 * Map集合的遍历之键找值 1234567891011121314151617HashMap&lt;String, Integer&gt; hm = new HashMap&lt;&gt;();hm.put(&quot;张三&quot;, 23);hm.put(&quot;李四&quot;, 24);hm.put(&quot;王五&quot;, 25);hm.put(&quot;赵六&quot;, 26); /*Set&lt;String&gt; keySet = hm.keySet(); //获取集合中所有的键Iterator&lt;String&gt; it = keySet.iterator(); //获取迭代器while(it.hasNext()) &#123; //判断单列集合中是否有元素 String key = it.next(); //获取集合中的每一个元素,其实就是双列集合中的键 Integer value = hm.get(key); //根据键获取值 System.out.println(key + &quot;=&quot; + value); //打印键值对&#125;*/ for(String key : hm.keySet()) &#123; //增强for循环迭代双列集合第一种方式 System.out.println(key + &quot;=&quot; + hm.get(key));&#125; A:键值对对象找键和值思路： * 获取所有键值对对象的集合 * 遍历键值对对象的集合，获取到每一个键值对对象 * 根据键值对对象找键和值案例演示 123456789101112131415161718192021* Map集合的遍历之键值对对象找键和值HashMap&lt;String, Integer&gt; hm = new HashMap&lt;&gt;();hm.put(&quot;张三&quot;, 23);hm.put(&quot;李四&quot;, 24);hm.put(&quot;王五&quot;, 25);hm.put(&quot;赵六&quot;, 26);/*Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySet = hm.entrySet(); //获取所有的键值对象的集合Iterator&lt;Entry&lt;String, Integer&gt;&gt; it = entrySet.iterator();//获取迭代器while(it.hasNext()) &#123; Entry&lt;String, Integer&gt; en = it.next(); //获取键值对对象 String key = en.getKey(); //根据键值对对象获取键 Integer value = en.getValue(); //根据键值对对象获取值 System.out.println(key + &quot;=&quot; + value);&#125;*/ for(Entry&lt;String,Integer&gt; en : hm.entrySet()) &#123; System.out.println(en.getKey() + &quot;=&quot; + en.getValue());&#125;``` 案例演示 需求：统计字符串中每个字符出现的次数String str = “aaaabbbcccccccccc”;char[] arr = str.toCharArray(); //将字符串转换成字符数组HashMap&lt;Character, Integer&gt; hm = new HashMap&lt;&gt;(); //创建双列集合存储键和值 for(char c : arr) { //遍历字符数组 /*if(!hm.containsKey(c)) { //如果不包含这个键 hm.put(c, 1); //就将键和值为1添加 }else { //如果包含这个键 hm.put(c, hm.get(c) + 1); //就将键和值再加1添加进来 } //hm.put(c, !hm.containsKey(c) ? 1 : hm.get(c) + 1); Integer i = !hm.containsKey(c) ? hm.put(c, 1) : hm.put(c, hm.get(c) + 1); }for (Character key : hm.keySet()) { //遍历双列集合 System.out.println(key + “=” + hm.get(key));} 12345678910111213141516 ## 0x0d 集合框架(HashMap和Hashtable的区别) * HashMap和Hashtable的区别 * Hashtable是JDK1.0版本出现的,是线程安全的,效率低,HashMap是JDK1.2版本出现的,是线程不安全的,效率高 * Hashtable不可以存储null键和null值,HashMap可以存储null键和null值 ## 0x0e 集合框架(Collections工具类的概述和常见方法讲解)A:Collections类概述 * 针对集合操作 的工具类B:Collections成员方法 * public static &lt;T&gt; void sort(List&lt;T&gt; list) public static &lt;T&gt; int binarySearch(List&lt;?&gt; list,T key) public static &lt;T&gt; T max(Collection&lt;?&gt; coll) public static void reverse(List&lt;?&gt; list) public static void shuffle(List&lt;?&gt; list) 模拟斗地主洗牌和发牌，牌没有排序//买一副扑克String[] num = {“A”,”2”,”3”,”4”,”5”,”6”,”7”,”8”,”9”,”10”,”J”,”Q”,”K”};String[] color = {“方片”,”梅花”,”红桃”,”黑桃”};ArrayList poker = new ArrayList&lt;&gt;(); for(String s1 : color) { for(String s2 : num) { poker.add(s1.concat(s2)); }} poker.add(“小王”);poker.add(“大王”);//洗牌Collections.shuffle(poker);//发牌ArrayList gaojin = new ArrayList&lt;&gt;();ArrayList longwu = new ArrayList&lt;&gt;();ArrayList me = new ArrayList&lt;&gt;();ArrayList dipai = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; poker.size(); i++) { if(i &gt;= poker.size() - 3) { dipai.add(poker.get(i)); }else if(i % 3 == 0) { gaojin.add(poker.get(i)); }else if(i % 3 == 1) { longwu.add(poker.get(i)); }else { me.add(poker.get(i)); }} //看牌 System.out.println(gaojin);System.out.println(longwu);System.out.println(me);System.out.println(dipai); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758案例演示``` * 模拟斗地主洗牌和发牌并对牌进行排序的代码实现 //买一副牌String[] num = &#123;&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;10&quot;,&quot;J&quot;,&quot;Q&quot;,&quot;K&quot;,&quot;A&quot;,&quot;2&quot;&#125;;String[] color = &#123;&quot;方片&quot;,&quot;梅花&quot;,&quot;红桃&quot;,&quot;黑桃&quot;&#125;;HashMap&lt;Integer, String&gt; hm = new HashMap&lt;&gt;(); //存储索引和扑克牌ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); //存储索引int index = 0; //索引的开始值for(String s1 : num) &#123; for(String s2 : color) &#123; hm.put(index, s2.concat(s1)); //将索引和扑克牌添加到HashMap中 list.add(index); //将索引添加到ArrayList集合中 index++; &#125;&#125;hm.put(index, &quot;小王&quot;);list.add(index);index++;hm.put(index, &quot;大王&quot;);list.add(index);//洗牌Collections.shuffle(list);//发牌TreeSet&lt;Integer&gt; gaojin = new TreeSet&lt;&gt;();TreeSet&lt;Integer&gt; longwu = new TreeSet&lt;&gt;();TreeSet&lt;Integer&gt; me = new TreeSet&lt;&gt;();TreeSet&lt;Integer&gt; dipai = new TreeSet&lt;&gt;(); for(int i = 0; i &lt; list.size(); i++) &#123; if(i &gt;= list.size() - 3) &#123; dipai.add(list.get(i)); //将list集合中的索引添加到TreeSet集合中会自动排序 &#125;else if(i % 3 == 0) &#123; gaojin.add(list.get(i)); &#125;else if(i % 3 == 1) &#123; longwu.add(list.get(i)); &#125;else &#123; me.add(list.get(i)); &#125;&#125; //看牌lookPoker(&quot;高进&quot;, gaojin, hm);lookPoker(&quot;龙五&quot;, longwu, hm);lookPoker(&quot;冯佳&quot;, me, hm);lookPoker(&quot;底牌&quot;, dipai, hm); &#125; public static void lookPoker(String name,TreeSet&lt;Integer&gt; ts,HashMap&lt;Integer, String&gt; hm) &#123;System.out.print(name + &quot;的牌是:&quot;);for (Integer index : ts) &#123; System.out.print(hm.get(index) + &quot; &quot;);&#125; System.out.println();&#125; 一般在使用HashMap,HashSet的时候，在调用类中调用对象需要重写其中的hashcode和equals一般在使用TreeMap,TreeSet的时候，在调用类中调用实现Comparetor接口并重写其compareTo方法 – 可以做排序，默认也可以做去重复；但是修改底层的comparetor可以进行对重复的数据进行保留 123456789101112131415161718192021222324252627282930313233343536* 需求：ArrayList去除集合中字符串的重复值(字符串的内容相同) * 思路：创建新集合方式public static void main(String[] args) &#123; ArrayList list = new ArrayList(); list.add(&quot;a&quot;); list.add(&quot;a&quot;); list.add(&quot;b&quot;); list.add(&quot;b&quot;); list.add(&quot;b&quot;); list.add(&quot;c&quot;); list.add(&quot;c&quot;); list.add(&quot;c&quot;); list.add(&quot;c&quot;); System.out.println(list); ArrayList newList = getSingle(list); System.out.println(newList);&#125; /* * 去除重复 * 1,返回ArrayList * 2,参数列表ArrayList */public static ArrayList getSingle(ArrayList list) &#123; ArrayList newList = new ArrayList(); //创建一个新集合 Iterator it = list.iterator(); //获取迭代器 while(it.hasNext()) &#123; //判断老集合中是否有元素 String temp = (String)it.next(); //将每一个元素临时记录住 if(!newList.contains(temp)) &#123; //如果新集合中不包含该元素 newList.add(temp); //将该元素添加到新集合中 &#125; &#125; return newList; //将新集合返回&#125; A:去除ArrayList中重复自定义对象元素 * 需求：ArrayList去除集合中自定义对象元素的重复值(对象的成员变量值相同) * 重写equals()方法的，需要做向下转型 B:LinkedList类特有功能 * public void addFirst(E e)及addLast(E e) * public E getFirst()及getLast() * public E removeFirst()及public E removeLast() * public E get(int index); 集合框架(栈和队列数据结构) 栈 先进后出 队列 先进先出 1234567891011121314151617* 需求：请用LinkedList模拟栈数据结构的集合，并测试* 创建一个类将Linked中的方法封装 public class Stack &#123; private LinkedList list = new LinkedList(); //创建LinkedList对象 public void in(Object obj) &#123; list.addLast(obj); //封装addLast()方法 &#125; public Object out() &#123; return list.removeLast(); //封装removeLast()方法 &#125; public boolean isEmpty() &#123; return list.isEmpty(); //封装isEmpty()方法 &#125; &#125; B:泛型好处 提高安全性(将运行期的错误转换到编译期) 省去强转的麻烦 C:泛型基本使用 &lt;&gt;中放的必须是引用数据类型 D:泛型使用注意事项 前后的泛型必须一致,或者后面的泛型可以省略不写(1.7的新特性菱形泛型) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 public class Demo3_Generic &#123; /** * A:案例演示 * 泛型的由来:通过Object转型问题引入 * 早期的Object类型可以接收任意的对象类型，但是在实际的使用中，会有类型转换的问题。也就存在这隐患，所以Java提供了泛型来解决这个安全问题。 */ public static void main(String[] args) &#123; //demo1(); Tool&lt;String&gt; t = new Tool&lt;&gt;(); //t.show(&quot;abc&quot;); t.show(true); &#125; public static void demo1() &#123; Tool&lt;Student&gt; t = new Tool&lt;&gt;(); //创建工具类对象 t.setObj(new Student(&quot;张三&quot;,23)); //Worker w = (Worker) t.getObj(); //向下转型 //System.out.println(w); &#125; &#125; public class Demo1_Generic &#123; public static void main(String[] args) &#123; //demo1(); //int[] arr = new byte[5]; //数组要保证前后的数据类型一致 //ArrayList&lt;Object&gt; list = new ArrayList&lt;Person&gt;(); //集合的泛型要保证前后的数据类型一致 //ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(); //1.7版本的新特性,菱形泛型 ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(); //泛型最好不要定义成Object,没有意义 list.add(&quot;aaa&quot;); list.add(true); &#125; public static void demo1() &#123; ArrayList&lt;Person&gt; list = new ArrayList&lt;Person&gt;(); // list.add(110); // list.add(true); list.add(new Person(&quot;张三&quot;, 23)); list.add(new Person(&quot;李四&quot;, 24)); Iterator&lt;Person&gt; it = list.iterator(); while(it.hasNext()) &#123; //System.out.println(it.next()); //System.out.println(it.next().getName() + &quot;...&quot; + it.next().getAge());//next方法只能调用一次,如果调用多次会将指针向后移动多次 Person p = it.next(); System.out.println(p.getName() + &quot;...&quot; + p.getAge()); &#125; &#125; &#125; 三种迭代，能否删除元素 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class Demo1_Foreach &#123; /** * * A:增强for概述 * 简化数组和Collection集合的遍历 * B:格式： * for(元素数据类型 变量 : 数组或者Collection集合) &#123; 使用变量即可，该变量就是元素 &#125; * C:案例演示 * 数组，集合存储元素用增强for遍历 * D:好处 * 简化遍历 增强for循环底层依赖的是迭代器(Iterator) */ public static void main(String[] args) &#123; //demo1(); //demo2(); ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); list.add(&quot;b&quot;); list.add(&quot;c&quot;); list.add(&quot;d&quot;); //1,普通for循环删除,索引要-- /*for(int i = 0; i &lt; list.size(); i++) &#123; if(&quot;b&quot;.equals(list.get(i))) &#123; list.remove(i--); //通过索引删除元素 &#125; &#125;*/ //2,迭代器删除 /*Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext()) &#123; if(&quot;b&quot;.equals(it.next())) &#123; //list.remove(&quot;b&quot;); //不能用集合的删除方法,因为迭代过程中如果集合修改会出现并发修改异常 it.remove(); &#125; &#125;*/ /*for(Iterator&lt;String&gt; it2 = list.iterator(); it2.hasNext();) &#123; if(&quot;b&quot;.equals(it2.next())) &#123; //list.remove(&quot;b&quot;); //不能用集合的删除方法,因为迭代过程中如果集合修改会出现并发修改异常 it2.remove(); &#125; &#125;*/ //3,增强for循环,增强for循环不能删除,只能遍历 for (String string : list) &#123; if(&quot;b&quot;.equals(string)) &#123; list.remove(&quot;b&quot;); //删除无效 &#125; &#125; System.out.println(list); &#125; public static void demo2() &#123; ArrayList&lt;Person&gt; list = new ArrayList&lt;&gt;(); list.add(new Person(&quot;张三&quot;, 23)); list.add(new Person(&quot;李四&quot;, 24)); list.add(new Person(&quot;王五&quot;, 25)); list.add(new Person(&quot;赵六&quot;, 26)); for (Person person : list) &#123; System.out.println(person); &#125; &#125; public static void demo1() &#123; int[] arr = &#123;11,22,33,44,55&#125;; for (int i : arr) &#123; System.out.println(i); &#125; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); list.add(&quot;c&quot;); list.add(&quot;d&quot;); for (String string : list) &#123; System.out.println(string); &#125; &#125; &#125; 泛型定义的几个方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class Demo4_Generic &#123; /** * * A:泛型接口概述 * 把泛型定义在接口上 * B:定义格式 * public interface 接口名&lt;泛型类型&gt; * C:案例演示 * 泛型接口的使用 */ public static void main(String[] args) &#123; &#125;&#125; interface Inter&lt;T&gt; &#123; public void show(T t);&#125; /*class Demo implements Inter&lt;String&gt; &#123; //推荐用这种 @Override public void show(String t) &#123; System.out.println(t); &#125; &#125;*/ class Demo&lt;T&gt; implements Inter&lt;T&gt; &#123; //没有必要在实现接口的时候给自己类加泛型 @Override public void show(T t) &#123; System.out.println(t); &#125;&#125; public class Demo5_Generic &#123; /** * * A:泛型通配符&lt;?&gt; * 任意类型，如果没有明确，那么就是Object以及任意的Java类了 * B:? extends E * 向下限定，E及其子类 * C:? super E * 向上限定，E及其父类 */ public static void main(String[] args) &#123; //List&lt;?&gt; list = new ArrayList&lt;Integer&gt;(); //当右边的泛型是不确定时,左边可以指定为? ArrayList&lt;Person&gt; list1 = new ArrayList&lt;&gt;(); list1.add(new Person(&quot;张三&quot;, 23)); list1.add(new Person(&quot;李四&quot;, 24)); list1.add(new Person(&quot;王五&quot;, 25)); ArrayList&lt;Student&gt; list2 = new ArrayList&lt;&gt;(); list2.add(new Student(&quot;赵六&quot;, 26)); list2.add(new Student(&quot;周七&quot;, 27)); list1.addAll(list2); System.out.println(list1); &#125; &#125; 可变参数 1234567891011121314151617181920212223242526272829 /** * * A:可变参数概述 * 定义方法的时候不知道该定义多少个参数 * B:格式 * 修饰符 返回值类型 方法名(数据类型… 变量名)&#123;&#125; * C:注意事项： * 这里的变量其实是一个数组 * 如果一个方法有可变参数，并且有多个参数，那么，可变参数肯定是最后一个 */ public static void main(String[] args) &#123; int[] arr = &#123;11,22,33,44,55&#125;; //print(arr); print(11,22,33,44,55); System.out.println(&quot;---------------&quot;); //print(); &#125; /*public static void print(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125;*/ public static void print(int ... arr) &#123; //可变参数其实是一个数组 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125; 集合转数组,加泛型的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 public static void main(String[] args) &#123; //demo1(); //demo2(); ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); list.add(&quot;c&quot;); list.add(&quot;d&quot;); String[] arr = list.toArray(new String[10]); //当集合转换数组时,数组长度如果是小于等于集合的size时,转换后的数组长度等于集合的size //如果数组的长度大于了size,分配的数组长度就和你指定的长度一样 for (String string : arr) &#123; System.out.println(string); &#125; &#125;数组转换成集合（不能增加或减少元素，其它功能可用; 想要删除和增加可以新建一个集合把来处理数组，自定义增加和删除功能）: public static void demo2() &#123; //int[] arr = &#123;11,22,33,44,55&#125;; //List&lt;int[]&gt; list = Arrays.asList(arr); 基本数据类型的数组转换成集合,会将整个数组当作一个对象转换 //System.out.println(list); Integer[] arr = &#123;11,22,33,44,55&#125;; //将数组转换成集合,数组必须是引用数据类型 List&lt;Integer&gt; list = Arrays.asList(arr); System.out.println(list); &#125; public static void demo1() &#123; String[] arr = &#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;; List&lt;String&gt; list = Arrays.asList(arr); //将数组转换成集合 //list.add(&quot;d&quot;); //不能添加 System.out.println(list); &#125; //删除数组中其中一个元素 public static void testB() &#123; String [] str = &#123;&quot;Java&quot;, &quot;C++&quot;, &quot;Php&quot;, &quot;C#&quot;, &quot;Python&quot;&#125;; for (String elementA:str ) &#123; System.out.print(elementA + &quot; &quot;); &#125; //删除php List&lt;String&gt; list = new ArrayList&lt;String&gt;(); //新建一个集合 for (int i=0; i&lt;str.length; i++) &#123; list.add(str[i]); &#125; list.remove(2); //list.remove(&quot;Php&quot;) System.out.println(); String[] newStr = list.toArray(new String[1]); //返回一个包含所有对象的指定类型的数组 for (String elementB:newStr ) &#123; System.out.print(elementB + &quot; &quot;); &#125; System.out.println(); &#125; //在数组中增加一个元素 public static void testC() &#123; String [] str = &#123;&quot;Java&quot;, &quot;C++&quot;, &quot;Php&quot;, &quot;C#&quot;, &quot;Python&quot;&#125;; for (String elementA:str ) &#123; System.out.print(elementA + &quot; &quot;); &#125; //增加ruby List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (int i=0; i&lt;str.length; i++) &#123; list.add(str[i]); &#125; list.add(2, &quot;ruby&quot;); //list.add(&quot;ruby&quot;) System.out.println(); String[] newStr = list.toArray(new String[1]); //返回一个包含所有对象的指定类型的数组 for (String elementB:newStr ) &#123; System.out.print(elementB + &quot; &quot;); &#125; System.out.println(); &#125;]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-file实战]]></title>
    <url>%2F2018%2F10%2F23%2Fjava-file%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[0x01 _File类递归练习(统计该文件夹大小)需求:1,从键盘接收一个文件夹路径,统计该文件夹大小 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class Test1 &#123; /** * @param args * 需求:1,从键盘接收一个文件夹路径,统计该文件夹大小 * * 从键盘接收一个文件夹路径 * 1,创建键盘录入对象 * 2,定义一个无限循环 * 3,将键盘录入的结果存储并封装成File对象 * 4,对File对象判断 * 5,将文件夹路径对象返回 * * 统计该文件夹大小 * 1,定义一个求和变量 * 2,获取该文件夹下所有的文件和文件夹listFiles(); * 3,遍历数组 * 4,判断是文件就计算大小并累加 * 5,判断是文件夹,递归调用 */ public static void main(String[] args) &#123; //File dir = new File(&quot;F:\\day06&quot;); //System.out.println(dir.length()); //直接获取文件夹的结果是0 File dir = getDir(); System.out.println(getFileLength(dir)); &#125; /* * 从键盘接收一个文件夹路径 * 1,返回值类型File * 2,参数列表无 */ public static File getDir() &#123; //1,创建键盘录入对象 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入一个文件夹路径:&quot;); //2,定义一个无限循环 while(true) &#123; //3,将键盘录入的结果存储并封装成File对象 String line = sc.nextLine(); File dir = new File(line); //4,对File对象判断 if(!dir.exists()) &#123; System.out.println(&quot;您录入的文件夹路径不存在,请输入一个文件夹路径:&quot;); &#125;else if(dir.isFile()) &#123; System.out.println(&quot;您录入的是文件路径,请输入一个文件夹路径:&quot;); &#125;else &#123; //5,将文件夹路径对象返回 return dir; &#125; &#125; &#125; /* * 统计该文件夹大小 * 1,返回值类型long * 2,参数列表File dir */ public static long getFileLength(File dir) &#123; //dir = F:\day06\day07 //1,定义一个求和变量 long len = 0; //2,获取该文件夹下所有的文件和文件夹listFiles(); File[] subFiles = dir.listFiles(); //day07 Demo1_Student.class Demo1_Student.java //3,遍历数组 for (File subFile : subFiles) &#123; //4,判断是文件就计算大小并累加 if(subFile.isFile()) &#123; len = len + subFile.length(); //5,判断是文件夹,递归调用 &#125;else &#123; len = len + getFileLength(subFile); &#125; &#125; return len; &#125;&#125; 0x02 _File类递归练习(删除该文件夹)需求:2,从键盘接收一个文件夹路径,删除该文件夹 12345678910111213141516171819202122232425262728293031323334353637383940public class Test2 &#123; /** * 需求:2,从键盘接收一个文件夹路径,删除该文件夹 * * 删除该文件夹 * 分析: * 1,获取该文件夹下的所有的文件和文件夹 * 2,遍历数组 * 3,判断是文件直接删除 * 4,如果是文件夹,递归调用 * 5,循环结束后,把空文件夹删掉 */ public static void main(String[] args) &#123; File dir = Test1.getDir(); //获取文件夹路径 deleteFile(dir); &#125; /* * 删除该文件夹 * 1,返回值类型 void * 2,参数列表File dir */ public static void deleteFile(File dir) &#123; //1,获取该文件夹下的所有的文件和文件夹 File[] subFiles = dir.listFiles(); //2,遍历数组 for (File subFile : subFiles) &#123; //3,判断是文件直接删除 if(subFile.isFile()) &#123; subFile.delete(); //4,如果是文件夹,递归调用 &#125;else &#123; deleteFile(subFile); &#125; &#125; //5,循环结束后,把空文件夹删掉 dir.delete(); &#125;&#125; 0x03 _File类递归练习(拷贝)需求:3,从键盘接收两个文件夹路径,把其中一个文件夹中(包含内容)拷贝到另一个文件夹中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Test3 &#123; /** * 需求:3,从键盘接收两个文件夹路径,把其中一个文件夹中(包含内容)拷贝到另一个文件夹中 * * 把其中一个文件夹中(包含内容)拷贝到另一个文件夹中 * 分析: * 1,在目标文件夹中创建原文件夹 * 2,获取原文件夹中所有的文件和文件夹,存储在File数组中 * 3,遍历数组 * 4,如果是文件就用io流读写 * 5,如果是文件夹就递归调用 * @throws IOException */ public static void main(String[] args) throws IOException &#123; File src = Test1.getDir(); File dest = Test1.getDir(); if(src.equals(dest)) &#123; System.out.println(&quot;目标文件夹是源文件夹的子文件夹&quot;); &#125;else &#123; copy(src,dest); &#125; &#125; /* * 把其中一个文件夹中(包含内容)拷贝到另一个文件夹中 * 1,返回值类型void * 2,参数列表File src,File dest */ public static void copy(File src, File dest) throws IOException &#123; //1,在目标文件夹中创建原文件夹 File newDir = new File(dest, src.getName()); newDir.mkdir(); //2,获取原文件夹中所有的文件和文件夹,存储在File数组中 File[] subFiles = src.listFiles(); //3,遍历数组 for (File subFile : subFiles) &#123; //4,如果是文件就用io流读写 if(subFile.isFile()) &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(subFile)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(new File(newDir,subFile.getName()))); int b; while((b = bis.read()) != -1) &#123; bos.write(b); &#125; bis.close(); bos.close(); //5,如果是文件夹就递归调用 &#125;else &#123; copy(subFile,newDir); &#125; &#125; &#125;&#125; 0x04 _File类递归练习(按层级打印)需求:4,从键盘接收一个文件夹路径,把文件夹中的所有文件以及文件夹的名字按层级打印, 例如: - aaa是文件夹,里面有bbb.txt,ccc.txt,ddd.txt这些文件,有eee这样的文件夹,eee中有fff.txt和ggg.txt,打印出层级来 - aaa bbb.txt ccc.txt ddd.txt eee fff.txt ggg.txt 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Test4 &#123; /** * 需求:4,从键盘接收一个文件夹路径,把文件夹中的所有文件以及文件夹的名字按层级打印, 例如: * 把文件夹中的所有文件以及文件夹的名字按层级打印 * 分析: * 1,获取所有文件和文件夹,返回的File数组 * 2,遍历数组 * 3,无论是文件还是文件夹,都需要直接打印 * 4,如果是文件夹,递归调用 * day07 * day08 * xxx.jpg * yyy.txt * Demo1_Consturctor.class * Demo1_Consturctor.java * Demo1_Student.class * Demo1_Student.java */ public static void main(String[] args) &#123; File dir = Test1.getDir(); //获取文件夹路径 printLev(dir,0); &#125; public static void printLev(File dir,int lev) &#123; //1,把文件夹中的所有文件以及文件夹的名字按层级打印 File[] subFiles = dir.listFiles(); //2,遍历数组 for (File subFile : subFiles) &#123; for(int i = 0; i &lt;= lev; i++) &#123; System.out.print(&quot;\t&quot;); &#125; //3,无论是文件还是文件夹,都需要直接打印 System.out.println(subFile); //4,如果是文件夹,递归调用 if(subFile.isDirectory()) &#123; //printLev(subFile,lev + 1); printLev(subFile,++lev); &#125; &#125; &#125;&#125; 0x05 _递归练习(斐波那契数列)不死神兔 * 故事得从西元1202年说起，话说有一位意大利青年，名叫斐波那契。 * 在他的一部著作中提出了一个有趣的问题：假设一对刚出生的小兔一个月后就能长成大兔，再过一个月就能生下一对小兔，并且此后每个月都生一对小兔，一年内没有发生死亡， * 问：一对刚出生的兔子，一年内繁殖成多少对兔子? * 1 1 2 3 5 8 13 * 第一个月一对小兔子 1 * 第二个月一对大兔子 1 * 第三个月一对大兔子生了一对小兔子 2 * 第四个月一对大兔子生了一对小兔子 * 一对小兔子长成大兔子 3 * 第五个月两对大兔子生两对小兔子 * 一对小兔子长成大兔子 5 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Test5 &#123; /** * * 不死神兔 * 故事得从西元1202年说起，话说有一位意大利青年，名叫斐波那契。 * 在他的一部著作中提出了一个有趣的问题：假设一对刚出生的小兔一个月后就能长成大兔，再过一个月就能生下一对小兔，并且此后每个月都生一对小兔，一年内没有发生死亡， * 问：一对刚出生的兔子，一年内繁殖成多少对兔子? * 1 1 2 3 5 8 13 21 * 1 = fun(1) * 1 = fun(2) * 2 = fun(1) + fun(2) * 3 = fun(2) + fun(3) */ public static void main(String[] args) &#123; //demo1(); System.out.println(fun(8)); &#125; public static void demo1() &#123; //用数组做不死神兔 int[] arr = new int[8]; //数组中第一个元素和第二个元素都为1 arr[0] = 1; arr[1] = 1; //遍历数组对其他元素赋值 for(int i = 2; i &lt; arr.length; i++) &#123; arr[i] = arr[i - 2] + arr[i - 1]; &#125; //如何获取最后一个数 System.out.println(arr[arr.length - 1]); &#125; /* * 用递归求斐波那契数列 */ public static int fun(int num) &#123; if(num == 1 || num == 2) &#123; return 1; &#125;else &#123; return fun(num - 2) + fun(num - 1); &#125; &#125;&#125; 0x06 _递归练习(1000的阶乘所有零和尾部零的个数)需求:求出1000的阶乘所有零和尾部零的个数,不用递归做 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Test6 &#123; /** * @param args * 需求:求出1000的阶乘所有零和尾部零的个数,不用递归做 */ public static void main(String[] args) &#123; /*int result = 1; for(int i = 1; i &lt;= 1000; i++) &#123; result = result * i; &#125; System.out.println(result); //因为1000的阶乘远远超出了int的取值范围 */ //demo1(); demo2(); &#125; public static void demo2() &#123; //获取1000的阶乘尾部有多少个零 BigInteger bi1 = new BigInteger(&quot;1&quot;); for(int i = 1; i &lt;= 1000; i++) &#123; BigInteger bi2 = new BigInteger(i+&quot;&quot;); bi1 = bi1.multiply(bi2); //将bi1与bi2相乘的结果赋值给bi1 &#125; String str = bi1.toString(); //获取字符串表现形式 StringBuilder sb = new StringBuilder(str); str = sb.reverse().toString(); //链式编程 int count = 0; //定义计数器 for(int i = 0; i &lt; str.length(); i++) &#123; if(&apos;0&apos; != str.charAt(i)) &#123; break; &#125;else &#123; count++; &#125; &#125; System.out.println(count); &#125; public static void demo1() &#123; //求1000的阶乘中所有的零 BigInteger bi1 = new BigInteger(&quot;1&quot;); for(int i = 1; i &lt;= 1000; i++) &#123; BigInteger bi2 = new BigInteger(i+&quot;&quot;); bi1 = bi1.multiply(bi2); //将bi1与bi2相乘的结果赋值给bi1 &#125; String str = bi1.toString(); //获取字符串表现形式 int count = 0; for(int i = 0; i &lt; str.length(); i++) &#123; if(&apos;0&apos; == str.charAt(i)) &#123; //如果字符串中出现了0字符 count++; //计数器加1 &#125; &#125; System.out.println(count); &#125;&#125; 0x07 _递归练习(1000的阶乘尾部零的个数)需求:求出1000的阶乘尾部零的个数,用递归做 1234567891011121314151617181920212223public class Test7 &#123; /** * @param args * 需求:求出1000的阶乘尾部零的个数,用递归做 * 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100...1000 1000 / 5 = 200 * 5 * 5 5 * 5 * 2 5 * 5 * 3 5 * 5 * 4 5 * 5 * 5 5 * 5 * 6 200 / 5 = 40 * 5 * 5 * 5 * 1 5 * 5 * 5 * 2 5 * 5 * 5 * 3 5 * 5 * 5 * 4 5 * 5 * 5 * 5 5 * 5 * 5 * 6 5 * 5 * 5 * 7 5 * 5 * 5 * 8 40 / 5 = 8 5 * 5 * 5 * 5 8 / 5 = 1 */ public static void main(String[] args) &#123; System.out.println(fun(1000)); &#125; public static int fun(int num) &#123; if(num &gt; 0 &amp;&amp; num &lt; 5) &#123; return 0; &#125;else &#123; return num / 5 + fun(num / 5); &#125; &#125;&#125; 0x08 _集合练习(约瑟夫环)幸运数字 12345678910111213141516171819202122232425262728293031323334353637public class Test8 &#123; /** * @param args * 约瑟夫环 * * 幸运数字 */ public static void main(String[] args) &#123; System.out.println(getLucklyNum(8)); &#125; /* * 获取幸运数字 * 1,返回值类型int * 2,参数列表int num */ public static int getLucklyNum(int num) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); //创建集合存储1到num的对象 for(int i = 1; i &lt;= num; i++) &#123; list.add(i); //将1到num存储在集合中 &#125; int count = 1; //用来数数的,只要是3的倍数就杀人 for(int i = 0; list.size() != 1; i++) &#123; //只要集合中人数超过1,就要不断的杀 if(i == list.size()) &#123; //如果i增长到集合最大的索引+1时 i = 0; //重新归零 &#125; if(count % 3 == 0) &#123; //如果是3的倍数 list.remove(i--); //就杀人 &#125; count++; &#125; return list.get(0); &#125;&#125;]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-io字节流3(序列，内存，输入输出)]]></title>
    <url>%2F2018%2F09%2F28%2Fjava-io%E5%AD%97%E8%8A%82%E6%B5%813%2F</url>
    <content type="text"><![CDATA[0x01 IO流(序列流)什么是序列流* 序列流可以把多个字节输入流整合成一个, 从序列流中读取数据时, 将从被整合的第一个流开始读, 读完一个之后继续读第二个, 以此类推.使用方式整合两个: SequenceInputStream(InputStream, InputStream) 123456789101112FileInputStream fis1 = new FileInputStream(&quot;a.txt&quot;); //创建输入流对象,关联a.txtFileInputStream fis2 = new FileInputStream(&quot;b.txt&quot;); //创建输入流对象,关联b.txtSequenceInputStream sis = new SequenceInputStream(fis1, fis2); //将两个流整合成一个流FileOutputStream fos = new FileOutputStream(&quot;c.txt&quot;); //创建输出流对象,关联c.txtint b;while((b = sis.read()) != -1) &#123; //用整合后的读 fos.write(b); //写到指定文件上&#125;sis.close();fos.close(); 整合多个: SequenceInputStream(Enumeration) 1234567891011121314151617FileInputStream fis1 = new FileInputStream(&quot;a.txt&quot;); //创建输入流对象,关联a.txtFileInputStream fis2 = new FileInputStream(&quot;b.txt&quot;); //创建输入流对象,关联b.txtFileInputStream fis3 = new FileInputStream(&quot;c.txt&quot;); //创建输入流对象,关联c.txtVector&lt;InputStream&gt; v = new Vector&lt;&gt;(); //创建vector集合对象v.add(fis1); //将流对象添加v.add(fis2);v.add(fis3);Enumeration&lt;InputStream&gt; en = v.elements(); //获取枚举引用SequenceInputStream sis = new SequenceInputStream(en); //传递给SequenceInputStream构造FileOutputStream fos = new FileOutputStream(&quot;d.txt&quot;);int b;while((b = sis.read()) != -1) &#123; fos.write(b);&#125;sis.close();fos.close(); 0x02 IO流(内存输出流)what’s it?* 该输出流可以向内存中写数据, 把内存当作一个缓冲区, 写出之后可以一次性获取出所有数据使用方式* 创建对象: new ByteArrayOutputStream() * 写出数据: write(int), write(byte[]) * 获取数据: toByteArray()1234567891011FileInputStream fis = new FileInputStream(&quot;a.txt&quot;);ByteArrayOutputStream baos = new ByteArrayOutputStream();int b;while((b = fis.read()) != -1) &#123; baos.write(b);&#125;//byte[] newArr = baos.toByteArray(); //将内存缓冲区中所有的字节存储在newArr中//System.out.println(new String(newArr));System.out.println(baos);fis.close(); 案例 定义一个文件输入流,调用read(byte[] b)方法,将a.txt文件中的内容打印出来(byte数组大小限制为5)123456789FileInputStream fis = new FileInputStream(&quot;a.txt&quot;); //创建字节输入流,关联a.txtByteArrayOutputStream baos = new ByteArrayOutputStream(); //创建内存输出流byte[] arr = new byte[5]; //创建字节数组,大小为5int len;while((len = fis.read(arr)) != -1) &#123; //将文件上的数据读到字节数组中 baos.write(arr, 0, len); //将字节数组的数据写到内存缓冲区中&#125;System.out.println(baos); //将内存缓冲区的内容转换为字符串打印fis.close(); 0x03 IO流(对象操作流)什么是对象操作流* 该流可以将一个对象写出, 或者读取一个对象到程序中. 也就是执行了序列化和反序列化的操作.使用方式写出: new ObjectOutputStream(OutputStream), writeObject() 12345678910111213141516171819202122public class Demo3_ObjectOutputStream &#123; /** * @param args * @throws IOException * 将对象写出,序列化 */ public static void main(String[] args) throws IOException &#123; Person p1 = new Person(&quot;张三&quot;, 23); Person p2 = new Person(&quot;李四&quot;, 24);// FileOutputStream fos = new FileOutputStream(&quot;e.txt&quot;);// fos.write(p1);// FileWriter fw = new FileWriter(&quot;e.txt&quot;);// fw.write(p1); //无论是字节输出流,还是字符输出流都不能直接写出对象 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;e.txt&quot;));//创建对象输出流 oos.writeObject(p1); oos.writeObject(p2); oos.close(); &#125;&#125; 读取: new ObjectInputStream(InputStream), readObject() 12345678910111213141516171819public class Demo3_ObjectInputStream &#123; /** * @param args * @throws IOException * @throws ClassNotFoundException * @throws FileNotFoundException * 读取对象,反序列化 */ public static void main(String[] args) throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;e.txt&quot;)); Person p1 = (Person) ois.readObject(); Person p2 = (Person) ois.readObject(); System.out.println(p1); System.out.println(p2); ois.close(); &#125;&#125; 对象操作流优化将对象存储在集合中写出 123456789101112131415Person p1 = new Person(&quot;张三&quot;, 23);Person p2 = new Person(&quot;李四&quot;, 24);Person p3 = new Person(&quot;马哥&quot;, 18);Person p4 = new Person(&quot;辉哥&quot;, 20);ArrayList&lt;Person&gt; list = new ArrayList&lt;&gt;();list.add(p1);list.add(p2);list.add(p3);list.add(p4);ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;f.txt&quot;));oos.writeObject(list); //写出集合对象oos.close(); 读取到的是一个集合对象 12345678ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;f.txt&quot;)); ArrayList&lt;Person&gt; list = (ArrayList&lt;Person&gt;)ois.readObject(); //泛型在运行期会被擦除,索引运行期相当于没有泛型 //想去掉黄色可以加注解 @SuppressWarnings(&quot;unchecked&quot;) for (Person person : list) &#123; System.out.println(person); &#125;ois.close(); 注意* 要写出的对象必须实现Serializable接口才能被序列化 * 不用必须加id号0x04 IO流(打印流的概述和特点)什么是打印流* 该流可以很方便的将对象的toString()结果输出, 并且自动加上换行, 而且可以使用自动刷出的模式 * System.out就是一个PrintStream, 其默认向控制台输出信息123456PrintStream ps = System.out;ps.println(97); //其实底层用的是Integer.toString(x),将x转换为数字字符串打印ps.println(&quot;xxx&quot;);ps.println(new Person(&quot;张三&quot;, 23));Person p = null;ps.println(p); //如果是null,就返回null,如果不是null,就调用对象的toString() 使用方式* 打印: print(), println() * 自动刷出: PrintWriter(OutputStream out, boolean autoFlush, String encoding) * 打印流只操作数据目的12345PrintWriter pw = new PrintWriter(new FileOutputStream(&quot;g.txt&quot;), true);pw.write(97);pw.print(&quot;大家好&quot;);pw.println(&quot;你好&quot;); //自动刷出,只针对的是println方法pw.close(); 0x05 IO流(标准输入输出流)什么是标准输入输出流* System.in是InputStream, 标准输入流, 默认可以从键盘输入读取字节数据 * System.out是PrintStream, 标准输出流, 默认可以向Console中输出字符和字节数据修改标准输入输出流* 修改输入流: System.setIn(InputStream) * 修改输出流: System.setOut(PrintStream)123456789101112System.setIn(new FileInputStream(&quot;a.txt&quot;)); //修改标准输入流System.setOut(new PrintStream(&quot;b.txt&quot;)); //修改标准输出流InputStream in = System.in; //获取标准输入流PrintStream ps = System.out; //获取标准输出流int b;while((b = in.read()) != -1) &#123; //从a.txt上读取数据 ps.write(b); //将数据写到b.txt上&#125;in.close();ps.close(); 修改标准输入输出流拷贝图片123456789101112131415System.setIn(new FileInputStream(&quot;IO图片.png&quot;)); //改变标准输入流System.setOut(new PrintStream(&quot;copy.png&quot;)); //改变标准输出流InputStream is = System.in; //获取标准输入流PrintStream ps = System.out; //获取标准输出流int len;byte[] arr = new byte[1024 * 8];while((len = is.read(arr)) != -1) &#123; ps.write(arr, 0, len);&#125;is.close();ps.close(); 0x06 IO流(两种方式实现键盘录入)BufferedReader的readLine方法* BufferedReader br = new BufferedReader(new InputStreamReader(System.in));1234BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); //InputStreamReader转换流String line = br.readLine();System.out.println(line);br.close(); Scanner1234Scanner sc = new Scanner(System.in);String line = sc.nextLine();System.out.println(line);sc.close(); 0x07 IO流(随机访问流概述和读写数据)随机访问流概述* RandomAccessFile概述 * RandomAccessFile类不属于流，是Object类的子类。但它融合了InputStream和OutputStream的功能。 * 支持对随机访问文件的读取和写入。read(),write(),seek()1234567RandomAccessFile raf = new RandomAccessFile(&quot;g.txt&quot;, &quot;rw&quot;);//raf.write(97);//int x = raf.read();//System.out.println(x);raf.seek(0); //在指定位置设置指针raf.write(98);raf.close(); 0x08 IO流(数据输入输出流)什么是数据输入输出流* DataInputStream, DataOutputStream可以按照基本数据类型大小读写数据 * 例如按Long大小写出一个数字, 写出时该数据占8字节. 读取的时候也可以按照Long类型读取, 一次读取8个字节.使用方式DataOutputStream(OutputStream), writeInt(), writeLong() 12345DataOutputStream dos = new DataOutputStream(new FileOutputStream(&quot;b.txt&quot;));dos.writeInt(997);dos.writeInt(998);dos.writeInt(999);dos.close(); DataInputStream(InputStream), readInt(), readLong() 12345678DataInputStream dis = new DataInputStream(new FileInputStream(&quot;b.txt&quot;));int x = dis.readInt();int y = dis.readInt();int z = dis.readInt();System.out.println(x);System.out.println(y);System.out.println(z);dis.close(); 0x09 IO流(Properties的概述和作为Map集合的使用)Properties的概述* Properties 类表示了一个持久的属性集。 * Properties 可保存在流中或从流中加载。 * 属性列表中每个键及其对应值都是一个字符串。 Properties的特殊功能* public Object setProperty(String key,String value) * public String getProperty(String key) * public Enumeration&lt;String&gt; stringPropertyNames() * Properties的load()和store()功能案例演示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.util.Enumeration;import java.util.Properties;public class Demo10_Properties &#123; /** * @param args * Properties是Hashtable的子类 * @throws IOException * @throws FileNotFoundException */ //* Properties的load()和store()功能 public static void main(String[] args) throws FileNotFoundException, IOException &#123; //demo1(); //demo2(); Properties prop = new Properties(); prop.load(new FileInputStream(&quot;config.properties&quot;)); //将文件上的键值对读取到集合中 prop.setProperty(&quot;tel&quot;, &quot;18912345678&quot;); prop.store(new FileOutputStream(&quot;config.properties&quot;), null);//第二个参数是对列表参数的描述,可以给值,也可以给null System.out.println(prop); &#125; //* Properties的特殊功能 public static void demo2() &#123; Properties prop = new Properties(); prop.setProperty(&quot;name&quot;, &quot;张三&quot;); prop.setProperty(&quot;tel&quot;, &quot;18912345678&quot;); //System.out.println(prop); Enumeration&lt;String&gt; en = (Enumeration&lt;String&gt;) prop.propertyNames(); while(en.hasMoreElements()) &#123; String key = en.nextElement(); //获取Properties中的每一个键 String value = prop.getProperty(key); //根据键获取值 System.out.println(key + &quot;=&quot;+ value); &#125; &#125; //* Properties作为Map集合的使用 public static void demo1() &#123; Properties prop = new Properties(); prop.put(&quot;abc&quot;, 123); System.out.println(prop); &#125;&#125;]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[env-docker使用]]></title>
    <url>%2F2018%2F09%2F26%2Fenv-docker%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[docker安装dockerAdd Docker PGP key: 1curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add - Configure Docker APT repository: 1echo &apos;deb https://download.docker.com/linux/debian stretch stable&apos; &gt; /etc/apt/sources.list.d/docker.list Update APT: 1apt-get update Install DockerIf you had older versions of Docker installed, uninstall them: 1apt-get remove docker docker-engine docker.io Install Docker: 1apt-get install docker-ce Test: 1docker run hello-world After installation, Docker service will be started, but not enabled (i.e. it will not be started automatically after reboot). To start it: 1systemctl start docker To start Docker automatically upon reboot (do it on your own risk!): 1systemctl enable docker 创建/使用dockerzookeeper dockerfile 12345678910111213141516FROM java:latestARG MIRROR=http://mirrors.aliyun.com/ARG VERSION=3.4.14LABEL name=&quot;zookeeper&quot; version=$VERSIONRUN wget $MIRROR/apache/zookeeper/zookeeper-$VERSION/zookeeper-$VERSION.tar.gz \ &amp;&amp; tar -zxvf zookeeper-$VERSION.tar.gz -C /opt/ \ &amp;&amp; mv /opt/zookeeper-$VERSION /opt/zookeeper \ &amp;&amp; cp /opt/zookeeper/conf/zoo_sample.cfg /opt/zookeeper/conf/zoo.cfg \ &amp;&amp; mkdir -p /tmp/zookeeperEXPOSE 2181WORKDIR /opt/zookeeperVOLUME [&quot;/opt/zookeeper/conf&quot;, &quot;/tmp/zookeeper&quot;]ENTRYPOINT [&quot;/opt/zookeeper/bin/zkServer.sh&quot;]CMD [&quot;start-foreground&quot;] kafka dockerfile 1234567891011121314151617FROM java:latest ARG MIRROR=http://mirror.bit.edu.cn/ARG SCALA_VERSION=2.11ARG KAFKA_VERSION=2.2.1LABEL name=&quot;kafka&quot; version=$VERSIONRUN wget $MIRROR/apache/kafka/$KAFKA_VERSION/kafka_$SCALA_VERSION-$KAFKA_VERSION.tgz \ &amp;&amp; tar -zxvf kafka_$SCALA_VERSION-$KAFKA_VERSION.tgz -C /opt/ &amp;&amp; mv /opt/kafka_$SCALA_VERSION-$KAFKA_VERSION /opt/kafka \ &amp;&amp; sed -i &apos;s/num.partitions.*$/num.partitions=3/g&apos; /opt/kafka/config/server.properties \ &amp;&amp; sed -i &apos;s/zookeeper.connect=.*$/zookeeper.connect=zookeeper:2181/g&apos; /opt/kafka/config/server.properties EXPOSE 9092ENTRYPOINT [&quot;/opt/kafka/bin/kafka-server-start.sh&quot;]CMD [&quot;/opt/kafka/config/server.properties&quot;] 构建容器 12docker build -f zookeeper.Dockerfile -t zookeeper:3.4.14 .docker build -f kafka.Dockerfile -t kafka:2.2.1 . 启动容器 12docker run --name zookeeper -itd -p2181:2181 zookeeper:3.4.14docker run --name kafka -itd -p9092:9092 --link zookeeper kafka:2.2.1 查看启动状况 12docker logs zookeeperdocker logs kafka 验证 12345678docker exec -it kafka bashcd /opt/kafkasource /root/.bash_profilebin/kafka-topics.sh --create --zookeeper zookeeper:2181 --replication-factor 1 --partitions 3 --topic test1bin/kafka-topics.sh --create --zookeeper zookeeper:2181 --replication-factor 1 --partitions 3 --topic test2 bin/kafka-topics.sh --describe --topic test1 --zookeeper zookeeper:2181bin/kafka-topics.sh --describe --topic test2 --zookeeper zookeeper:2181bin/kafka-topics.sh --list --zookeeper zookeeper:2181]]></content>
      <categories>
        <category>misc</category>
      </categories>
      <tags>
        <tag>env</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-element搭建]]></title>
    <url>%2F2018%2F09%2F25%2Fvue-element%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[0x01 安装脚手架123456apt-get install nodeapt-get install npm npm install -g vuenpm install -g vue-cli vue init webpack xxcd xx 0x02 安装组件安装element-ui, -S 是你发布之后还依赖的东西 1npm install element-ui -S 安装element-ui, –save-dev 是你开发时候依赖的东西 1npm install element-ui --save-dev 0x03 目录结构src的目录结构，项目进口的Html页面在根目录的index.html├── App.vue app挂在的单页├── assets 静态资源文件│ └── logo.png├── axios 请求组件│ └── api.js├── components 组件设置│ ├── BaseCharts.vue├── main.js 主入口文件├── mock 模拟数据模块│ └── mock.js├── router 路由模块│ └── index.js├── store 全局配置模块├── utils 工具└── views 模块的页面文件 ├── helloworld.vue └── layout.vue 0x04 建立路由路由js中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143import Vue from &apos;vue&apos; //导入vueimport Router from &apos;vue-router&apos; //导入路由import Layout from &apos;@/views/layout&apos; //导入组件; @代表根目录Vue.use(Router) //vue使用路由const login = &#123;template: &apos;&lt;div&gt;login 页面&lt;/div&gt;&apos;&#125; //自定义常量，作为常用页面const error404 = &#123;template: &apos;&lt;div&gt;404错误页面&lt;/div&gt;&apos;&#125;export default new Router(&#123; // export 导出路由模块 mode: &apos;history&apos;, // 去掉Url签名的#号 routes: [ &#123; path: &apos;/&apos;, // 主目录，配合&lt;transition name=&quot;move&quot; mode=&quot;out-in&quot;&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt;才可以显示子组件 component: Layout, // 挂载的组件 children:[ // 子组件 &#123; path: &apos;/dashboard&apos;, name: &apos;dashboard&apos;, component: login &#125;, &#123; path: &apos;/asset&apos;, name: &apos;asset&apos;, component: error404 &#125;, //&#123; // path: &apos;/scan/task&apos;, // name: &apos;scanTask&apos;, // component: resolve =&gt; require([&apos;../views/ScanPlugin.vue&apos;], resolve) //&#125; ] &#125; ]&#125;)动态路由：&#123; path:&quot;/two:id&quot;, component:&#123;template:&quot;#b&quot;&#125;,&#125;,编程式导航：router.push(location)想要导航到不同的 URL，则使用 router.push 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。当你点击 &lt;router-link&gt; 时，这个方法会在内部调用，所以说，点击 &lt;router-link :to=&quot;...&quot;&gt; 等同于调用 router.push(...)。该方法的参数可以是一个字符串路径，或者一个描述地址的对象。例如：// 字符串router.push(&apos;home&apos;)// 对象router.push(&#123; path: &apos;home&apos; &#125;)// 命名的路由router.push(&#123; name: &apos;user&apos;, params: &#123; userId: 123 &#125;&#125;)// 带查询参数，变成 /register?plan=privaterouter.push(&#123; path: &apos;register&apos;, query: &#123; plan: &apos;private&apos; &#125;&#125;)命名路由：我们直接在路由下添加一个 name 即可.var routes = [ &#123; path:&quot;/one&quot;, name:&quot;one&quot;, component:&#123;template:&quot;#a&quot;&#125; &#125;, &#123; path:&quot;/two&quot;, name:&quot;two&quot;, component:&#123;template:&quot;#b&quot;&#125;, &#125;,]要链接到一个命名路由，可以给 router-link 的 to 属性传一个对象：&lt;router-link :to=&quot;&#123; name: &apos;one&apos;&#125;&quot;&gt;User&lt;/router-link&gt;命名视图：当我们的视图如上时,我们会发现每一个路由被渲染了两次,所以我们需要为视图命名&lt;router-view name=&quot;a&quot;&gt;&lt;/router-view&gt;&lt;router-view name=&quot;b&quot;&gt;&lt;/router-view&gt;var Foo = &#123; template: &apos;&lt;div&gt;foo&lt;/div&gt;&apos; &#125;var Bar = &#123; template: &apos;&lt;div&gt;bar&lt;/div&gt;&apos; &#125;var routes = [ &#123; path:&quot;/one&quot;, name:&quot;one&quot;, components:&#123; a:Foo, b:Bar &#125; &#125;, ]重定向和别名：routes: [ &#123; path: &apos;/a&apos;, redirect: &apos;/b&apos; &#125; ]routes: [ &#123; path: &apos;/a&apos;, component: A, alias: &apos;/b&apos; &#125; ]通过&lt;router-link&gt; 标签中的to传参这种传参方法的基本语法：&lt;router-link :to=&quot;&#123;name:xxx,params:&#123;key:value&#125;&#125;&quot;&gt;valueString&lt;/router-link&gt;&lt;router-link to=&quot;/params/198/jspang website is very good&quot;&gt;params&lt;/router-link&gt;|在/src/router/index.js文件里配置路由&#123; path:&apos;/params/:newsId/:newsTitle&apos;, component:Params&#125;全局钩子：使用 router.beforeEach 注册一个全局的 before 钩子：var router = new VueRouter(&#123; ... &#125;)router.beforeEach(function(to,from,next)&#123;&#125;);当一个导航触发时，全局的 before 钩子按照创建顺序调用。钩子是异步解析执行，此时导航在所有钩子 resolve 完之前一直处于 等待中。每个钩子方法接收三个参数：to: Route: 即将要进入的目标 路由对象from: Route: 当前导航正要离开的路由next: Function: 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数。next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。next(&apos;/&apos;) 或者 next(&#123; path: &apos;/&apos; &#125;): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。var Foo = &#123; template: `...`, beforeRouteEnter:function(to, from, next) &#123; // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！获取组件实例 `this` // 因为当钩子执行前，组件实例还没被创建 &#125;, beforeRouteLeave:function(to, from, next) &#123; // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` &#125;&#125; 静态页面中： 123456789101112131415161718&lt; router-link &gt; 默认会被渲染成一个 &lt;a&gt; 标签 &gt;&gt;&gt;to=&quot;&quot;为我们定义的路由&lt; router-view &gt; 路由匹配到的组件将渲染在这里&lt;div&gt; user:&#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;this.$router.go(-1)//跳转到上一次浏览的页面this.$router.replace(&apos;/menu&apos;)//指定跳转的地址this.$router.replace(&#123;name:&apos;menuLink&apos;&#125;)// 指定跳转路由的名字下this.$router.push(&apos;/menu&apos;)通过push进行跳转this.$router.push(&#123;name:&apos;menuLink&apos;&#125;)通过push进行跳转路由的名字下&lt;!-- v-for=&quot;(issue,index) in $router.options.routes&quot; v-if=&quot;issue.name === $store.state.leftNavState&quot; $route.path --&gt;watch: &#123; &apos;$route&apos;: function(to, from)&#123; // 路由改变时执行 // console.info(&quot;to.path:&quot; + to.path); &#125;&#125; 0x05 新建单页123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388&lt;template&gt;&lt;div&gt; &lt;el-container&gt; &lt;el-footer&gt;©2018 0x00安全平台 意见反馈 京ICP证1号 京公网安备1号 &lt;a href=&quot;http://0x726f6f74.github.io&quot; target=&quot;_blank&quot; style=&quot;text-decoration:none&quot;&gt;0x00技术中心&lt;/a&gt;&lt;/el-footer&gt; &lt;/el-container&gt; &lt;transition name=&quot;move&quot; mode=&quot;out-in&quot;&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;//import &#123; Navbar, Sidebar, TagsView &#125; from &apos;./components&apos;export default &#123; name: &apos;Layout&apos;, data() &#123; return &#123; msgOfp: false &#125;; &#125;, methods: &#123; &#125;, components: &#123; // AppMain &#125;&#125;&lt;/script&gt;&lt;style scoped&gt; /* scoped是限制，在这个页面使用；不会修改全局样式 */.el-container &#123; margin: 0%; padding: 0%;&#125;.el-footer &#123; text-align: left; line-height: 60px; color: #999; font-size: 12px;&#125;&lt;/style&gt;其中包含了时间转化和 异步请求的列子：&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/bootstrap.min.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/style.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/font-awesome.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;//at.alicdn.com/t/font_696758_e63hc2ltocg14i.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/element-ui.css&quot; /&gt;&lt;style&gt;.chart-container &#123; width: 100%; /* float: left; */&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;wrapper&quot;&gt; &lt;div id=&quot;page-wrapper&quot; class=&quot;gray-bg&quot;&gt; &lt;div class=&quot;row wrapper border-bottom white-bg page-heading&quot;&gt; &lt;div class=&quot;col-lg-10&quot;&gt; &lt;h2&gt;标题&lt;/h2&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;wrapper wrapper-content&quot;&gt; &lt;!-- 第七个界面 --&gt; &lt;section class=&quot;chart-container&quot; &gt; &lt;el-row&gt; &lt;el-col :span=&quot;24&quot; &gt; &lt;h3&gt;WAF趋势：&lt;/h3&gt; &lt;/el-col&gt; &lt;el-col :span=&quot;24&quot;&gt; &lt;div id=&quot;chartTrend&quot; style=&quot;width:100%; height:480px; margin-top: 20px;&quot;&gt;&lt;/div&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/section&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-2.1.1.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;config.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/plugins/jquery.metisMenu.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/jq-common.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/echarts.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/element-ui.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/common.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vdata = new Vue(&#123; el: &apos;#wrapper&apos;, data: function () &#123; return &#123; showCluster: false, data: &apos;&apos;, checkSign: &apos;&apos;, //定义需要显示的数据变量 chartData: &#123; &quot;xData&quot;: [], &quot;waf_log&quot;: [], &quot;waf_deny&quot;: [], &quot;waf_req&quot;: [], &#125;, option: &#123; title: &#123; text: &apos;&apos; &#125;, tooltip: &#123; trigger: &apos;axis&apos; &#125;, toolbox: &#123; x:&apos;80%&apos;, y:&apos;top&apos;, show : true, feature : &#123; mark : &#123;show: true&#125;, saveAsImage : &#123;show: true&#125;, dataView:&#123;show: true&#125;, &#125; &#125;, legend: &#123; data: [&apos;waf_log&apos;, &apos;waf_deny&apos;, &apos;waf_req&apos;] &#125;, grid: &#123; left: &apos;3%&apos;, right: &apos;4%&apos;, bottom: &apos;3%&apos;, containLabel: true &#125;, xAxis:&#123; type: &apos;category&apos;, boundaryGap: false, data:[] &#125;, yAxis : [ &#123; type : &apos;value&apos; &#125; ], series : [ &#123; name: &apos;waf_log&apos;, type: &apos;line&apos;, // stack: &apos;总量&apos;, 需要注释，不然会导致y轴对应的值不对应 data: [] &#125;, &#123; name: &apos;waf_deny&apos;, type: &apos;line&apos;, // stack: &apos;总量&apos;, data: [] &#125;, &#123; name: &apos;waf_req&apos;, type: &apos;line&apos;, stack: &apos;总量&apos;, data: [] &#125;, ] &#125;, &#125; &#125;, watch: &#123; checkSign: function (val) &#123; if (val == &quot;sign error&quot;) &#123; window.location = &apos;/login.html&apos;; &#125; &#125; &#125;, mounted() &#123; this.drawLineChart(); &#125;, updated: function () &#123; &#125;, destroyed() &#123; this.showCluster = false; &#125;, methods: &#123; loadingRules() &#123; var that = this; $.post(URL + &apos;/api/v2/dict_json&apos;, &#123; action: &apos;reload&apos;, &#125;, function (data) &#123; if (data.code == &apos;ok&apos;) &#123; that.$notify(&#123; type: &apos;success&apos;, title: &apos;提示&apos;, message: &apos;载入成功&apos;, duration: 4000 &#125;); &#125; else &#123; if (data.msg == &quot;sign error&quot;) &#123; that.checkSign = &quot;sign error&quot;; &#125; that.$notify(&#123; type: &apos;warning&apos;, title: &apos;提示&apos;, message: data.msg, duration: 4000 &#125;); &#125; &#125;) &#125;, restartServer() &#123; var that = this; $.post(URL + &apos;/api/v2/nginx_Mod/reload&apos;, &#123; action: &apos;reload&apos;, &#125;, function (data) &#123; if (data.code == &apos;ok&apos;) &#123; that.$notify(&#123; type: &apos;success&apos;, title: &apos;提示&apos;, message: &apos;重启成功&apos;, duration: 4000 &#125;); &#125; else &#123; if (data.msg == &quot;sign error&quot;) &#123; that.checkSign = &quot;sign error&quot;; &#125; that.$notify(&#123; type: &apos;warning&apos;, title: &apos;提示&apos;, message: data.msg, duration: 4000 &#125;); &#125; &#125;) &#125;, restartClusterServer() &#123; var that = this; $.post(URL + &apos;/cluster/v2/nginx_Mod/reload&apos;, &#123; action: &apos;reload&apos;, &#125;, function (data) &#123; if (data.code == &apos;ok&apos;) &#123; that.$notify(&#123; type: &apos;success&apos;, title: &apos;提示&apos;, message: &apos;重启成功&apos;, duration: 4000 &#125;); &#125; else &#123; if (data.msg == &quot;sign error&quot;) &#123; that.checkSign = &quot;sign error&quot;; &#125; that.$notify(&#123; type: &apos;warning&apos;, title: &apos;提示&apos;, message: data.msg, duration: 4000 &#125;); &#125; &#125;) &#125;, logout() &#123; var that = this; deleteCookie(&apos;openstar&apos;, null); &#125;, drawLineChart()&#123; var that = this; // 定义累加器变量 var result =&#123; &quot;sevenLog&quot; : &#123;&#125; , &quot;sevenDeny&quot; : &#123;&#125; &#125; // 定义获取时间段 var now = new Date(); var now7 = new Date(new Date().getTime() - 24 * 60 * 60 * 1000 * 6) var currentDay = [now.getFullYear(), now.getMonth() + 1, now.getDate()].join(&apos;-&apos;); var sevenDayAgo = [now7.getFullYear(), now7.getMonth() + 1, now7.getDate()].join(&apos;-&apos;); var baseLogUri = URL + &apos;/api/v2/data_Mod/trendx?key=waf_log&amp;stime=&apos; + sevenDayAgo + &apos;&amp;etime=&apos; + currentDay ; var baseDenyUri = URL + &apos;/api/v2/data_Mod/trendx?key=waf_deny&amp;stime=&apos; + sevenDayAgo + &apos;&amp;etime=&apos; + currentDay ; function check()&#123; if(a&amp;&amp;b)&#123; // 对时间进行排序 var arr = new Array(); for(var i in result[&quot;sevenLog&quot;]) &#123; var str = i.replace(/-/g, &quot;/&quot;); var newstr=&quot;&quot;; for(var i=0;i&lt;str.length;i+=13)&#123; var tmp=str.substring(i, i+13); newstr+=tmp+&quot;:&quot;; &#125; newstr = newstr + &quot;00&quot;; arr.push(newstr); &#125; arr.sort(function(a,b)&#123; return a &gt; b ? 1:-1; &#125;) // 循环遍历, 按时进行计算 for(i in arr) &#123;// var stime = arr[i]+&quot;:00&quot;;// var test = new Date(stime) ;// var test1 = new Date(test + 1 * 60 * 60 * 1000 * 6) ;// var currentTime = [test.getFullYear() + &apos;-&apos;, test.getMonth() + 1 + &apos;-&apos;, test.getDate() + &apos; &apos;, test.getHours() + &apos;:&apos;, test.getMinutes() + &apos;:&apos;, test.getSeconds()].join(&apos;&apos;);// var nextTime = [test1.getFullYear() + &apos;-&apos;, test1.getMonth() + 1 + &apos;-&apos;, test1.getDate() + &apos; &apos;, test1.getHours() + &apos;:&apos;, test1.getMinutes() + &apos;:&apos;, test1.getSeconds()].join(&apos;&apos;);// console.log(stime, currentTime, nextTime);// var str = arr[i].replace(/\//g, &quot;-&quot;);// var tmp = str.substring(0, 16).replace(/:/g, &quot;&quot;);// that.chartData[&quot;xData&quot;].push( tmp );// that.chartData[&quot;waf_log&quot;].push( result[&quot;sevenLog&quot;][tmp] );// that.chartData[&quot;waf_deny&quot;].push( result[&quot;sevenDeny&quot;][tmp] );// that.chartData[&quot;waf_req&quot;].push( result[&quot;sevenLog&quot;][tmp] + result[&quot;sevenDeny&quot;][tmp] ); &#125; // 1. 获取一个用于挂在 echarts 的 DOM 元素 let echartsDOM = document.getElementById(&apos;chartTrend&apos;); // 2. 初始化 let myEcharts = echarts.init(echartsDOM); // 3. 设置配置项 that.option.xAxis.data = that.chartData.xData; that.option.series[0].data = that.chartData.waf_log; that.option.series[1].data = that.chartData.waf_deny; that.option.series[2].data = that.chartData.waf_req; // 4. 为 echarts 指定配置 myEcharts.setOption(that.option); &#125; &#125; var a; $.get(baseLogUri, &#123;&#125;, function (data) &#123; //异步请求，有些值是要等请求完成才能给全局遍历赋值上值，所以得价格check函数进行验证 a = data; // 默认异步请求也有this变量，所以在开头需要重新定义修改，避免和vue的this冲突 if (data.code == &apos;ok&apos;) &#123; result.sevenLog = data.msg; &#125; check(); &#125;); var b; $.get(baseDenyUri, &#123;&#125;, function (data) &#123; b = data; if (data.code == &apos;ok&apos;) &#123; result.sevenDeny = data.msg; &#125; check(); &#125;); &#125;, &#125;, &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;// 同步var email = &quot;test@xx.com&quot;;console.log(1);jQuery.ajax(&#123; url: &quot;/invite/sendEmailAjax.pt&quot;, type: &quot;post&quot;, dataType: &quot;text&quot;, async: false, //同步 data: &quot;inviteEmails=&quot;+email, success: function(data)&#123; console.log(2); &#125;&#125;);console.log(3);//时间处理var from_date = new Date(&quot;2018-11-05 00:00:00&quot;);var end_date = new Date(&quot;2018-11-08 00:00:00&quot;);var s3 = end_date.getTime() - from_date.getTime();var day = s3 / (24*60*60*1000);console.log(day);l = l + (this.waf_log[t] || 0)var da = new Date(new Date()); //新建立一个时间对象，防止使用setDate的时候修改了日期，导致原来的时间不可用//ip地理位置查询// var url = &apos;http://ip.360.cn/IPQuery/ipquery?ip=&apos; + String(site);var url = &apos;http://ip-api.com/json/115.191.200.34?lang=zh-CN&apos;; 外部js调用: 1234567891011121314151617181920212223242526272829vue组件里怎么引入外部js文件里的方法&lt;template&gt; &lt;div&gt; &lt;input ref=&apos;test&apos; id=&quot;test&quot;&gt; &lt;button @click=&apos;diyfun&apos;&gt;Click&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; myfun &#125; from &apos;../js/test.js&apos; //注意路径export default &#123; data () &#123; return &#123; testvalue: &apos;&apos; &#125; &#125;, methods:&#123; diyfun:function()&#123; myfun(); &#125; &#125;&#125;&lt;/script&gt;test.js代码：function myfun() &#123; console.log(&apos;Success&apos;)&#125;//很关键export &#123; myfun &#125; 0x06 flex简单布局123456789101112131415161718192021222324.tab-box &#123; margin-top: 20px; display: -webkit-flex; /* display: -ms-flexbox; // 移动端 flex 布局 */ display: flex; // flex 布局 position: absolute; flex-direction: row; // 默认排序 top: 0px; //距离左右边距 bottom: 0px; left: 0px; right: 0px; overflow: hidden;&#125;.tab-box .box-left &#123; background: white; width: 280px; height: 180px;&#125;.tab-box .box-right &#123; background: black; width: 280px;&#125; 0x07 vue上线12345678# 上线到nginx 需要配置location / &#123; #default_type text/html; #index index.html; try_files $uri $uri/ /index.html;&#125;# 上线到apache 需要配置 ifmodule模块，把所有请求都重定向到index.html vue issue在自定义好Vue.prototype.api = api 以后，使用this.api去调用有时候会报错，出现未定义。 解决办法如下: 12var that = this; console.log( that.api ); 参考http://www.jq22.com/jquery-info13004 素材库jquery+boostrap - 侧边栏制作https://my.oschina.net/rlqmy/blog/1935223 vue组件库http://www.fredwei.com/2017/04/26/vuejs%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/ vuejs入门https://www.cnblogs.com/yeqrblog/p/9140390.html 侧边栏导航https://www.cnblogs.com/taylorchen/p/6083099.html 饿了么简单界面https://www.jianshu.com/p/9e49e65c4ef8 vue组件封装http://blog.talkingdata.com/?p=5993 vue ui库https://blog.csdn.net/mongo_node/article/details/78879330 vue组件库https://www.cnblogs.com/luyuefeng/p/8668236.html vue图标引入https://blog.csdn.net/qq_31126175/article/details/79139322 阿里侧边栏https://blog.csdn.net/eagle_88/article/details/72957496 vue computed使用https://panjiachen.github.io/vue-element-admin-site/zh/guide/advanced/icon.html#%E7%94%9F%E6%88%90%E5%9B%BE%E6%A0%87%E5%BA%93%E4%BB%A3%E7%A0%81 element 模板样式https://blog.csdn.net/jack_bob/article/details/79813114 vue element布局https://blog.csdn.net/weixin_37580235/article/details/80735169 侧边栏制作https://blog.csdn.net/qq_39725309/article/details/81558332 vue cli 3]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn-BLE重放攻击]]></title>
    <url>%2F2018%2F09%2F25%2Fpwn-ble%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[0x01 背景知识无线鼠标：无线蓝牙，无线鼠标都使用的波段为2.4 GHz ISM波段。其频率范围是2400 – 2483.5 MHz蓝牙：传统蓝牙（4.0以前）和低功率蓝牙（4.0以后），使用跳频收发器用于对抗干扰及信号衰减。 传统蓝牙： * 基础定义–4.0以前规范, 2.4GHz的波段上定义了79个信道, 每个信道有1MHz的带宽,任何蓝牙技术通信需要在同一时刻处于同一信道之内,通过相互进行通信组成”微微网”。每个”微微网”都有一个”主设备”和一个到7个”从设备” * 配对方式–”安全简化配对”每次派生密钥[DHKey]或PIN码,用来做安全验证 低功耗蓝牙[ibeacon–定位作用]： * 基础定义–4.0以后规范, 2.4GHz的波段上定义了40个信道;采用AES-CCMP 128位密钥进行加密和完整性保护 * 安全模式1和2都分级别,安全模式2的leve2采用配对认证和数据签名 安全简易配对SSP四种配对模式，在Classic 和 LE中都有 Numeric Comparison：配对双方都显示一个6位的数字，由用户来核对数字是否一致，一致即可配对。例如手机之间的配对。 Just Works：用于配对没有显示没有输入的设备，主动发起连接即可配对，用户看不到配对过程。例如连接蓝牙耳机。 Passkey Entry：要求配对目标输入一个在本地设备上显示的6位数字，输入正确即可配对。例如连接蓝牙键盘。 Out of Band：两设备的通过别的途径交换配对信息，例如NFC等。例如一些NFC蓝牙音箱。 蓝牙技术：早期【BR和LE】，蓝牙4.0【BLE】，蓝牙4.2【BLE有了secure connection】 * B：Basic * R：Rate * L：Low * E：Energy BLE 协议有很多部分组成，但是我们主要关注两部分： * GAP（Generic Access Profile）： 用于让两个设备进行连接。GAP 为设备定义多个角色，其中最重要的两个分别是：Central(进行连接)和 Pheipheral(发出广播)。 * GATT（Generic Attribute Profile）： 用于让两个设备进行连接后的通讯。 0x02 基本命令查看本机信息 123456lsusb # 查看加载的驱动lsmod | grep bt # 查看模块hciconfig # 查看蓝牙设备信息hciconfig hci0 up # 启动蓝牙设备hciconfig hci0 off # 关闭蓝牙设备l2ping -i hci0 -c 4 24:1F:A0:CE:50:69 # 测试蓝牙是否连通 扫描蓝牙信息 12345hcitool scan # 进行扫描hcitool lescan # 低功率蓝牙扫描ubertooth scan # 蓝牙扫描fang -r 范围 -s # 使用fang工具扫描隐藏的蓝牙设备（可以设置扫描范围）fang -r a4eac61de5d8-b0aa2813e4f5 -s 连接，查看蓝牙信息 1234rfcomm connect 0 00:23:a2:8s 1 # 建立连接请求blueranger.sh &lt;hciX&gt; &lt;bdaddr&gt; # blueranger工具强制连接蓝牙设备sdptool #查看，修改，删除蓝牙功能和属性gatttool -b 1C:96:5A:FF:4B:E7 -I # 连接查看属性等 蓝牙地址伪造 12345方式1：bdaddr -i hci0 00:23:a2:8s # 伪造已匹配的mac地址bccmd warmreset方式2：bccmd -d hci0 psset -s 0 bdaddr 0x16 0x00 0x67 0x08 0x05 0x00 0x07 0x20 dos测试 1l2ping -s 10000 蓝牙mac地址 蓝牙连接嗅探 1234567891011121314ubertooth-btle -f -c test.pcap #抓包&amp;保存到本地, 使用这条命令我们可以把设备捕获到的数据包保存到本地，完成后可导入wireshark进行数据包、协议分析。wireshark设置:Edit → Preferences → Protocols → DLT_USER → Edit → New 在payload protocol中输入btle蓝牙信号：btle.data_header.length &gt; 0 || btle.advertising_header.pdu_type == 0x05如果捕获到足够的数据包尤其是btsmp，那接下来便可以用crackle来破解tk和ltk：crackle -i &lt;file.pcap&gt;解密数据包，并把解密后的包另存：crackle -i &lt;file.pcap&gt; -o &lt;output.pcap&gt;crackle -i &lt;file.pcap&gt; -o &lt;out.pcap&gt; -l &lt;ltk&gt; 0x03 安装捕获数据工具中间人攻击工具:ubertooth https://github.com/greatscottgadgets/ubertooth/wiki/Build-GuideGATTacker https://github.com/securing/gattackerBtlejuice https://github.com/DigitalSecurity/btlejuice 低功耗蓝牙–中间人攻击其它工具：BlueMaho 链接：https://pan.baidu.com/s/1iMkyUgEOKiO_KJll556B4w 密码：u7ms 它可用于已知的漏洞和重要的事情来做测试BT设备漏洞，以发现未知vulns。 安装btlejuice on ubuntu –errorhttp://www.freebuf.com/articles/wireless/180716.html 12345sudo apt-get autocleansudo apt-get autoremovesudo apt-get updatesudo apt-get dist-upgradesudo apt-get -y install make gcc g++ cmake build-essential libssl-dev 下载node包管理工具,重启终端后列出可用的node版本 12sudo curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bashnvm ls-remote 安装最新版, Btlejuice需要一个相当新版本的node(&gt;=4.3.2) 和npm 1234567891011nvm install 10.11.0nvm use 10.11.0nvm alias default 10.11.0node -vnpm install -g npmnpm -vecho fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -psudo apt-get -y install bluetooth bluez libbluetooth-dev libudev-devnpm remove -g btlejuicenpm install -g btlejuice 报错处理: 123456789101112131415npm ERR! Error: CERT_UNTRUSTEDsudo npm config set strict-ssl falsenpm WARN This failure might be due to the use of legacy binary &quot;node&quot;sudo ln -s /usr/bin/nodejs /usr/bin/nodeno permission:npm install -g btlejuice --unsafe-perm$ cd ~/$ git clone https://github.com/noble/node-bluetooth-hci-socket.git$ cd ./node-bluetooth-hci-socket.git$ sudo npm install$ rm -fR ~/node-bluetooth-hci-socket$ sudo apt-get install nodejs-legacy 更换node管理包工具： 1npm install cnpm -g --registry=https://registry.npm.taobao.org 安装btlejuice on kali –success更新kali源 1234567cd /etc/apt/sudo gedit source.list #deb http://http.kali.org/kali kali-rolling main contrib non-free #deb http://http.kali.org/kali sana main non-free contrib #deb http://security.kali.org/kali-security sana/updates main contrib non-free deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib 安装tlejuice 123sudo apt-get install bluetooth bluez libbluetooth-dev libudev-devsudo apt-get install npmsudo npm install -g btlejuice --unsafe-perm 启动蓝牙 1sudo hciconfig hci0 up 运行代理 1sudo btlejuice-proxy 最终运行,如下命令: 1sudo btlejuice -u &lt;Proxy IP address&gt; -w 然后访问本地的8080端口。 扩展安装 1sudo npm install -g btlejuice-bindings 安装ubertooth –ubuntu 14.0412345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364sudo apt-get -y install bluetooth bluez blueman //pi-bluetoothsudo apt-get install spectoolswget https://github.com/greatscottgadgets/libbtbb/archive/2017-03-R2.tar.gz -O libbtbb-2017-03-R2.tar.gztar xf libbtbb-2017-03-R2.tar.gzcd libbtbb-2017-03-R2mkdir buildcd buildcmake ..makesudo make installsudo ldconfigcd ~cd libbtbb-2017-03-R2/wireshark/plugins/btbbmkdir buildcd buildcmake -DCMAKE_INSTALL_LIBDIR=/usr/lib/x86_64-linux-gnu/wireshark/libwireshark3/plugins ..makesudo make installsudo idconfigcd ~wget https://github.com/greatscottgadgets/ubertooth/releases/download/2017-03-R2/ubertooth-2017-03-R2.tar.xz -O ubertooth-2017-03-R2.tar.xztar xf ubertooth-2017-03-R2.tar.xzcd ubertooth-2017-03-R2/hostmkdir buildcd buildcmake ..makesudo make installsudo idconfigcd ~git clone https://github.com/mikeryan/crackle.gitcd cracklemakesudo make installsudo ldconfigcd ~sudo apt-get -y install libmicrohttpd-dev zlib1g-dev libnl-3-dev libnl-genl-3-dev libcap-dev libncurses5-dev libnm-* libdw-dev libsqlite3-dev libprotobuf-dev libprotobuf-c0-dev protobuf-compiler protobuf-c-compiler libsensors4-dev python python-setuptools python-protobuf python-sqlite python-requests librtlsdr0sudo apt-get -y install spectoolswget https://ftpmirror.gnu.org/libmicrohttpd/libmicrohttpd-latest.tar.gztar zxvf libmicrohttpd-latest.tar.gz cd libmicrohttpd-0.9.59/./configure sudo apt-get install libmicrohttpdmakesudo make install sudo ldconfigcd ~wget https://kismetwireless.net/code/kismet-2013-03-R1b.tar.xztar xf kismet-2013-03-R1b.tar.xzcd kismet-2013-03-R1bln -s ../ubertooth-2015-09-R2/host/kismet/plugin-ubertooth ../configuremake &amp;&amp; make pluginssudo make suidinstallsudo make plugins-installsudo ldconfigcd ~sudo usermod -a -G kismet bing# 找到kismet的配置文件kismet.conf ，把”pcapbtbb”加入到kismet.conf的logtypes= 里边 0x04 分析利用无低功耗蓝牙, 暂停分析… 0x05 分析蓝牙底层git clone https://github.com/pybluez/pybluez.gittodo 参考https://wenku.baidu.com/view/404f0c4376c66137ef06190c.htmlhttp://www.freebuf.com/news/88281.htmlhttp://www.freebuf.com/articles/wireless/106298.htmlhttp://sdr-x.github.io/cat-lte/ todo:https://sec.xiaomi.com/article/39http://www.freebuf.com/sectool/95426.htmlhttps://www.anquanke.com/post/id/85863https://www.anquanke.com/post/id/85602http://drops.xmd5.com/static/drops/tips-10109.html]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-io字节流2]]></title>
    <url>%2F2018%2F09%2F20%2Fjava-io%E5%AD%97%E8%8A%82%E6%B5%812%2F</url>
    <content type="text"><![CDATA[0x01 IO字符流(字符流FileReader)1.字符流是什么 字符流是可以直接读写字符的IO字符流 字符流读取字符, 就要先读取到字节数据, 然后转为字符. 如果要写出字符, 需要把字符转为字节再写出.2.FileReader FileReader类的read()方法可以按照字符大小读取 1234567FileReader fr = new FileReader(&quot;aaa.txt&quot;); //创建输入流对象,关联aaa.txtint ch;while((ch = fr.read()) != -1) &#123; //将读到的字符赋值给ch System.out.println((char)ch); //将读到的字符强转后打印&#125;fr.close(); //关流 0x02 IO字符流(字符流FileWriter)FileWriter类的write()方法可以自动把字符转为字节写出 123FileWriter fw = new FileWriter(&quot;aaa.txt&quot;);fw.write(&quot;aaa&quot;);fw.close(); 0x03 IO字符流(字符流的拷贝)12345678910FileReader fr = new FileReader(&quot;a.txt&quot;);FileWriter fw = new FileWriter(&quot;b.txt&quot;);int ch;while((ch = fr.read()) != -1) &#123; fw.write(ch);&#125;fr.close();fw.close(); 0x04 IO字符流(什么情况下使用字符流)字符流也可以拷贝文本文件, 但不推荐使用. 因为读取时会把字节转为字符, 写出时还要把字符转回字节.程序需要读取一段文本, 或者需要写出一段文本的时候可以使用字符流读取的时候是按照字符的大小读取的,不会出现半个中文写出的时候可以直接将字符串写出,不用转换为字节数组 0x05 IO字符流(字符流是否可以拷贝非纯文本的文件)不可以拷贝非纯文本的文件因为在读的时候会将字节转换为字符,在转换过程中,可能找不到对应的字符,就会用?代替,写出的时候会将字符转换成字节写出去如果是?,直接写出,这样写出之后的文件就乱了,看不了了 0x06 IO字符流(自定义字符数组的拷贝)1234567891011FileReader fr = new FileReader(&quot;aaa.txt&quot;); //创建字符输入流,关联aaa.txtFileWriter fw = new FileWriter(&quot;bbb.txt&quot;); //创建字符输出流,关联bbb.txtint len;char[] arr = new char[1024*8]; //创建字符数组while((len = fr.read(arr)) != -1) &#123; //将数据读到字符数组中 fw.write(arr, 0, len); //从字符数组将数据写到文件上&#125;fr.close(); //关流释放资源fw.close(); 0x07 IO字符流(带缓冲的字符流)BufferedReader的read()方法读取字符时会一次读取若干字符到缓冲区, 然后逐个返回给程序, 降低读取文件的次数, 提高效率BufferedWriter的write()方法写出字符时会先写到缓冲区, 缓冲区写满时才会写到文件, 降低写文件的次数, 提高效率 12345678910BufferedReader br = new BufferedReader(new FileReader(&quot;aaa.txt&quot;)); //创建字符输入流对象,关联aaa.txtBufferedWriter bw = new BufferedWriter(new FileWriter(&quot;bbb.txt&quot;)); //创建字符输出流对象,关联bbb.txtint ch; while((ch = br.read()) != -1) &#123; //read一次,会先将缓冲区读满,从缓冲去中一个一个的返给临时变量ch bw.write(ch); //write一次,是将数据装到字符数组,装满后再一起写出去&#125;br.close(); //关流bw.close(); 0x08 IO字符流(readLine()和newLine()方法)BufferedReader的readLine()方法可以读取一行字符(不包含换行符号)BufferedWriter的newLine()可以输出一个跨平台的换行符号”\r\n” 1234567891011BufferedReader br = new BufferedReader(new FileReader(&quot;aaa.txt&quot;));BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;bbb.txt&quot;));String line;while((line = br.readLine()) != null) &#123; bw.write(line); //bw.write(&quot;\r\n&quot;); //只支持windows系统 bw.newLine(); //跨平台的&#125;br.close();bw.close(); 0x09 IO字符流(将文本反转)将一个文本文档上的文本反转,第一行和倒数第一行交换,第二行和倒数第二行交换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.util.ArrayList;public class Test1 &#123; /** * @param args * 将一个文本文档上的文本反转,第一行和倒数第一行交换,第二行和倒数第二行交换 * * 分析: * 1,创建输入输出流对象 * 2,创建集合对象 * 3,将读到的数据存储在集合中 * 4,倒着遍历集合将数据写到文件上 * 5,关流 * @throws IOException * * 注意事项: * 流对象尽量晚开早关 */ public static void main(String[] args) throws IOException &#123; //改写后是尽量晚开早关 // 1,创建输入输出流对象 BufferedReader br = new BufferedReader(new FileReader(&quot;zzz.txt&quot;)); //2,创建集合对象 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //3,将读到的数据存储在集合中 String line; while((line = br.readLine()) != null) &#123; list.add(line); &#125; br.close(); //关流 //4,倒着遍历集合将数据写到文件上 BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;revzzz.txt&quot;)); for(int i = list.size() - 1; i &gt;= 0; i--) &#123; bw.write(list.get(i)); bw.newLine(); &#125; //5,关流 bw.close(); &#125;&#125; 0x0a IO字符流(LineNumberReader)LineNumberReader是BufferedReader的子类, 具有相同的功能, 并且可以统计行号 调用getLineNumber()方法可以获取当前行号 调用setLineNumber()方法可以设置当前行号 12345678LineNumberReader lnr = new LineNumberReader(new FileReader(&quot;aaa.txt&quot;));String line;lnr.setLineNumber(100); //设置行号while((line = lnr.readLine()) != null) &#123; System.out.println(lnr.getLineNumber() + &quot;:&quot; + line);//获取行号&#125;lnr.close(); 0x0b IO字符流(装饰设计模式)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Demo6_Wrap &#123; /** * @param args * 装饰设计模式的好处是: * 耦合性不强,被装饰的类的变化与装饰类的变化无关 */ public static void main(String[] args) &#123; HeiMaStudent hms = new HeiMaStudent(new Student()); hms.code(); &#125;&#125;interface Coder &#123; public void code();&#125;class Student implements Coder &#123; @Override public void code() &#123; System.out.println(&quot;javase&quot;); System.out.println(&quot;javaweb&quot;); &#125; &#125;class HeiMaStudent implements Coder &#123; //1,获取被装饰类的引用 private Student s; //获取学生引用 //2,在构造方法中传入被装饰类的对象 public HeiMaStudent(Student s) &#123; this.s = s; &#125; //3,对原有的功能进行升级 @Override public void code() &#123; s.code(); System.out.println(&quot;ssh&quot;); System.out.println(&quot;数据库&quot;); System.out.println(&quot;大数据&quot;); System.out.println(&quot;...&quot;); &#125;&#125; 0x0c IO字符流(使用指定的码表读写字符)FileReader是使用默认码表读取文件, 如果需要使用指定码表读取, 那么可以使用InputStreamReader(字节流,编码表)FileWriter是使用默认码表写出文件, 如果需要使用指定码表写出, 那么可以使用OutputStreamWriter(字节流,编码表) 1234567891011BufferedReader br = //高效的用指定的编码表读 new BufferedReader(new InputStreamReader(new FileInputStream(&quot;UTF-8.txt&quot;), &quot;UTF-8&quot;));BufferedWriter bw = //高效的用指定的编码表写 new BufferedWriter(new OutputStreamWriter(new FileOutputStream(&quot;GBK.txt&quot;), &quot;GBK&quot;));int ch;while((ch = br.read()) != -1) &#123; bw.write(ch);&#125;br.close();bw.close(); 0x0d IO字符流(转换流图解)画图分析转换流 0x0e IO字符流(获取文本上字符出现的次数)获取一个文本上每个字符出现的次数,将结果写在times.txt上 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.util.TreeMap;public class Test3 &#123; /** * 获取一个文本上每个字符出现的次数,将结果写在times.txt上 * * 分析: * 1,创建带缓冲的输入流对象 * 2,创建双列集合对象TreeMap * 3,将读到的字符存储在双列集合中,存储的时候要做判断,如果不包含这个键,就将键和1存储,如果包含这个键,就将该键和值加1存储 * 4,关闭输入流 * 5,创建输出流对象 * 6,遍历集合将集合中的内容写到times.txt中 * 7,关闭输出流 * @throws IOException */ public static void main(String[] args) throws IOException &#123; //1,创建带缓冲的输入流对象 BufferedReader br = new BufferedReader(new FileReader(&quot;zzz.txt&quot;)); //2,创建双列集合对象TreeMap TreeMap&lt;Character, Integer&gt; tm = new TreeMap&lt;&gt;(); //3,将读到的字符存储在双列集合中,存储的时候要做判断,如果不包含这个键,就将键和1存储,如果包含这个键,就将该键和值加1存储 int ch; while((ch = br.read()) != -1) &#123; char c = (char)ch; //强制类型转换 /*if(!tm.containsKey(c)) &#123; tm.put(c, 1); &#125;else &#123; tm.put(c, tm.get(c) + 1); &#125;*/ tm.put(c, !tm.containsKey(c) ? 1 : tm.get(c) + 1); &#125; //4,关闭输入流 br.close(); //5,创建输出流对象 BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;times.txt&quot;)); //6,遍历集合将集合中的内容写到times.txt中 for(Character key : tm.keySet()) &#123; switch (key) &#123; case &apos;\t&apos;: bw.write(&quot;\\t&quot; + &quot;=&quot; + tm.get(key)); break; case &apos;\n&apos;: bw.write(&quot;\\n&quot; + &quot;=&quot; + tm.get(key)); break; case &apos;\r&apos;: bw.write(&quot;\\r&quot; + &quot;=&quot; + tm.get(key)); break; default: bw.write(key + &quot;=&quot; + tm.get(key)); //写出键和值 break; &#125; bw.newLine(); &#125; //7,关闭输出流 bw.close(); &#125;&#125; 0x0f IO字符流(试用版软件)当我们下载一个试用版软件,没有购买正版的时候,每执行一次就会提醒我们还有多少次使用机会用学过的IO字符流知识,模拟试用版软件,试用10次机会,执行一次就提示一次您还有几次机会,如果次数到了提示请购买正版 1234567891011121314151617181920212223242526272829303132333435363738import java.io.BufferedReader;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;public class Test4 &#123; /** * 当我们下载一个试用版软件,没有购买正版的时候,每执行一次就会提醒我们还有多少次使用机会用学过的IO字符流知识,模拟试用版软件, * 试用10次机会,执行一次就提示一次您还有几次机会,如果次数到了提示请购买正版 * @throws IOException * 分析: * 1,创建带缓冲的输入流对象,因为要使用readLine方法,可以保证数据的原样性 * 2,将读到的字符串转换为int数 * 3,对int数进行判断,如果大于0,就将其--写回去,如果不大于0,就提示请购买正版 * 4,在if判断中要将--的结果打印,并将结果通过输出流写到文件上 */ public static void main(String[] args) throws IOException &#123; //1,创建带缓冲的输入流对象,因为要使用readLine方法,可以保证数据的原样性 BufferedReader br = new BufferedReader(new FileReader(&quot;config.txt&quot;)); //2,将读到的字符串转换为int数 String line = br.readLine(); int times = Integer.parseInt(line); //将数字字符串转换为数字 //3,对int数进行判断,如果大于0,就将其--写回去,如果不大于0,就提示请购买正版 if(times &gt; 0) &#123; //4,在if判断中要将--的结果打印,并将结果通过输出流写到文件上 System.out.println(&quot;您还有&quot; + times-- + &quot;次机会&quot;); FileWriter fw = new FileWriter(&quot;config.txt&quot;); fw.write(times + &quot;&quot;); fw.close(); &#125;else &#123; System.out.println(&quot;您的试用次数已到,请购买正版&quot;); &#125; //关闭流 br.close(); &#125;&#125; 0x10 IO字符流(总结)1.会用BufferedReader读取GBK码表和UTF-8码表的字符2.会用BufferedWriter写出字符到GBK码表和UTF-8码表的文件中3.会使用BufferedReader从键盘读取一行]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-爬虫]]></title>
    <url>%2F2018%2F09%2F18%2Fpython-%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[0x01 背景知识​headless chrome工具是用来自动加载js，获取渲染后的页面源码，解决web2.0爬虫之困。 0x02 环境安装系统环境: ubuntu-14.04 一般添加源操作添加 PPA 源 12 添加 PPA 源的命令为：sudo add-apt-repository ppa:user/ppa-name 添加好记得要更新一下： sudo apt-get update 删除 PPA 源 123 删除 PPA 源的命令格式则为：sudo add-apt-repository -r ppa:user/ppa-name 然后进入 /etc/apt/sources.list.d 目录，将相应 ppa 源的保存文件删除。 最后同样更新一下：sudo apt-get update headless-chrom 安装12345678910111213141516sudo apt-get updatesudo apt-get install software-properties-commonsudo add-apt-repository ppa:canonical-chromium-builds/stagesudo apt-get updatesudo apt-get install chromium-browser chromium-browser --headless --remote-debugging-port=9222 https://www.baidu.com --disable-gpu这里是使用headless模式进行远程调试，ubuntu上大多没有gpu，所以--disable-gpu以免报错。curl http://localhost:9222能够看到调试信息应该就是装好了。#获取网页源码chromium-browser --headless --dump-dom https://www.baidu.com/ --disable-gpu#获取网页转换成PDFchromium-browser --headless --print-to-pdf https://www.baidu.com/ --disable-gpu#截图chromium-browser --headless --screenshot --window-size=1280,1696 https://www.baidu.com/ --disable-gpu 安装python3环境12345678910由于chrome-remote-interface-python基于是用python3.5开发的，所以python安装高版本,以便兼容sudo add-apt-repository ppa:jonathonf/python-3.6sudo apt updatesudo apt-get -y install python3.6sudo apt-get -y install python3.6-devsudo apt-get -y install python3.6-venvwget https://bootstrap.pypa.io/get-pip.pysudo python3.6 get-pip.pysudo ln -s /usr/bin/python3.6 /usr/local/bin/pythonsudo ln -s /usr/local/bin/pip /usr/local/bin/pip 打开启动chrome headless监听模式1nohup chromium-browser --headless --disable-gpu --remote-debugging-port=9222 --remote-debugging-address=0.0.0.0 --disable-web-security --disable-xss-auditor --no-sandbox --disable-setuid-sandbox &amp; 0x03 使用chrome-remote-interface-pythonchrome_remote_interface是一个更底层的工具，可以用来分析协议，简单说就是可以分析整个渲染过程，以及截取分析过程中的流量。就类似您打开了chrome浏览器的审查元素功能，然后刷新一下页面，查看一下network信息。本篇文章主要介绍chrome_remote_interface的python版使用项目地址 第一种安装方式： 12git clone https://github.com/wasiher/chrome-remote-interface-python.gitsudo python3.6 setup.py install 第二种安装方式： 123456sudo pip3.6 install git+https://github.com/wasiher/chrome-remote-interface-python.git@master一般遇到这种错误：Cannot uninstall &apos;urllib3&apos;. It is a distutils installed project and thus we cannot accurately determine which files belong to it which would lead to only a partial uninstall.解决方式:sudo pip3.6 install --upgrade requests --ignore-installed urllib3 演示：vim t2.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301#! /usr/bin/env python3# encoding: utf-8import asyncioimport chrome_remote_interfaceclass callbacks(object): target_url = &apos;&apos; result = [] async def start(tabs): await tabs.add() async def tab_start(tabs, tab): await tab.Page.enable() await tab.Network.enable() await tab.Page.navigate(url=callbacks.target_url) async def network__response_received(tabs, tab, requestId, loaderId, timestamp, type, response, **kwargs): &apos;&apos;&apos; print(response.requestHeaders) print(dir(response)) more response attribute https://chromedevtools.github.io/devtools-protocol/tot/Network#type-Response &apos;&apos;&apos; try: body = tabs.helpers.old_helpers.unpack_response_body(await tab.Network.get_response_body(requestId=requestId)) except tabs.FailResponse as e: print(&apos;[Error]&apos;, e) else: print(response.url,response.status,len(body)) callbacks.result.append((response.url,response.status,len(body))) async def page__frame_stopped_loading(tabs, tab, **kwargs): print(&quot;[Info]Finish&quot;) tabs.terminate() async def any(tabs, tab, callback_name, parameters): passif __name__==&quot;__main__&quot;: callbacks.target_url = &quot;https://www.chehejia.com&quot; asyncio.get_event_loop().run_until_complete(chrome_remote_interface.Tabs.run(&apos;localhost&apos;, 9222, callbacks)) # print(callbacks.result)#! -*- coding:utf-8 -*-import asyncioimport chrome_remote_interfaceclass callbacks(object): target_url = &apos;&apos; result = [] async def start(tabs): await tabs.add() async def tab_start(tabs, tab): await tab.Page.enable() await tab.Network.enable() await tab.Page.navigate(url=callbacks.target_url) async def network__response_received(tabs, tab, requestId, loaderId, timestamp, type, response, **kwargs): try: #body = tabs.helpers.old_helpers.unpack_response_body(await tab.Network.get_response_body(requestId=requestId)) body = await tab.Network.get_response_body(requestId=requestId) except tabs.FailResponse as e: print(&apos;[Error]&apos;, e) else: fileSuffix = str(response.url).split(&quot;.&quot;)[-1] # simple filter if fileSuffix in [&quot;css&quot;, &quot;js&quot;, &quot;png&quot;, &quot;jpg&quot;, &quot;gif&quot;, &quot;woff2&quot;]: pass else: print(response.url,response.status,len(body), body.get(&quot;base64Encoded&quot;)) &apos;&apos;&apos; if not body.get(&quot;base64Encoded&quot;): print( body.get(&quot;body&quot;) ) else: print( &quot;run_until_complete&quot; ) #callbacks.result.append((response.url,response.status,len(body))) &apos;&apos;&apos; &apos;&apos;&apos; try: body1 = await tab.Network.get_request_post_data(requestId=requestId) except tabs.FailResponse as e: print(&apos;[Error]&apos;, e) else: print(body1, &quot;b&quot;*30) frameid = &quot;&quot; url = &quot;&quot; try: body2 = await tab.Page.get_resource_tree() except Exception as e: print(&apos;[Error]&apos;, e) else: print(body2.frame.url, body2.frame.mimeType) try: body3 = await tab.Page.get_resource_content(frameId=frameid, url=url) except Exception as e: print(&quot;[content]:&quot;, e) else: print( len(body3), &quot;c&quot;*30) &apos;&apos;&apos; async def page__frame_stopped_loading(tabs, tab, **kwargs): print(&quot;[Info]Finish&quot;) tabs.terminate() async def any(tabs, tab, callback_name, parameters): passif __name__==&quot;__main__&quot;: callbacks.target_url = &quot;https://www.chehejia.com&quot; asyncio.get_event_loop().run_until_complete(chrome_remote_interface.Tabs.run(&apos;localhost&apos;, 9222, callbacks)) # print(callbacks.result)#! -*- coding:utf-8 -*-import asyncio, sysimport chrome_remote_interfacefrom lxml import etree, htmlclass callbacks(object): target_url = &apos;&apos; result = [] async def start(tabs): await tabs.add() async def tab_start(tabs, tab): await tab.Page.enable() await tab.Network.enable() await tab.Page.navigate(url=callbacks.target_url) async def network__response_received(tabs, tab, requestId, loaderId, timestamp, type, response, **kwargs): try: #body = tabs.helpers.old_helpers.unpack_response_body(await tab.Network.get_response_body(requestId=requestId)) body = await tab.Network.get_response_body(requestId=requestId) except tabs.FailResponse as e: print(&apos;[Error]&apos;, e) else: Server = response.get(&quot;headers&quot;).get(&quot;server&quot;) if response.get(&quot;headers&quot;).get(&quot;server&quot;) else response.get(&quot;headers&quot;).get(&quot;Server&quot;) contentType = response.get(&quot;headers&quot;).get(&quot;content-type&quot;) if response.get(&quot;headers&quot;).get(&quot;content-type&quot;) else response.get(&quot;headers&quot;).get(&quot;Content-Type&quot;) try: Subdomain = response.get(&quot;securityDetails&quot;).get(&quot;sanList&quot;) except: Subdomain = &quot;&quot; print(&quot;Url :&quot;, response.get(&quot;url&quot;), response.get(&quot;status&quot;), contentType ) print(&quot;Subdomain :&quot;, Subdomain) if &quot;text/html&quot; in str(contentType): tree = etree.HTML(body.get(&quot;body&quot;)) for link in tree.xpath(&quot;//@href&quot;): print(link) #text = page.text_content() # drop all of tags #print(text) print(&quot;-&quot;*80) print(&quot;\r&quot;) async def page__frame_stopped_loading(tabs, tab, **kwargs): print(&quot;[Info] Finish&quot;) tabs.terminate() # async def any(tabs, tab, callback_name, parameters): # passif __name__==&quot;__main__&quot;: callbacks.target_url = sys.argv[1] #callbacks.target_url = &quot;http://www.baidu.com&quot; asyncio.get_event_loop().run_until_complete(chrome_remote_interface.Tabs.run(&apos;localhost&apos;, 9222, callbacks)) # print(callbacks.result)tab:[&apos;Accessibility&apos;, &apos;Animation&apos;, &apos;ApplicationCache&apos;, &apos;Audits&apos;, &apos;Browser&apos;, &apos;CSS&apos;, &apos;CacheStorage&apos;, &apos;Console&apos;, &apos;CustomClassReprType&apos;, &apos;DOM&apos;, &apos;DOMDebugger&apos;, &apos;DOMSnapshot&apos;, &apos;DOMStorage&apos;, &apos;Database&apos;, &apos;Debugger&apos;, &apos;DeviceOrientation&apos;, &apos;Emulation&apos;, &apos;HeadlessExperimental&apos;, &apos;HeapProfiler&apos;, &apos;IO&apos;, &apos;IndexedDB&apos;, &apos;Input&apos;, &apos;Inspector&apos;, &apos;LayerTree&apos;, &apos;Log&apos;, &apos;Memory&apos;, &apos;Network&apos;, &apos;Overlay&apos;, &apos;Page&apos;, &apos;Performance&apos;, &apos;Profiler&apos;, &apos;Runtime&apos;, &apos;Schema&apos;, &apos;Security&apos;, &apos;ServiceWorker&apos;, &apos;Storage&apos;, &apos;SystemInfo&apos;, &apos;Target&apos;, &apos;Tethering&apos;, &apos;Tracing&apos;, &apos;__aenter__&apos;, &apos;__aexit__&apos;, &apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__module__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;__weakref__&apos;, &apos;_connect_raw_parameter_or_result&apos;, &apos;_connect_raw_type&apos;, &apos;_dummy_cool_type&apos;, &apos;_emit_event&apos;, &apos;_empty_class&apos;, &apos;_event_name_to_event&apos;, &apos;_float_hook&apos;, &apos;_handle_event&apos;, &apos;_host&apos;, &apos;_i&apos;, &apos;_id&apos;, &apos;_locks&apos;, &apos;_make_ppr&apos;, &apos;_make_send_method&apos;, &apos;_method_name_to_method&apos;, &apos;_method_responses&apos;, &apos;_pending_tasks&apos;, &apos;_port&apos;, &apos;_pythonic_method_name&apos;, &apos;_raw_protocol&apos;, &apos;_recv_data_lock&apos;, &apos;_repr_class&apos;, &apos;_run_later&apos;, &apos;_soc&apos;, &apos;_start_time&apos;, &apos;_tabs&apos;, &apos;_unpack_event&apos;, &apos;_unpack_response&apos;, &apos;_wrap_macros&apos;, &apos;_ws_url&apos;, &apos;close&apos;, &apos;closed&apos;, &apos;events&apos;, &apos;id&apos;, &apos;lock&apos;, &apos;manual&apos;, &apos;remove&apos;, &apos;send_raw&apos;, &apos;timestamp&apos;, &apos;ws_url&apos;]tab.Page:[&apos;AppManifestError&apos;, &apos;DialogType&apos;, &apos;Frame&apos;, &apos;FrameId&apos;, &apos;FrameResource&apos;, &apos;FrameResourceTree&apos;, &apos;FrameTree&apos;, &apos;LayoutViewport&apos;, &apos;NavigationEntry&apos;, &apos;ResourceType&apos;, &apos;ScreencastFrameMetadata&apos;, &apos;ScriptIdentifier&apos;, &apos;TransitionType&apos;, &apos;Viewport&apos;, &apos;VisualViewport&apos;, &apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__module__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;__weakref__&apos;, &apos;_class_repr&apos;, &apos;add_script_to_evaluate_on_load&apos;, &apos;add_script_to_evaluate_on_new_document&apos;, &apos;bring_to_front&apos;, &apos;capture_screenshot&apos;, &apos;clear_device_metrics_override&apos;, &apos;clear_device_orientation_override&apos;, &apos;clear_geolocation_override&apos;, &apos;crash&apos;, &apos;create_isolated_world&apos;, &apos;delete_cookie&apos;, &apos;dependencies&apos;, &apos;disable&apos;, &apos;enable&apos;, &apos;experimental&apos;, &apos;get_app_manifest&apos;, &apos;get_cookies&apos;, &apos;get_frame_tree&apos;, &apos;get_layout_metrics&apos;, &apos;get_navigation_history&apos;, &apos;get_resource_content&apos;, &apos;get_resource_tree&apos;, &apos;handle_java_script_dialog&apos;, &apos;navigate&apos;, &apos;navigate_to_history_entry&apos;, &apos;print_to_pdf&apos;, &apos;reload&apos;, &apos;remove_script_to_evaluate_on_load&apos;, &apos;remove_script_to_evaluate_on_new_document&apos;, &apos;request_app_banner&apos;, &apos;screencast_frame_ack&apos;, &apos;search_in_resource&apos;, &apos;set_ad_blocking_enabled&apos;, &apos;set_device_metrics_override&apos;, &apos;set_device_orientation_override&apos;, &apos;set_document_content&apos;, &apos;set_download_behavior&apos;, &apos;set_geolocation_override&apos;, &apos;set_lifecycle_events_enabled&apos;, &apos;set_touch_emulation_enabled&apos;, &apos;start_screencast&apos;, &apos;stop_loading&apos;, &apos;stop_screencast&apos;]tab.DOM:[&apos;BackendNode&apos;, &apos;BackendNodeId&apos;, &apos;BoxModel&apos;, &apos;Node&apos;, &apos;NodeId&apos;, &apos;PseudoType&apos;, &apos;Quad&apos;, &apos;RGBA&apos;, &apos;Rect&apos;, &apos;ShadowRootType&apos;, &apos;ShapeOutsideInfo&apos;, &apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__module__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;__weakref__&apos;, &apos;_class_repr&apos;, &apos;collect_class_names_from_subtree&apos;, &apos;copy_to&apos;, &apos;dependencies&apos;, &apos;describe_node&apos;, &apos;disable&apos;, &apos;discard_search_results&apos;, &apos;enable&apos;, &apos;experimental&apos;, &apos;focus&apos;, &apos;get_attributes&apos;, &apos;get_box_model&apos;, &apos;get_document&apos;, &apos;get_flattened_document&apos;, &apos;get_node_for_location&apos;, &apos;get_outer_html&apos;, &apos;get_relayout_boundary&apos;, &apos;get_search_results&apos;, &apos;hide_highlight&apos;, &apos;highlight_node&apos;, &apos;highlight_rect&apos;, &apos;mark_undoable_state&apos;, &apos;move_to&apos;, &apos;perform_search&apos;, &apos;push_node_by_path_to_frontend&apos;, &apos;push_nodes_by_backend_ids_to_frontend&apos;, &apos;query_selector&apos;, &apos;query_selector_all&apos;, &apos;redo&apos;, &apos;remove_attribute&apos;, &apos;remove_node&apos;, &apos;request_child_nodes&apos;, &apos;request_node&apos;, &apos;resolve_node&apos;, &apos;set_attribute_value&apos;, &apos;set_attributes_as_text&apos;, &apos;set_file_input_files&apos;, &apos;set_inspected_node&apos;, &apos;set_node_name&apos;, &apos;set_node_value&apos;, &apos;set_outer_html&apos;, &apos;undo&apos;]tab.Debugger:[&apos;BreakLocation&apos;, &apos;BreakpointId&apos;, &apos;CallFrame&apos;, &apos;CallFrameId&apos;, &apos;Location&apos;, &apos;Scope&apos;, &apos;ScriptPosition&apos;, &apos;SearchMatch&apos;, &apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__module__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;__weakref__&apos;, &apos;_class_repr&apos;, &apos;continue_to_location&apos;, &apos;dependencies&apos;, &apos;disable&apos;, &apos;enable&apos;, &apos;evaluate_on_call_frame&apos;, &apos;experimental&apos;, &apos;get_possible_breakpoints&apos;, &apos;get_script_source&apos;, &apos;get_stack_trace&apos;, &apos;pause&apos;, &apos;pause_on_async_call&apos;, &apos;remove_breakpoint&apos;, &apos;restart_frame&apos;, &apos;resume&apos;, &apos;schedule_step_into_async&apos;, &apos;search_in_content&apos;, &apos;set_async_call_stack_depth&apos;, &apos;set_blackbox_patterns&apos;, &apos;set_blackboxed_ranges&apos;, &apos;set_breakpoint&apos;, &apos;set_breakpoint_by_url&apos;, &apos;set_breakpoints_active&apos;, &apos;set_pause_on_exceptions&apos;, &apos;set_return_value&apos;, &apos;set_script_source&apos;, &apos;set_skip_all_pauses&apos;, &apos;set_variable_value&apos;, &apos;step_into&apos;, &apos;step_out&apos;, &apos;step_over&apos;]tab.IO:[&apos;StreamHandle&apos;, &apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__module__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;__weakref__&apos;, &apos;_class_repr&apos;, &apos;close&apos;, &apos;dependencies&apos;, &apos;experimental&apos;, &apos;read&apos;, &apos;resolve_blob&apos;]tab.LayerTree:[&apos;Layer&apos;, &apos;LayerId&apos;, &apos;PaintProfile&apos;, &apos;PictureTile&apos;, &apos;ScrollRect&apos;, &apos;SnapshotId&apos;, &apos;StickyPositionConstraint&apos;, &apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__module__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;__weakref__&apos;, &apos;_class_repr&apos;, &apos;compositing_reasons&apos;, &apos;dependencies&apos;, &apos;disable&apos;, &apos;enable&apos;, &apos;experimental&apos;, &apos;load_snapshot&apos;, &apos;make_snapshot&apos;, &apos;profile_snapshot&apos;, &apos;release_snapshot&apos;, &apos;replay_snapshot&apos;, &apos;snapshot_command_log&apos;]tab.Network:[&apos;AuthChallenge&apos;, &apos;AuthChallengeResponse&apos;, &apos;BlockedReason&apos;, &apos;CachedResource&apos;, &apos;ConnectionType&apos;, &apos;Cookie&apos;, &apos;CookieParam&apos;, &apos;CookieSameSite&apos;, &apos;ErrorReason&apos;, &apos;Headers&apos;, &apos;Initiator&apos;, &apos;InterceptionId&apos;, &apos;InterceptionStage&apos;, &apos;LoaderId&apos;, &apos;MonotonicTime&apos;, &apos;Request&apos;, &apos;RequestId&apos;, &apos;RequestPattern&apos;, &apos;ResourcePriority&apos;, &apos;ResourceTiming&apos;, &apos;Response&apos;, &apos;SecurityDetails&apos;, &apos;SignedCertificateTimestamp&apos;, &apos;TimeSinceEpoch&apos;, &apos;WebSocketFrame&apos;, &apos;WebSocketRequest&apos;, &apos;WebSocketResponse&apos;, &apos;__class__&apos;, &apos;__delattr__&apos;, &apos;__dict__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__le__&apos;, &apos;__lt__&apos;, &apos;__module__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;__weakref__&apos;, &apos;_class_repr&apos;, &apos;can_clear_browser_cache&apos;, &apos;can_clear_browser_cookies&apos;, &apos;can_emulate_network_conditions&apos;, &apos;clear_browser_cache&apos;, &apos;clear_browser_cookies&apos;, &apos;continue_intercepted_request&apos;, &apos;delete_cookies&apos;, &apos;dependencies&apos;, &apos;disable&apos;, &apos;emulate_network_conditions&apos;, &apos;enable&apos;, &apos;experimental&apos;, &apos;get_all_cookies&apos;, &apos;get_certificate&apos;, &apos;get_cookies&apos;, &apos;get_request_post_data&apos;, &apos;get_response_body&apos;, &apos;get_response_body_for_interception&apos;, &apos;replay_xhr&apos;, &apos;search_in_response_body&apos;, &apos;set_blocked_ur_ls&apos;, &apos;set_bypass_service_worker&apos;, &apos;set_cache_disabled&apos;, &apos;set_cookie&apos;, &apos;set_cookies&apos;, &apos;set_data_size_limits_for_test&apos;, &apos;set_extra_http_headers&apos;, &apos;set_request_interception&apos;, &apos;set_user_agent_override&apos;]tab.Network.get_response_body:[&apos;__class__&apos;, &apos;__contains__&apos;, &apos;__delattr__&apos;, &apos;__delitem__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__getitem__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__iter__&apos;, &apos;__le__&apos;, &apos;__len__&apos;, &apos;__lt__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__setattr__&apos;, &apos;__setitem__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;clear&apos;, &apos;copy&apos;, &apos;fromkeys&apos;, &apos;get&apos;, &apos;items&apos;, &apos;keys&apos;, &apos;pop&apos;, &apos;popitem&apos;, &apos;setdefault&apos;, &apos;update&apos;, &apos;values&apos;]response: 可以通过get的方式获取以下信息Network.Response(&#123;&apos;url&apos;: &apos;https://hm.baidu.com/hm.js?4b812fe425e0bb97ce17260602b7a27a&apos;, &apos;status&apos;: 200, &apos;statusText&apos;: &apos;OK&apos;, &apos;headers&apos;: &#123; &apos;Date&apos;: &apos;Wed, 19 Sep 2018 08:21:49 GMT&apos;, &apos;Content-Encoding&apos;: &apos;gzip&apos;, &apos;Server&apos;: &apos;apache&apos;, &apos;Etag&apos;: &apos;0f1c3a610ba012cea2c5f46e42b6a306&apos;, &apos;Strict-Transport-Security&apos;: &apos;max-age=172800&apos;, &apos;Content-Type&apos;: &apos;application/javascript&apos;, &apos;Cache-Control&apos;: &apos;max-age=0, must-revalidate&apos;, &apos; Content-Length&apos;: &apos;9890&apos;&#125;, &apos;headersText&apos;: &apos;HTTP/1.1 200 OK\r\nCache-Control: max-age=0, must-revalidate\r\nContent-Encoding: gzip\r\nContent-Length: 9890\r\nContent-Type: application/javascript\r\nDate: Wed, 19 Sep 2018 08:21:49 GMT\r\nEtag: 0f1c3a610ba012cea2c5f46e42b6a306\r\nServer: apache\r\nStrict-Transport-Security: max-age=172800\r\n\r\n&apos;, &apos;mimeType&apos;: &apos;application/javascript&apos;, &apos;requestHeaders&apos;: &#123; &apos;Cookie&apos;: &apos;BAIDUID=A866CBEEA134D64FB3E9F0DCA6EC652D:FG=1; BIDUPSID=A866CBEEA134D64FB3E9F0DCA6EC652D; PSTM=1537321927; H_PS_PSSID=1469_21124_26350_22158; HMACCOUNT=14729D0D5CAAFD32&apos;, &apos;Accept-Encoding&apos;: &apos;gzip, deflate&apos;, &apos;Host&apos;: &apos;hm.baidu.com&apos;, &apos;User-Agent&apos;: &apos;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/65.0.3325.181 HeadlessChrome/65.0.3325.181 Safari/537.36&apos;, &apos;Accept&apos;: &apos;*/*&apos;, &apos;Referer&apos;: &apos;https://www.chehejia.com/&apos;, &apos;If-None-Match&apos;: &apos;330d23baa21adfe4b3e09e5632ca26dc&apos;, &apos;Connection&apos;: &apos;keep-alive&apos;&#125;, &apos;requestHeadersText&apos;: &apos;GET /hm.js?4b812fe425e0bb97ce17260602b7a27a HTTP/1.1\r\nHost: hm.baidu.com\r\nConnection: keep-alive\r\nUser-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/65.0.3325.181 HeadlessChrome/65.0.3325.181 Safari/537.36\r\nAccept: */*\r\nReferer: https://www.chehejia.com/\r\nAccept-Encoding: gzip, deflate\r\nCookie: BAIDUID=A866CBEEA134D64FB3E9F0DCA6EC652D:FG=1; BIDUPSID=A866CBEEA134D64FB3E9F0DCA6EC652D; PSTM=1537321927; H_PS_PSSID=1469_21124_26350_22158; HMACCOUNT=14729D0D5CAAFD32\r\nIf-None-Match: 330d23baa21adfe4b3e09e5632ca26dc\r\n&apos;,&apos;connectionReused&apos;: False,&apos;connectionId&apos;: 1993,&apos;remoteIPAddress&apos;: &apos;202.108.23.152&apos;,&apos;remotePort&apos;: 443,&apos;fromDiskCache&apos;: False,&apos;fromServiceWorker&apos;: False,&apos;encodedDataLength&apos;: 282,&apos;timing&apos;: Network.ResourceTiming(&#123; &apos;requestTime&apos;: 26082.14393, &apos;proxyStart&apos;: -1, &apos;proxyEnd&apos;: -1, &apos;dnsStart&apos;: 0.905000000784639, &apos;dnsEnd&apos;: 9.20800000312738, &apos;connectStart&apos;: 9.20800000312738, &apos;connectEnd&apos;: 36.4270000027318, &apos;sslStart&apos;: 17.6940000019385, &apos;sslEnd&apos;: 36.3940000024741, &apos;workerStart&apos;: -1, &apos;workerReady&apos;: -1, &apos;sendStart&apos;: 40.8540000025823, &apos;sendEnd&apos;: 41.1260000000766, &apos;pushStart&apos;: 0, &apos;pushEnd&apos;: 0, &apos;receiveHeadersEnd&apos;: 67.9180000006454&#125;),&apos;protocol&apos;: &apos;http/1.1&apos;,&apos;securityState&apos;: &apos;secure&apos;,&apos;securityDetails&apos;: Network.SecurityDetails(&#123; &apos;protocol&apos;: &apos;TLS 1.2&apos;, &apos;keyExchange&apos;: &apos;ECDHE_RSA&apos;, &apos;keyExchangeGroup&apos;: &apos;P-256&apos;, &apos;cipher&apos;: &apos;AES_128_GCM&apos;, &apos;certificateId&apos;: 0, &apos;subjectName&apos;: &apos;baidu.com&apos;, &apos;sanList&apos;: [&apos;baidu.com&apos;, &apos;click.hm.baidu.com&apos;, &apos;cm.pos.baidu.com&apos;, &apos;log.hm.baidu.com&apos;, &apos;update.pan.baidu.com&apos;, &apos;wn.pos.baidu.com&apos;, &apos;*.91.com&apos;, &apos;*.aipage.cn&apos;, &apos;*.aipage.com&apos;, &apos;*.apollo.auto&apos;, &apos;*.baidu.com&apos;, &apos;*.baidubce.com&apos;, &apos;*.baiducontent.com&apos;, &apos;*.baidupcs.com&apos;, &apos;*.baidustatic.com&apos;, &apos;*.baifae.com&apos;, &apos;*.baifubao.com&apos;, &apos;*.bce.baidu.com&apos;, &apos;*.bcehost.com&apos;, &apos;*.bdimg.com&apos;, &apos;*.bdstatic.com&apos;, &apos;*.bdtjrcv.com&apos;, &apos;*.bj.baidubce.com&apos;, &apos;*.chuanke.com&apos;, &apos;*.dlnel.com&apos;, &apos;*.dlnel.org&apos;, &apos;*.dueros.baidu.com&apos;, &apos;*.eyun.baidu.com&apos;, &apos;*.fanyi.baidu.com&apos;, &apos;*.gz.baidubce.com&apos;, &apos;*.hao123.baidu.com&apos;, &apos;*.hao123.com&apos;, &apos;*.im.baidu.com&apos;, &apos;*.map.baidu.com&apos;, &apos;*.mbd.baidu.com&apos;, &apos;*.mipcdn.com&apos;, &apos;*.news.baidu.com&apos;, &apos;*.nuomi.com&apos;, &apos;*.safe.baidu.com&apos;, &apos;*.smartapps.cn&apos;, &apos;*.ssl2.duapps.com&apos;, &apos;*.su.baidu.com&apos;, &apos;*.trustgo.com&apos;, &apos;*.xueshu.baidu.com&apos;, &apos;apollo.auto&apos;, &apos;baifae.com&apos;, &apos;baifubao.com&apos;, &apos;dwz.cn&apos;, &apos;mct.y.nuomi.com&apos;, &apos;www.baidu.cn&apos;, &apos;www.baidu.com.cn&apos;], &apos;issuer&apos;: &apos;GlobalSign Organization Validation CA - SHA256 - G2&apos;, &apos;validFrom&apos;: 1535440922, &apos;validTo&apos;: 1558848662, &apos;signedCertificateTimestampList&apos;: [Network.SignedCertificateTimestamp(&#123; &apos;status&apos;: &apos;Verified&apos;, &apos;origin&apos;: &apos;Embedded in certificate&apos;, &apos;logDescription&apos;: &apos;DigiCert Log Server 2&apos;, &apos;logId&apos;: &apos;8775BFE7597CF88C43995FBDF36EFF568D475636FF4AB560C1B4EAFF5EA0830F&apos;, &apos;timestamp&apos;: 1535440924361, &apos;hashAlgorithm&apos;: &apos;SHA-256&apos;, &apos;signatureAlgorithm&apos;: &apos;ECDSA&apos;, &apos;signatureData&apos;: &apos;304502204E05C88802BC2A1BF70F5C296E2539A70A543D66336DDE3E2ABF3398C80EFB90022100897394A0343AE7BE8FCAA40BDD0727EE27F0C4D4C66C62DDE59C00DAA4A1337C&apos; &#125;), Network.SignedCertificateTimestamp(&#123; &apos;status&apos;: &apos;Verified&apos;, &apos;origin&apos;: &apos;Embedded in certificate&apos;, &apos;logDescription&apos;: &quot;Google &apos;Pilot&apos; log&quot;, &apos;logId&apos;: &apos;A4B90990B418581487BB13A2CC67700A3C359804F91BDFB8E377CD0EC80DDC10&apos;, &apos;timestamp&apos;: 1535440924467, &apos;hashAlgorithm&apos;: &apos;SHA-256&apos;, &apos;signatureAlgorithm&apos;: &apos;ECDSA&apos;, &apos;signatureData&apos;: &apos;304402201DC652445DB65BBED0FEE596AFC58BE36B4C840614F4187899532B0FF37A0E5902206E9080AAE833CECAD70E8D0AD2D3407338566BBF85A903D3C0707A996805C441&apos; &#125;)], &apos;mac&apos;: None&#125;)], &apos;mac&apos;: None&#125;)&#125;) 0x04 使用pyppeteer安装方式： 1pip3.6 install git+https://github.com/miyakogi/pyppeteer.git@master 演示：vim test.py 1234567891011121314151617181920212223242526#! /usr/bin/env python3# encoding: utf-8import asynciofrom pyppeteer import launchasync def main(): browser = await launch() # 这个也可以设置调用浏览器接口 page = await browser.newPage() await page.goto(&apos;http://www.baidu.com&apos;) await page.waitFor(&quot;body &gt; div.footer-up&quot;) urls = await page.evaluate(&apos;&apos;&apos;() =&gt; &#123; var urls = new Array(); var atags = document.getElementsByTagName(&quot;a&quot;); for(var i=0;i&lt;atags.length;i++)&#123; if (atags[i].getAttribute(&quot;href&quot;))&#123; urls[i] = atags[i].getAttribute(&quot;href&quot;) &#125; &#125; return urls; &#125;&apos;&apos;&apos;) for line in urls : print(line) await browser.close()asyncio.get_event_loop().run_until_complete(main()) 0x05 Spider Cycle1.启用chrome-headless2.设置扫描目标参数(登陆/非登陆, IP随机，USER_AGENT随机)3.通过python调用headless，传入参数4.headless会加载完成渲染过后的html页面内容5.使用lxml进行解析获取链接和参数(一般都四种方式：re, bs4[dom树], xpath, 利用selenium)6.去重复7.循环加载遍历 参考https://www.dust8.com/2018/06/03/pyppeteer%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/https://github.com/miyakogi/pyppeteerhttps://miyakogi.github.io/pyppeteer/reference.htmlhttps://chromedevtools.github.io/devtools-protocol/tot/Networkhttps://blog.csdn.net/gao_zhuang/article/details/31766731]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-io字节流]]></title>
    <url>%2F2018%2F09%2F16%2Fjava-io%E5%AD%97%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[0x01 IO流-字节流(IO流概述及其分类)概念IO流用来处理设备之间的数据传输Java对数据的操作是通过流的方式Java用于操作流的类都在IO包中流按流向分为两种：输入流，输出流。流按操作类型分为两种： * 字节流 : 字节流可以操作任何数据,因为在计算机中任何数据都是以字节的形式存储的 * 字符流 : 字符流只能操作纯字符数据，比较方便。 IO流常用父类1.字节流的抽象父类： * InputStream * OutputStream中文拷贝有问题，由于编码表 2.字符流的抽象父类： * Reader * Writer图片拷贝有问题，由于编码表 IO程序书写使用前，导入IO包中的类使用时，进行IO异常处理使用后，释放资源 0x02 IO流-字节流(FileInputStream)read方法read()一次读取一个字节(8位) 123456789101112131415//IO操作字节流的read方法FileInputStream fis = new FileInputStream(&quot;aaa.txt&quot;); //创建一个文件输入流对象,并关联aaa.txtint b; //定义变量,记录每次读到的字节while((b = fis.read()) != -1) &#123; //将每次读到的字节赋值给b并判断是否是-1 System.out.println(b); //打印每一个字节&#125;fis.close(); //关闭流释放资源 //进制转换byte ivalue = (byte)-1;int ivalue = -1;String binaryString = Integer.toBinaryString(ivalue);System.out.println(&quot;binaryString = &quot; + binaryString);String hexString = Integer.toHexString(ivalue);System.out.println(&quot;binaryString = &quot; + hexString); read()方法读取的是一个字节(8位),为什么返回是int,而不是byte: 因为字节输入流可以操作任意类型的文件,比如图片音频等,这些文件底层都是以二进制形式的存储的,如果每次读取都返回byte,有可能在读到中间的时候遇到111111111。那么这11111111是byte类型的-1,我们的程序是遇到-1就会停止不读了,后面的数据就读不到了,所以在读取的时候用int类型接收。如果11111111会在其前面补上24个0凑足4个字节,那么byte类型的-1就变成int类型的255了这样可以保证整个数据读完,而结束标记的-1就是int类型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;public class Demo1_FileInputStream &#123; /** * @param args * @throws IOException * read()方法读取的是一个字节,为什么返回是int,而不是byte * * 00010100 00100100 01000001 11111111 00000000 * * 10000001 byte类型-1的原码 * 11111110 -1的反码 * 11111111 -1的补码 * * 00000000 00000000 00000000 11111111 */ public static void main(String[] args) throws IOException &#123; //demo1(); FileInputStream fis = new FileInputStream(&quot;xxx.txt&quot;); //创建流对象 int b; while((b = fis.read()) != -1) &#123; System.out.println(b); &#125; fis.close(); &#125; public static void demo1() throws FileNotFoundException, IOException &#123; FileInputStream fis = new FileInputStream(&quot;xxx.txt&quot;); //创建流对象 int x = fis.read(); //从硬盘上读取一个字节 System.out.println(x); int y = fis.read(); System.out.println(y); int z = fis.read(); System.out.println(z); int a = fis.read(); System.out.println(a); int b = fis.read(); System.out.println(b); fis.close(); //关流释放资源 &#125;&#125; write方法write()一次写出一个字节(8位) 123456FileOutputStream fos = new FileOutputStream(&quot;bbb.txt&quot;); //如果没有bbb.txt,会创建出一个, 如果有，则先清空文件内容，再写入//FileOutputStream fos = new FileOutputStream(&quot;bbb.txt&quot;,true); //如果没有bbb.txt,会创建出一个, 如果有，则先清空文件内容，再追加//fos.write(97); //虽然写出的是一个int数,但是在写出的时候会将前面的24个0去掉,所以写出的一个bytefos.write(98);fos.write(99);fos.close(); 演示拷贝图片 12345678910FileInputStream fis = new FileInputStream(&quot;致青春.mp3&quot;); //创建输入流对象,关联致青春.mp3FileOutputStream fos = new FileOutputStream(&quot;copy.mp3&quot;);//创建输出流对象,关联copy.mp3int b;while((b = fis.read()) != -1) &#123; fos.write(b);&#125;fis.close();fos.close(); ** 弊端：字节流一次读写一个字节复制音频，效率太低 ** 原理图 字节数组拷贝之available()方法)案例演示 * int read(byte[] b):一次读取一个字节数组 * write(byte[] b):一次写出一个字节数组 * available()获取读的文件所有的字节个数 ** 弊端:有可能会内存溢出 ** 1234567FileInputStream fis = new FileInputStream(&quot;致青春.mp3&quot;);FileOutputStream fos = new FileOutputStream(&quot;copy.mp3&quot;);byte[] arr = new byte[fis.available()]; //根据文件大小做一个字节数组fis.read(arr); //将文件上的所有字节读取到数组中fos.write(arr); //将数组中的所有字节一次写到了文件上fis.close();fos.close(); 字节流一次读写一个字节数组复制图片和视频 123456789101112FileInputStream fis = new FileInputStream(&quot;致青春.mp3&quot;);FileOutputStream fos = new FileOutputStream(&quot;copy.mp3&quot;);int len;byte[] arr = new byte[1024 * 8]; //自定义字节数组while((len = fis.read(arr)) != -1) &#123; //fos.write(arr); fos.write(arr, 0, len); //写出字节数组写出有效个字节个数&#125;fis.close();fos.close(); 0x03 IO流-字节流(BufferedInputStream和BufferOutputStream拷贝)缓冲思想 * 字节流一次读写一个数组的速度明显比一次读写一个字节的速度快很多， * 这是加入了数组这样的缓冲区效果，java本身在设计的时候， * 也考虑到了这样的设计思想(装饰设计模式后面讲解)，所以提供了字节缓冲区流BufferedInputStream * BufferedInputStream内置了一个缓冲区(数组) * 从BufferedInputStream中读取一个字节时 * BufferedInputStream会一次性从文件中读取8192个, 存在缓冲区中, 返回给程序一个 * 程序再次读取时, 就不用找文件了, 直接从缓冲区中获取 * 直到缓冲区中所有的都被使用过, 才重新从文件中读取8192个BufferedOutputStream * BufferedOutputStream也内置了一个缓冲区(数组) * 程序向流中写出字节时, 不会直接写到文件, 先写到缓冲区中 * 直到缓冲区写满, BufferedOutputStream才会把缓冲区中的数据一次性写到文件里拷贝的代码 123456789101112FileInputStream fis = new FileInputStream(&quot;致青春.mp3&quot;); //创建文件输入流对象,关联致青春.mp3BufferedInputStream bis = new BufferedInputStream(fis); //创建缓冲区对fis装饰FileOutputStream fos = new FileOutputStream(&quot;copy.mp3&quot;); //创建输出流对象,关联copy.mp3BufferedOutputStream bos = new BufferedOutputStream(fos); //创建缓冲区对fos装饰int b;while((b = bis.read()) != -1) &#123; bos.write(b);&#125;bis.close(); //只关装饰后的对象即可bos.close(); 原理图 小数组的读写和带Buffered的读取哪个更快? * 定义小数组如果是8192个字节大小和Buffered比较的话 * 定义小数组会略胜一筹,因为读和写操作的是同一个数组 * 而Buffered操作的是两个数组 flush()方法 * 用来刷新缓冲区的,刷新后可以再次写出close()方法 * 用来关闭流释放资源的的,如果是带缓冲区的流对象的close()方法,不但会关闭流,还会再关闭流之前刷新缓冲区,关闭后不能再写出 0x04 IO流-字节流(字节流读写中文)字节流读取中文的问题(在字符流中可以解决) * 字节流在读中文的时候有可能会读到半个中文,造成乱码字节流写出中文的问题 * 字节流直接操作的字节,所以写出中文必须将字符串转换成字节数组 * 写出回车换行 write(“\r\n”.getBytes()); 0x05 IO流-字节流(流的标准处理异常代码1.6版本及其以前)try finally嵌套 123456789101112131415161718FileInputStream fis = null;FileOutputStream fos = null;try &#123; fis = new FileInputStream(&quot;aaa.txt&quot;); fos = new FileOutputStream(&quot;bbb.txt&quot;); int b; while((b = fis.read()) != -1) &#123; fos.write(b); &#125;&#125; finally &#123; try &#123; if(fis != null) fis.close(); &#125;finally &#123; if(fos != null) fos.close(); &#125;&#125; 0x06 IO流-字节流(流的标准处理异常代码1.7版本)try close 12345678910111213141516try( FileInputStream fis = new FileInputStream(&quot;aaa.txt&quot;); FileOutputStream fos = new FileOutputStream(&quot;bbb.txt&quot;); MyClose mc = new MyClose();)&#123; int b; while((b = fis.read()) != -1) &#123; fos.write(b); &#125;&#125;class MyClose implements AutoCloseable &#123; public void close() &#123; System.out.println(&quot;get off&quot;); &#125;&#125; 原理 * 在try()中创建的流对象必须实现了AutoCloseable这个接口,如果实现了,在try后面的{}(读写代码)执行后就会自动调用,流对象的close方法将流关掉 0x07 IO流-字节流(图片加密)给图片加密 12345678910BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;a.jpg&quot;));BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;b.jpg&quot;));int b;while((b = bis.read()) != -1) &#123; bos.write(b ^ 123);&#125;bis.close();bos.close(); 0x08 IO流-字节流(拷贝文件)在控制台录入文件的路径,将文件拷贝到当前项目下 123456789101112131415Scanner sc = new Scanner(System.in);System.out.println(&quot;请输入一个文件路径&quot;);String line = sc.nextLine(); //将键盘录入的文件路径存储在line中File file = new File(line); //封装成File对象FileInputStream fis = new FileInputStream(file);FileOutputStream fos = new FileOutputStream(file.getName());int len;byte[] arr = new byte[8192]; //定义缓冲区while((len = fis.read(arr)) != -1) &#123; fos.write(arr,0,len);&#125;fis.close();fos.close(); 0x09 IO流-字节流(录入数据拷贝到文件)将键盘录入的数据拷贝到当前项目下的text.txt文件中,键盘录入数据当遇到quit时就退出 123456789101112Scanner sc = new Scanner(System.in);FileOutputStream fos = new FileOutputStream(&quot;text.txt&quot;);System.out.println(&quot;请输入:&quot;);while(true) &#123; String line = sc.nextLine(); if(&quot;quit&quot;.equals(line)) break; fos.write(line.getBytes()); fos.write(&quot;\r\n&quot;.getBytes());&#125;fos.close();]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-file类]]></title>
    <url>%2F2018%2F09%2F16%2Fjava-file%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[0x01 File类(File类的概述和构造方法)File类的概述 * File更应该叫做一个路径 * 文件路径或者文件夹路径 * 路径分为绝对路径和相对路径 * 绝对路径是一个固定的路径,从盘符开始 * 相对路径相对于某个位置,在eclipse下是指当前项目下,在dos下 * 查看API指的是当前路径 * 文件和目录路径名的抽象表示形式构造方法 * File(String pathname)：根据一个路径得到File对象 * File(String parent, String child):根据一个目录和一个子文件/目录得到File对象 * File(File parent, String child):根据一个父File对象和一个子文件/目录得到File对象 1234567891011121314151617181920212223242526272829303132333435363738import java.io.File;public class Demo1_File &#123; /** * File(String pathname)：根据一个路径得到File对象 * File(String parent, String child):根据一个目录和一个子文件/目录得到File对象 * File(File parent, String child):根据一个父File对象和一个子文件/目录得到File对象 */ public static void main(String[] args) &#123; //demo1(); //demo2(); File parent = new File(&quot;D:\\ee\\day19\\video&quot;); String child = &quot;001_今日内容.avi&quot;; File file = new File(parent, child); System.out.println(file.exists()); System.out.println(parent.exists()); &#125; public static void demo2() &#123; String parent = &quot;D:\\ee\\day19\\video&quot;; String child = &quot;001_今日内容.avi&quot;; File file = new File(parent,child); System.out.println(file.exists()); &#125; public static void demo1() &#123; File file = new File(&quot;D:\\ee\\day19\\video\\001_今日内容.avi&quot;); System.out.println(file.exists()); File file2 = new File(&quot;xxx.txt&quot;); System.out.println(file2.exists()); File file3 = new File(&quot;yyy.txt&quot;); System.out.println(file3.exists()); &#125;&#125; 0x02 File类(File类的创建功能)创建功能 * public boolean createNewFile():创建文件 如果存在这样的文件，就不创建了 * public boolean mkdir():创建文件夹 如果存在这样的文件夹，就不创建了 * public boolean mkdirs():创建文件夹,如果父文件夹不存在，会帮你创建出来 * 注意事项： * 如果你创建文件或者文件夹忘了写盘符路径，那么，默认在项目路径下。 0x02 File类(File类的重命名和删除功能)重命名和删除功能 * public boolean renameTo(File dest):把文件重命名为指定的文件路径 * public boolean delete():删除文件或者文件夹重命名注意事项 * 如果路径名相同，就是改名。 * 如果路径名不同，就是改名并剪切。删除注意事项： * Java中的删除不走回收站。 * 要删除一个文件夹，请注意该文件夹内不能包含文件或者文件夹 0x02 File类(File类的判断功能)判断功能 * public boolean isDirectory():判断是否是目录 * public boolean isFile():判断是否是文件 * public boolean exists():判断是否存在 * public boolean canRead():判断是否可读 * public boolean canWrite():判断是否可写 * public boolean isHidden():判断是否隐藏 0x03 File类(File类的获取功能)获取功能 * public String getAbsolutePath()：获取绝对路径 * public String getPath():获取路径 * public String getName():获取名称 * public long length():获取长度。字节数 * public long lastModified():获取最后一次的修改时间，毫秒值 * public String[] list():获取指定目录下的所有文件或者文件夹的名称数组 * public File[] listFiles():获取指定目录下的所有文件或者文件夹的File数组 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.io.File;import java.text.SimpleDateFormat;import java.util.Date;public class Demo5_FileMethod &#123; /** * * A:获取功能 * public String getAbsolutePath()：获取绝对路径 * public String getPath():获取路径 * public String getName():获取名称 * public long length():获取长度。字节数 * public long lastModified():获取最后一次的修改时间，毫秒值 * public String[] list():获取指定目录下的所有文件或者文件夹的名称数组 * public File[] listFiles():获取指定目录下的所有文件或者文件夹的File数组 */ public static void main(String[] args) &#123; //demo1(); File dir = new File(&quot;D:\\双元课堂\\day19\\video&quot;); String[] arr = dir.list(); //仅为了获取文件名 for (String string : arr) &#123; System.out.println(string); &#125; File[] subFiles = dir.listFiles(); for (File file : subFiles) &#123; //获取文件对象 System.out.println(file); &#125; &#125; public static void demo1() &#123; File file1 = new File(&quot;ccc.txt&quot;); File file2 = new File(&quot;D:\\ee\\day19\\ccc.txt&quot;); //System.out.println(file1.getAbsolutePath()); //获取绝对路径 //System.out.println(file2.getAbsolutePath()); //System.out.println(file1.getPath()); //获取构造方法中传入路径 //System.out.println(file2.getPath()); // System.out.println(file1.getName()); //获取文件或者文件的名字// System.out.println(file2.getName());// // System.out.println(file1.length()); Date d = new Date(file1.lastModified()); //文件的最后修改时间 SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); System.out.println(sdf.format(d)); &#125;&#125; 0x04 File类(文件名称过滤器的概述及使用)文件名称过滤器的概述 * public String[] list(FilenameFilter filter) * public File[] listFiles(FileFilter filter)文件名称过滤器的使用 * 需求：判断E盘目录下是否有后缀名为.jpg的文件，如果有，就输出该文件名称 1234567891011File dir = new File(&quot;D:\\双元课堂\\day19\\video&quot;);String[] arr = dir.list(new FilenameFilter() &#123; @override public boolean accept(File dir, String name) &#123; File file = new File(dir, name); return file.isFile() &amp;&amp; file.getName().endsWith(&quot;.jpg&quot;); &#125;&#125;);for (String string : arr)&#123; System.out.println(string);&#125; 源码分析 * 带文件名称过滤器的list()方法的源码 0x05 File类(递归)5的阶乘 12345678910111213141516171819202122232425262728293031323334353637383940public class Demo8_Digui &#123; /** * @param args * 递归:方法自己调用自己 * 5! * 5 * 4 * 3 * 2 * 1 * * 5 * fun(4)(代表4!) * 4 * fun(3)(代表3!) * 3 * fun(2)(代表2!) * 2 * fun(1)(代表1!) * 递归的弊端:不能调用次数过多,容易导致栈内存溢出 * 递归的好处:不用知道循环次数 * * 构造方法是否可以递归调用? * 构造方法不能使用递归调用 * * 递归调用是否必须有返回值? * 不一定(可以有,也可以没有) */ public static void main(String[] args) &#123; /*int result = 1; for(int i = 1; i &lt;= 5; i++) &#123; result = result * i; &#125; System.out.println(result);*/ System.out.println(fun(6000)); &#125; public static int fun(int num) &#123; if(num == 1) &#123; return 1; &#125;else &#123; return num * fun(num - 1); &#125; &#125;&#125; 0x06 File类(练习)需求:从键盘输入接收一个文件夹路径,打印出该文件夹下所有的.java文件名 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.io.File;import java.io.FileReader;import java.util.Scanner;public class Test5 &#123; /** * 需求:从键盘输入接收一个文件夹路径,打印出该文件夹下所有的.java文件名 * * 分析: * 从键盘接收一个文件夹路径 * 1,如果录入的是不存在,给与提示 * 2,如果录入的是文件路径,给与提示 * 3,如果是文件夹路径,直接返回 * * 打印出该文件夹下所有的.java文件名 * 1,获取到该文件夹路径下的所有的文件和文件夹,存储在File数组中 * 2,遍历数组,对每一个文件或文件夹做判断 * 3,如果是文件,并且后缀是.java的,就打印 * 4,如果是文件夹,就递归调用 */ public static void main(String[] args) &#123; File dir = getDir(); printJavaFile(dir); &#125; /* * 获取键盘录入的文件夹路径 * 1,返回值类型File * 2,不需要有参数 */ public static File getDir() &#123; Scanner sc = new Scanner(System.in); //创建键盘录入对象 System.out.println(&quot;请输入一个文件夹路径&quot;); while(true) &#123; String line = sc.nextLine(); //将键盘录入的文件夹路径存储 File dir = new File(line); //封装成File对象 if(!dir.exists()) &#123; System.out.println(&quot;您录入的文件夹路径不存在,请重新录入&quot;); &#125;else if(dir.isFile()) &#123; System.out.println(&quot;您录入的是文件路径,请重新录入文件夹路径&quot;); &#125;else &#123; return dir; &#125; &#125; &#125; /* * 获取文件夹路径下的所.java文件 * 1,返回值类型 void * 2,参数列表File dir */ public static void printJavaFile(File dir) &#123; //1,获取到该文件夹路径下的所有的文件和文件夹,存储在File数组中 File[] subFiles = dir.listFiles(); //2,遍历数组,对每一个文件或文件夹做判断 for (File subFile : subFiles) &#123; //3,如果是文件,并且后缀是.java的,就打印 if(subFile.isFile() &amp;&amp; subFile.getName().endsWith(&quot;.java&quot;)) &#123; System.out.println(subFile); //4,如果是文件夹,就递归调用 &#125;else if (subFile.isDirectory())&#123; printJavaFile(subFile); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-异常处理]]></title>
    <url>%2F2018%2F09%2F16%2Fjava-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[0x01 异常处理JVM默认是如何处理异常的 * main函数收到这个问题时,有两种处理方式: * a:自己将该问题处理,然后继续运行 * b:自己没有针对的处理方式,只有交给调用main的jvm来处理 * jvm有一个默认的异常处理机制,就将该异常进行处理. * 并将该异常的名称,异常的信息.异常出现的位置打印在了控制台上,同时将程序停止运行 * 编译时异常 * Java程序必须显示处理，否则程序就会发生错误，无法通过编译 * 运行时异常 * 无需显示处理，也可以和编译时异常一样处理0x02 异常处理的方式try…catch…finally * try catch * try catch finally * try finallythrows * 定义功能方法时，需要把出现的问题暴露出来让调用者去处理。 * 那么就通过throws在方法上标识。 0x03 try…catch…finallyfinally的特点 * 被finally控制的语句体一定会执行 * 特殊情况：在执行到finally之前jvm退出了(比如System.exit(0))finally的作用 * 用于释放资源，在IO流操作和数据库操作中会见到 123456789101112131415161718192021222324252627finally演示public class Demo7_Finally &#123; /** * * A:finally的特点 * 被finally控制的语句体一定会执行 * 特殊情况：在执行到finally之前jvm退出了(比如System.exit(0)) * B:finally的作用 * 用于释放资源，在IO流操作和数据库操作中会见到 * C:案例演示 * finally关键字的特点及作用 *return语句相当于是方法的最后一口气,那么在他将死之前会看一看有没有finally帮其完成遗愿,如果有就将finally执行 *后在彻底返回 */ public static void main(String[] args) &#123; try &#123; System.out.println(10/0); &#125; catch (Exception e) &#123; System.out.println(&quot;除数为零了&quot;); System.exit(0); //退出jvm虚拟机 return; &#125; finally &#123; System.out.println(&quot;看看我执行了吗&quot;); &#125; &#125;&#125; 0x04 throwsthrows和throw的区别 * a:throws * 用在方法声明后面，跟的是异常类名 * 可以跟多个异常类名，用逗号隔开 * 表示抛出异常，由该方法的调用者来处理 * b:throw * 用在方法体内，跟的是异常对象名 * 只能抛出一个异常对象名 * 表示抛出异常，由方法体内的语句处理Throws演示 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Demo6_Exception &#123; /** * * A:throws的方式处理异常 * 定义功能方法时，需要把出现的问题暴露出来让调用者去处理。 * 那么就通过throws在方法上标识。 * B:案例演示 * 举例分别演示编译时异常和运行时异常的抛出 * 编译时异常的抛出必须对其进行处理 * 运行时异常的抛出可以处理也可以不处理 * @throws Exception */ public static void main(String[] args) throws Exception &#123; Person p = new Person(); p.setAge(-17); System.out.println(p.getAge()); &#125;&#125;class Person &#123; private String name; private int age; public Person() &#123; super(); &#125; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) throws AgeOutOfBoundsException &#123; if(age &gt;0 &amp;&amp; age &lt;= 150) &#123; this.age = age; &#125;else &#123; //Exception e = new Exception(&quot;年龄非法&quot;); //throw e; throw new AgeOutOfBoundsException(&quot;年龄非法&quot;); &#125; &#125; &#125;]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn-基础]]></title>
    <url>%2F2018%2F09%2F15%2Fpwn-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[0x01 背景知识堆栈：内存中的一个数据结构。寄存器：CPU的存储器，速度快。内存：CPU和硬盘之间的通道。 汇编AT&amp;T : * 寄存器 – 以% 作为前缀，$作为常量前缀。 * 指令 – 源操作数在左边，目的操作数在右边；例如：eax寄存器加4: add $0x4 %eax 。 * CPU –可以在多种CPU上都可以使用。Intel : * 寄存器 – 寄存器指令无前缀 * 指令 – 目的操作数在左边，源操作数在右边；例如：eax寄存器加4: add eax 0x4。 * CPU – 只用在自家的x86系列CPU。ARM： * 寄存器 – * 指令 – * CPU – 只用在ARM系列CPU上。 内存现代操作系统内存通常是以分段的形式存放不同类型的信息的: 函数调用栈就是分段的一个部分（Stack Segment）。 内存分段还包括堆（Heap Segment）用于存放程序运行中动态分配的内存，例如C语言中的 malloc() 和 free() 函数就是在堆上分配和释放内存。 数据段（Data Segment）存储已经初始化且初值不为0的全局变量和静态局部变量。 BSS段存储未初始化或初值为0的全局变量和静态局部变量，这两段数据都有可写的属性。 代码段（Code Segment）存储可执行代码和只读常量（如常量字符串），属性可读可执行，但通常不可写。 栈栈：使用了栈数据结构，先进后出, 同时栈是由高地址向低地址增长。当把数据放入栈时，我们把数据push进入；当从栈取出数据时，我们把数据pop出来。栈随着数据被压入或者弹出而增长或者减小。最新压入栈的项被认为是在“栈的顶部”。当从栈中弹出一个项时，我们得到的是位于栈最顶部的那一个，就像给弹夹上子弹，只能在顶部进行操作。在x86体系中，栈顶由堆栈指针寄存器ESP来标记，它是一个32位寄存器，里面存放着最后一个压入栈顶的项的内存地址。正因为有它，我们才能够随时操作到需要的项。需要注意的是，栈顶是朝着地内存方向增长的。栈应该被看成一个短期存储数据的地方，存在在栈中的数据项没有名字，只是按照后进先出来操作罢了。栈经常可以用来在寄存器紧张的情况下，临时存储一些数据，并且十分安全。当寄存器空闲后，我们可以从栈中弹出该数据，供寄存器使用。这种临时存放数据的特性，使得它经常用来存储局部变量，函数参数，上下文环境等。 linux_64与linux_86的区别主要有两点：首先是内存地址的范围由32位变成了64位。但是可以使用的内存地址不能大于0x00007fffffffffff，否则会抛出异常。其次是函数参数的传递方式发生了改变，x86中参数都是保存在栈上,但在x64中的前六个参数依次保存在RDI, RSI, RDX, RCX, R8和 R9中，如果还有更多的参数的话才会保存在栈上。 栈溢出： * 覆盖ebp寄存器后面的返回地址，执行自己的想要的地址上的代码，看看函数调用发生时，如果要让 eip 指向攻击指令，需要哪些准备？这时，eip 会指向原程序中某个指定的函数，我们没法通过改写返回地址来控制了，不过我们可以“偷梁换柱”－－将原本指定的函数在调用时替换为其他函数。 栈溢出技术包括以下： * 修改返回地址，让其指向溢出数据中的一段指令（shellcode） * 修改返回地址，让其指向内存中已有的某个函数（return2libc） * 修改返回地址，让其指向内存中已有的一段指令（ROP） * 修改某个被调用函数的地址，让其指向另一个函数（hijack GOT） 堆堆:再来看我拍的照片，为于.bss段和栈之间有一段空余内存，C程序经常使用这种剩余内存空间来为那些为于堆内存中的，“已经在运行中”的变量分配空间。我们常说的堆就存在于这里。相反，堆相对于栈，更加强调需要进行控制。常见的就是我们手动申请，手动释放。因此可以分配更大的空间，但开销也会更多。来段代码： 寄存器在32位环境下:32位x86架构下的寄存器可以被简单分为通用寄存器和特殊寄存器两类，通用寄存器在大部分汇编指令下是可以任意使用的（虽然有些指令规定了某些寄存器的特定用途），而特殊寄存器只能被特定的汇编指令使用，不能用来任意存储数据。32位x86架构下的通用寄存器包括一般寄存器（eax、ebx、ecx、edx），索引寄存器（esi、edi），以及堆栈指针寄存器（esp、ebp）。一般寄存器用来存储运行时数据，是指令最常用到的寄存器，除了存放一般性的数据，每个一般寄存器都有自己较为固定的独特用途。 eax 被称为累加寄存器（Accumulator），用以进行算数运算和返回函数结果等。 ebx 被称为基址寄存器（Base），在内存寻址时（比如数组运算）用以存放基地址。 ecx 被称为记数寄存器（Counter），用以在循环过程中记数。 edx 被称为数据寄存器（Data），常配合 eax 一起存放运算结果等数据。索引寄存器通常用于字符串操作中: esi 指向要处理的数据地址（Source Index）。 edi 指向存放处理结果的数据地址（Destination Index）。堆栈指针寄存器用于保存函数在调用栈中的状态: esp 用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化。 ebp 用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。 eip 用来存储即将执行的程序指令的地址，cpu 依照 eip 的存储内容读取指令并执行，eip 随之指向相邻的下一条指令，如此反复，程序就得以连续执行指令。32位x86架构下的特殊寄存器包括段地址寄存器（ss、cs、ds、es、fs、gs），标志位寄存器（EFLAGS），以及指令指针寄存器（eip）。 在64位环境下:函数的调用所需要的参数是优先通过寄存器来进行的。寄存器的顺序如下：rdi,rsi,rdx,rcx,r8,r9。当一个函数有大于6个整形参数，则超出的部分会通过栈来传递，这个情况少见。由于64位下，是优先通过寄存器来传参，所以不能像在32位环境下直接去布置栈上的数据来exp。比如：我们想要传入一个参数，那这个参数需要被布置到寄存器rdi中，这时我们可以寻找诸如pop rdi;ret的代码片段，从而在执行完pop rdi后把栈上布置好的数据存放到寄存器rdi中后能够再次控制程序执行流（ret）。X86-64有16个64位寄存器，分别是：%rax，%rbx，%rcx，%rdx，%esi，%edi，%rbp，%rsp，%r8，%r9，%r10，%r11，%r12，%r13，%r14，%r15。还有几个特殊的指针（寄存器）： rip、rbp和rsp。其中rip是指令指针，cpu会把rip指向的内容当作指令执行。rbp指向当前栈帧的底部。rsp指向当前栈帧的顶部。%rax 作为函数返回值使用。%rsp 栈指针寄存器，指向栈顶%rdi，%rsi，%rdx，%rcx，%r8，%r9 用作函数参数，依次对应第1参数，第2参数。。。%rbx，%rbp，%r12，%r13，%14，%15 用作数据存储，遵循被调用者使用规则，简单说就是随便用，调用子函数之前要备份它，以防他被修改%r10，%r11 用作数据存储，遵循调用者使用规则，简单说就是使用之前要先保存原值 代码演示1234567891011121314#include &lt;stdio.h&gt; int a = 0; //全局初始化区 char *p1; //全局未初始化区 int main() &#123; int b; //栈 char s[] = &quot;abc&quot;; //栈 char *p2; //栈 char *p3 = &quot;123456&quot;; //123456\0在常量区，p3在栈上 static int c =0; //全局（静态）初始化区 p1 = (char *)malloc(10); //堆 p2 = (char *)malloc(20); //堆 return 0; &#125; 0x02 环境准备系统环境：Ubuntu 14.04 64bit iso – http://mirrors.163.com/ubuntu-releases/14.04/ubuntu-14.04.5-desktop-amd64.iso安装pwntools： pip install pwntools – https://pwntoolsdocinzh-cn.readthedocs.io/en/master/intro.html 1234$ apt-get update$ apt-get install python2.7 python-pip python-dev git libssl-dev libffi-dev build-essential$ pip install --upgrade pip$ pip install --upgrade pwntools 安装必备工具：sudo apt-get install nasm,gcc,gdb,binutils,hexedit安装32位libc库：sudo apt-get install libc6-dev-i386qira：qira – https://github.com/BinaryAnalysisPlatform/qirapeda：peda – https://github.com/longld/pedagdb-peda：gdb方便调试的工具，类似的工具有gef，gdbinit – http://blog.csdn.net/gatieme/article/details/63254211objdump和readelf：可以很快的知道elf程序中的关键信息ida pro ：强大的反编译工具one_gadget：可以快速的寻找libc中的调用exec(‘bin/sh’)的位置libc-database： 可以通过泄露的libc的某个函数地址查出远程系统是用的哪个libc版本PEiD：检测大多数编译语言、病毒和加密的壳ROPgadget：强大的rop利用工具checksec：可以很方便的知道elf程序的安全性和程序的运行平台cyclic: 找出返回地址具体偏移 12$ cyclic 3000 #生成3000个字符$ cyclic -l 0x56415862 #根据奔溃时的地址信息找到偏移 libcdb： 0x03 操作流程1.判断操作系统位数(32,64): 使用file,和 checksec, strings都可以查看程序是否为32,642.判断已有的保护: * 【1】RELRO：RELRO会有Partial RELRO和FULL RELRO，如果开启FULL RELRO，意味着我们无法修改got表 * 【2】Stack：如果栈中开启Canary found，那么就不能用直接用溢出的方法覆盖栈中返回地址，而且要通过改写指针与局部变量、leak canary、overwrite canary的方法来绕过 * 【3】NX：NX enabled如果这个保护开启就是意味着栈中数据没有执行权限，以前的经常用的call esp或者jmp esp的方法就不能使用，但是可以利用rop这种方法绕过 * 【4】PIE：PIE enabled如果程序开启这个地址随机化选项就意味着程序每次运行的时候地址都会变化，而如果没有开PIE的话那么No PIE (0x400000)，括号内的数据就是程序的基地址 * 【5】FORTIFY：FORTIFY_SOURCE机制对格式化字符串有两个限制(1)包含%n的格式化字符串不能位于程序内存中的可写地址。(2)当使用位置参数时，必须使用范围内的所有参数。所以如果要使用%7$x，你必须同时使用1,2,3,4,5和6。 * 【6】Canary: 编译程序时还可以设置某些编译选项，使程序在运行时会在函数栈上的 ebp 地址和返回地址之间生成一个特殊的值，这个值被称为“金丝雀”（关于这个典故，请大家自行谷歌）。这样一旦发生了栈溢出并覆盖了返回地址，这个值就会被改写，从而实现函数栈的越界检查。 测试：gcc test.c -o pwn -O0 -fno-stack-protector 选项 -O0 表示不进行任何优化， -fno-stack-protector表示无canary保护。 3.静态分析: IDA进行查看汇编类型(AT&amp;T, Intel, ARM)4.模糊测试分析报错点是否存在溢出 参考** 背景知识： ** https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/1.5.1_c_basic.htmlhttps://www.jianshu.com/p/5a4f2d78cb53 – x64函数调用分析–寄存器指令和栈https://www.anquanke.com/post/id/86383 – ARM汇编参考https://www.cnblogs.com/33debug/p/6773059.html — 栈的使用https://blog.csdn.net/bjbz_cxy/article/details/79467688 – x86汇编指令集大全https://www.jianshu.com/p/5910b9e63644http://blog.sina.com.cn/s/blog_5420e0000101a0w1.htmlhttp://www.kerneltravel.net/journal/v/mem.htm** 测试站点： ** Pwnable.kr ( http://pwnable.kr )：有不同难度的题目，内容涵盖多个领域，界面很可爱https://etenal.me/archives/972 –pwn.kr 练习解说http://www.secist.com/archives/3613.html –pwn.kr 练习解说2Pwnhub ( https://pwnhub.cn/index)：长亭出品，题目丰富，积分排名机制，还可以兑换奖品，快来一起玩耍吧！http://Pwnable.tw（ Pwnable.tw )：由台湾CTF爱好者组织的练习平台，质量较高http://www.freebuf.com/column/183879.html – 实战测试演示Exploit Exercises ( https://exploit-exercises.com )：有比较完善的题目难度分级，还有虚拟机镜像供下载]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客转移]]></title>
    <url>%2F2018%2F09%2F14%2F%E5%8D%9A%E5%AE%A2%E8%BD%AC%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[0x01 扯淡背景欢迎来到风暴大陆，相传在这个大陆的远古时期经历一场非常大的灾难，每天都会有一群来自异域星空的生命体经常攻击各地的城池，给城池带来了无数资源的损失 … 0x02 主题切入There are something maybe you want or not, but I hope you continue focus on it. older blog: https://blog.csdn.net/qq_39325340]]></content>
      <categories>
        <category>misc</category>
      </categories>
      <tags>
        <tag>novels</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-运算符]]></title>
    <url>%2F2018%2F08%2F28%2Fjava-%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[0x01 &amp;&amp;和&amp;的区别* 最终结果一样。 &amp;&amp;具有短路效果。左边是false，右边不执行。 &amp;是无论左边是false还是true,右边都会执行0x02 同理||和|的区别* 最终结果一样。 ||具有短路效果。左边是true，右边不执行。 |是无论左边是false还是true,右边都会执行0x03 位运算符有哪些(以二进制形式进行运算, 以补码形式计算)* &amp;,|,^,~ ,&gt;&gt;,&gt;&gt;&gt;,&lt;&lt;案例演示 * &amp;,|,^,~ 的用法 &amp;:有0则0 |:有1则1 ^:相同则0，不同则1 ~:按位取反 ^的特点：一个数据对另一个数据位异或两次，该数本身不变 案例演示 &gt;&gt;,&gt;&gt;&gt;,&lt;&lt;的用法: * &lt;&lt;:左移 左边最高位丢弃，右边补齐0[向左移几位，就是乘以2的几次幂] * &gt;&gt;:右移 最高位是0，左边补齐0;最高为是1，左边补齐1[向右移几位，就是除以2的几次幂] * &gt;&gt;&gt;:无符号右移 无论最高位是0还是1，左边补齐0 * 最有效率的算出2 * 8的结果: 2&lt;&lt;3 三元运算符的格式 * (关系表达式) ? 表达式1 : 表达式2; 0x04 如何实现键盘录入呢?导包* 格式：import java.util.Scanner; * 位置：在class上面。创建键盘录入对象格式：Scanner sc = new Scanner(System.in);通过对象获取数据格式：int x = sc.nextInt();所谓的水仙花数是指一个三位数，其各位数字的立方和等于该数本身。举例：153就是一个水仙花数。153 = 111 + 555 + 333 = 1 + 125 + 27 = 153 12345678for(int i = 100; i &lt;= 999; i++)&#123; int ge = i % 10; int shi = i / 10 % 10; int bai = i / 10 % 10; if(ge * ge * ge + shi * shi * shi + bai * bai * bai == i) &#123; Sytem.out.println(i); &#125;&#125; 0x05 函数方法A:为什么要有方法* 提高代码的复用性 B:什么是方法* 完成特定功能的代码块。 C:方法的格式修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) { 方法体语句; return 返回值; } D:方法的格式说明* 修饰符：目前就用 public static 返回值类型：就是功能结果的数据类型。 方法名：符合命名规则即可。方便我们的调用。 参数： * 实际参数：就是实际参与运算的。 * 形式参数；就是方法定义上的，用于接收实际参数的。 参数类型：就是参数的数据类型 参数名：就是变量名 方法体语句：就是完成功能的代码。 return：结束方法的。 返回值：就是功能的结果，由return带给调用者。F:方法重载* 在同一个类中，方法名相同，参数列表不同。与返回值类型无关。 * 参数列表不同： * A:参数个数不同 * B:参数类型不同 * C:参数的顺序不同(算重载,但是在开发中不用)]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c-基础1]]></title>
    <url>%2F2018%2F05%2F26%2Fc-%E5%9F%BA%E7%A1%801%2F</url>
    <content type="text"><![CDATA[shell操作基本格式123456#!/bin/bash #执行shell的脚本程序# 注释str=&quot;hello world&quot;echo &quot;sdf&quot; \ #其中&quot;\&quot;为换行符号# 输出helloworldecho $str shell中的特殊字符12345678910111213141516# 通配符*:匹配一个或者多个?:匹配任意一个字符[]:匹配方括号中限定的任意一个字符!:表示方括号中列出的字符以外的其它字符# 引号双引号：由双引号扩起来的字符，除了$,反引号`,反斜杠\ 保留其特殊功能，其它字符均作为普通字符对待。如一下: echo &quot;current dir is: `pwd`&quot;单引号：反引号：# 输入输出重定向符号&gt;:标准输入重定向&lt;:标准输出重定向&gt;&gt;:追加内容在后面，而不破坏文件原有的内容 shell中变量的使用1234567891011121314#对变量进行赋值，等号两边不能有空格str=&quot;sdfh&quot;echo $str#如果出现了混淆，前面有定义str，可以使用括号来区分echo $(str) --这个语法有点问题unset str #清除变量$0:脚本名称$#:命令行参数个数$*:所有命令行参数$[1-n]:第1-n个命令行参数$!:后台运行的最后一个进程的标识符$$:当前进程标识符$?:命令的退出状态，0表示没有错误 条件测试12345678910111213141516171819202122232425262728293031323334注意：[ ] 可以使用 -a, -o的参数，但是必须在 [ ] 中括号内，判断条件;[ -z &quot;$pid&quot; ] 单对中括号变量必须要加双引号[[ -z $pid ]] 双对括号，变量不用加双引号expr: 命令可以实现数值运算、数值或字符串比较、字符串匹配、字符串提取、字符串长度计算等功能。它还具有几个特殊功能，判断变量或参数是否为整数、是否为空、是否为0等。字符串测试符:=:两个字符串相等!=:两个字符串不相等-z:字符串为空-n:字符串不为空数值测试符:-eq:两个数相等-ne:两个数不相等-gt:第一个数大于第二个数-lt:第一个数小于第二个数-le:第一个数小于等于第二个数-ge:第一个数大于等于第二个数文件状态测试:-f:是否为普通文件-d:是否为目录-c:是否为字符设备文件-b:是否为块设备文件-s:文件是否为零-r:用户对文件是否有读权限-w:用户对文件是否有写权限-x:用户对文件是否有执行权限逻辑操作:-a:逻辑与-o:逻辑或!:逻辑非 shell中的结构控制语句1234567891011121314151617181920212223# if语句:if 提交1then 命令1elif 条件2then 命令2else 命令3fi# case语句case 字符串 in模式1） 命令1 ;;模式2) 命令2 ;;*) 命令n ;;esac 12345678910111213141516171819202122232425262728293031323334353637383940# for循环语句for 变量名 in [列表]do 命令1donefor l3 in A B Cdo echo $l3donefor x in `seq 1 10`do echo $xdoneseq选项：-s:指定分隔符，默认为换行符-w:等宽输出，位数不足的前面补0-f:格式化输出# while循环[条件成立，则循环]counter=1while [ $counter -lt 3 ]do counter=`expr $counter + 1` #数值累加 echo $counterdoneecho -n "请输入一个数字："read IN #读取数字# util循环[条件不成立，则循环]util 条件do 命令1donebreak:跳出循环continue:跳出当前循环，执行下一次循环 定义shell函数123456789sum() &#123; SUM=`expr $1 + $2` echo $SUM&#125;echo -n "请输入两个数字："read x y #读取数字echo -n "$x + $y = "sum $x $y c语言介绍C语言主要用于底层开发，例如：Windows、Linux、Unix 等操作系统的内核90%以上都使用C语言开发；开发硬件驱动，让硬件和操作系统连接起来，这样用户才能使用硬件、程序员才能控制硬件；单片机和嵌入式属于软硬件的结合，有很多使用C语言的地方；开发系统组件或服务，用于支撑上层应用；编写PHP扩展，增强PHP的功能；如果对软件某个模块（例如算法和搜索部分）的效率要求较高，也可以使用C语言来开发。 既然C语言能做这么多事情，为什么很多初学者学完C语言以后仍然非常迷茫，只能编写没有界面的控制台程序呢？ 这是因为，C语言仅仅是一个工具，它的标准库也很简单，只提供了最基本的功能，如果希望开发出实用的程序，往往还需要学习其他方面的知识。例如：开发硬件驱动要学习数字电路，了解 Windows 或 Linux 内核，阅读硬件厂商的接口说明书；从事嵌入式开发要学习数字电路、模拟电路、ARM、Linux、Qt等；开发PC软件要学习Windows编程，了解 GTK。 基础 语法，注释 123456789#include "stdio.h"int main(int argc, char * argv[]) //argc参数个数，argv参数数组&#123; // 执行系统命令 system("start calc"); system("pause"); return 0;&#125; c语言大致可以分为两类：一类为说明语句，用来描述数据，决定内存的分配；另一类为执行语句，用来对数据进行操作，决定内存的内容； 注意：c语言区分大小写，关键字都必须使用小写字母 转义字符 12345678910111213\a 响铃\b 退格\f 换页\n\r\t 水平制表\v 垂直制表\\\'\"\0 空字符\ddd\xhh 1到2位十六进制所代表的任意字符 数据类型基本类型：char,int,float,double,void(空值型)聚合类型：数组，结构，联合和枚举等各种数据类型转化； 基本类型123456789101112131415类型 存储大小 值范围char 1 字节 -128 到 127 或 0 到 255unsigned char 1 字节 0 到 255signed char 1 字节 -128 到 127int 2 或 4 字节 -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647unsigned int 2 或 4 字节 0 到 65,535 或 0 到 4,294,967,295short 2 字节 -32,768 到 32,767unsigned short 2 字节 0 到 65,535long 4 字节 -2,147,483,648 到 2,147,483,647unsigned long 4 字节 0 到 4,294,967,295类型 存储大小 值范围 精度float 4 字节 1.2E-38 到 3.4E+38 6 位小数double 8 字节 2.3E-308 到 1.7E+308 15 位小数long double 16 字节 3.4E-4932 到 1.1E+4932 19 位小数 sizeof: 获取一个数据类型的宽度。 123456#include "stdio.h"int main()&#123; printf("%d/n", sizeof(float)); return 0;&#125; getconf命令[bash命令]：查看处理器的字长，也可以查看其它参数，如整形数据的取值范围 123456getconf LONG_BIT #查看处理器字长getconf WORD_BIT getconf INT_MAXgetconf详解：https://www.cnblogs.com/MYSQLZOUQI/p/5552238.htmlCPU寻址能力 = 2^S (s为地址总线宽度） &lt;= CPU位数 数组数组分一维数组和多维数组，最常用的为而为数组； 一维数组初始化 123456数组名称[下标]array[0], array[1], array[2]int x[5] = &#123;1,2,3,4,5&#125; int x[] = &#123;1,2,3,4,5&#125; int x[5] = &#123;1,2,3&#125; //没有赋值的int为0，字符串为空int x[5] = &#123; ,2, 3, 4, 5&#125; //错误 二维数组和多维数组初始化 1234int a[2][3]; #先定义后赋值int a[2][3] = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125; #定义并初始化数据int a[][3] = &#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;int a[2][3] = &#123; 1,2,3,4,5,6&#125; 参考练习：https://www.cnblogs.com/lixiaomingr/p/7918646.html 常用运算符1234567891011121314151617181.算法运算符+, -, *, /, %(取余), ++(自增), --(自减)++x #等于x=x+1--xx++ #和上面的区别是：先赋值后自增x--2.关系和逻辑运算符关系运算符: &gt;, &lt;, ==, &gt;=, &lt;=, !=逻辑运算符: &amp;&amp;, ||, !关系和逻辑运算符关键概念都是返回真或者假3.位操作符(二进制底层操作)：&amp;, | , ^(异或), ~(取反), &lt;&lt;(左移), &gt;&gt;(右移)4.条件运算符运算量1 ? 运算量2 : 运算量3*先计算运算量1，为真执行运算量2，为假执行运算量3 常量常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。常量可以是任何的基本数据类型，比如整数常量、浮点常量、字符常量，或字符串字面值，也有枚举常量。 123456789101112131415161718192021212 /* 合法的 */215u /* 合法的 */0xFeeL /* 合法的 */078 /* 非法的：8 不是八进制的数字 */032UU /* 非法的：不能重复后缀 */以下是各种类型的整数常量的实例：85 /* 十进制 */0213 /* 八进制 */0x4b /* 十六进制 */30 /* 整数 */30u /* 无符号整数 */30l /* 长整数 */30ul /* 无符号长整数 */下面列举几个浮点常量的实例：3.14159 /* 合法的 */314159E-5L /* 合法的 */510E /* 非法的：不完整的指数 */210f /* 非法的：没有小数或指数 */.e55 /* 非法的：缺少整数或分数 */ 在 C 中，有两种简单的定义常量的方式：使用 #define 预处理器。使用 const 关键字。 1234567891011121314151617#include &lt;stdio.h&gt;#define LENGTH 10#define WIDTH 5#define NEWLINE '\n'int main()&#123; int area; area = LENGTH * WIDTH; printf("value of area : %d", area); printf("%c", NEWLINE); return 0;&#125; 123456789101112131415#include &lt;stdio.h&gt;int main()&#123; const int LENGTH = 10; const int WIDTH = 5; const char NEWLINE = '\n'; int area; area = LENGTH * WIDTH; printf("value of area : %d", area); printf("%c", NEWLINE); return 0;&#125; 变量变量其实只不过是程序可操作的存储区的名称。C中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。 变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C 是大小写敏感的。 123456变量的声明有两种情况：1、一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。2、另一种是不需要建立存储空间的，通过使用extern关键字声明变量名而不定义它。 例如：extern int a 其中变量 a 可以在别的文件中定义的。除非有extern关键字，否则都是变量的定义。extern int i; //声明，不是定义int i; //声明，也是定义 表达式语句12345678910111213141516171819202122232425262728293031323334353637383940414243444546471.if/switch语句if(表达式)&#123; 语句1&#125; else&#123; 语句2&#125;switch(表达式)&#123; case 常量1: 语句1; break; default: printf("test");&#125;2.循环语句(for, while, do...while)for(表达式1; 表达式2; 表达式3)&#123; 语句;&#125;while(表达式)&#123; 语句;&#125;do&#123; 语句;&#125;while (表达式)3.跳转语句(goto, continue, break)goto 语句标号；include "stdio.h"int main()&#123; int x=0; goto l1; x=1; l1:printf("x = %d\n", x); return 0;&#125; 预处理1.宏定义 1234567891011#define 宏名 字符串#define 宏名(带参数) 字符串#define PI 3.1415926#define MAX(m,n) (m&gt;n)?m:n2.文件包含#include &lt;文件名&gt;3.条件编译条件编译用于增强程序的可移植性。可以根据编译环境的不同而采取不同的编译方式。可以是目标程序变小，运行速度变快。 存储类1234567auto 只能用在函数内，即 auto 只能修饰局部变量。register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 '&amp;' 运算符（因为它没有内存位置）。static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。 static 修饰符也可以应用于全局变量。extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 'extern' 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。 函数返回1231.函数返回为空: C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status);2.函数参数为空: C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void);3.指针指向 void: 类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 void *malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型 linux创建子进程123456789101112131415161718192021222324252627282930313233343536#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt; /* 相关头文件 */#include &lt;sys/wait.h&gt;int main()&#123; pid_t pid; int sta; pid = fork(); //fork函数用于复制当前进程内容，在父进程中返回0，子进程中返回pid进程号,失败为-1 if(pid &lt; 0) &#123; printf("fork error.\n"); exit(1); &#125; if(pid == 0) &#123; printf("Child Process: \n"); printf("pid = %d\n", getpid()); printf("ppid = %d\n", getppid()); printf("gid = %d\n", getpgrp()); exit(1); &#125;else &#123; printf("Parent Process: \n"); printf("pid = %d\n", getpid()); printf("ppid = %d\n", getppid()); printf("gid = %d\n", getpgrp()); if(pid != wait(&amp;sta)) &#123; printf("wait error.\n"); exit(1); &#125; &#125; return 0;&#125; linux创建守护进程 12 linux进程间的通信管道 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;sys/wait.h&gt;#define BUFSIZE 256int main()&#123; pid_t cpid; int fifod[2]; int sta; char buf[BUFSIZE] = "Linux c is very good!!!"; if(pipe(fifod) &lt; 0) &#123; // 创建匿名管道 printf("ppe error.\n"); exit(1); &#125; cpid = fork(); // 创建子进程 if(cpid &lt; 0) &#123; printf("fork error.\n"); exit(1); &#125; printf("First cpid: %d, ppid: %d\n", cpid, getppid() ); if(cpid == 0 ) &#123; /* 子进程 */ close(fifod[0]); // 关闭读取管道 write(fifod[1], buf, sizeof(buf)); // 向写入管道中写入数据 &#125;else&#123; close(fifod[1]); // 关闭父进程管道 read(fifod[0], buf, sizeof(buf)); printf("Received message from child process:\n%s\n", buf); printf("Second cpid: %d, ppid: %d\n", cpid, getppid() ); if(cpid != wait(&amp;sta))&#123; // 等待子进程结束 printf("wait error.\n"); exit(1); &#125; &#125; printf("Third cpid: %d, ppid: %d\n", cpid, getppid() ); return 0;&#125; todohttps://cloud.tencent.com/developer/news/148736学到了数组和指针, 数据之间的类型转换，数据合并，分割，截取等操作线程,内存分配，堆，栈,常用的类 其它printf 不管什么类型的值都按照 %d %f %u %lld 的类型输出(不会进行类型转换，直接输出乱码)，如果不是相同类型需要进行强制类型转化；for example:printf(“test~~%d”,(int)10.3)Notice: num=1 and num=”1” 一个是数字一个是字符 计算机数据都是按照补码的方式存储在内存里面；（补码是在反码的基础上加1；正数的原码和反码和补码都一样）符号：~ 数据在内存二进制的数字取反（如：~74）&lt;&lt; 左移（用于内存二进制数,ch&lt;&lt;1,如：ch的值左移1一位;但不会改变ch的值,如果要改值需要赋值） 字符类型：*p 指针占4个字节（也就是32位） 0000 0000 0000 0000 0000 0000 0000 0000char类型1个字节(也就是8位)0000 0000&amp; 计算：只要有一个为0，其结果就为0| 和^ 或和异或：只要有一个为1，其结果为1;(异或有个差别就是两个都为1时，其结果为0)&lt;&lt;= 符合运算符：相当于左移数据后并赋值&amp;= for example:int ch = 4ch &amp;=1 等于 ch= ch&amp;1(也是二进制数据对比,就是ch的二进制与1的二进制进行&amp;运算)位运算只能操作整数和字符，不适用于实数运算，实数是以指数的方式表示无符号（整数）的数据在进行位运算的时候，需要自动进行转换:低字节向高字节转换的时候，会自动填充0有符号（负数） 在进行位运算的时候，需要自动进行转换:低字节向高字节转换的时候；正数会按照符号位0自动填充0；负数会按照符号位1自动填充1负数在位运算右移的时候会自动填充1，整数填充0；左移都是填充0位“反”、“与”、“或”、“异或”运算符不关心操作数的符号，知识按操作数所在字节的0、1序列进行对比，符号位会被当成普通的0或1进行处理 | 1|1 1 0|1 01|0 1 0|0 0 端口扫描样本:http://blog.csdn.net/u011721501/article/details/38642133]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
</search>
